(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (factory());
}(this, (function () { 'use strict';

/*
  Implements Substance ChangeStore API. This is just a dumb store.
  No integrity checks are made, as this is the task of DocumentEngine
*/
var ChangeStore = function ChangeStore(seed) {
  this._changes = seed || {};
};

/*
  Gets changes for a given document

  @param {String} documentId document id
  @param {Number} sinceVersion since which change (optional)
  @param {Number} toVersion up to and including version (optional)
*/
ChangeStore.prototype.getChanges = function getChanges (documentId, sinceVersion, toVersion, cb) {
  if (typeof sinceVersion === 'function') {
    cb = sinceVersion;
    sinceVersion = 0;
  } else if (typeof toVersion === 'function') {
    cb = toVersion;
    toVersion = undefined;
  }
  if (!(documentId && sinceVersion >= 0 && cb)) {
    throw new Error('Invalid arguments')
  }
  var version = this._getVersion(documentId);
  var changes = this._getChanges(documentId);
  changes = changes.slice(sinceVersion, toVersion);
  cb(null, changes, version);
};

/*
  Add a change object to the database
*/
ChangeStore.prototype.addChange = function addChange (documentId, change, cb) {
  if (!documentId || !change) {
    throw new Error('Invalid arguments')
  }
  this._addChange(documentId, change);
  var newVersion = this._getVersion(documentId);
  cb(null, newVersion);
};

/*
  Delete changes for a given documentId
*/
ChangeStore.prototype.deleteChanges = function deleteChanges (documentId, cb) {
  var deletedChanges = this._deleteChanges(documentId);
  cb(null, deletedChanges.length);
};

/*
  Gets the version number for a document
*/
ChangeStore.prototype.getVersion = function getVersion (id, cb) {
  cb(null, this._getVersion(id));
};

// Handy synchronous helpers
// -------------------------

ChangeStore.prototype._deleteChanges = function _deleteChanges (documentId) {
  var changes = this._getChanges(documentId);
  delete this._changes[documentId];
  return changes
};

ChangeStore.prototype._getVersion = function _getVersion (documentId) {
  var changes = this._changes[documentId];
  return changes ? changes.length : 0
};

ChangeStore.prototype._getChanges = function _getChanges (documentId) {
  return this._changes[documentId] || []
};

ChangeStore.prototype._addChange = function _addChange (documentId, change) {
  if (!this._changes[documentId]) {
    this._changes[documentId] = [];
  }
  this._changes[documentId].push(change);
};

function forEach(iteratee, func) {
  if (!iteratee) { return }
  if (iteratee.constructor.prototype.forEach) {
    iteratee.forEach(func);
  } else {
    Object.keys(iteratee).forEach(function(key) {
      return func(iteratee[key], key)
    });
  }
}

function isObject(val) {
  var type = typeof val;
  return Boolean(val) && (type === 'object' || type === 'function')
}

/**
  Event support.
*/
var EventEmitter = function EventEmitter () {};

var prototypeAccessors = { __events__: {} };

EventEmitter.prototype.emit = function emit (event) {
  if (event in this.__events__) {
    // console.log("Emitting event %s (%d listeners) on", event, this.__events__[event].length, this)
    // Clone the list of bindings so that handlers can remove or add handlers during the call.
    var bindings = this.__events__[event].slice();
    var args = Array.prototype.slice.call(arguments, 1);
    for (var i = 0, len = bindings.length; i < len; i++) {
      var binding = bindings[i];
      // console.log("- triggering %s on %s", event, binding.context.constructor.name)
      binding.method.apply(binding.context, args);
    }
    return true
  }
  return false
};

/**
  Subscribe a listener to an event.

  Optionally, a `priority` can be provided to control the order
  of all bindings. The default priority is 0. All listeners with the
  same priority remain in order of registration.
  A lower priority will make the listener be called later, a higher
  priority earlier.

  @param {String} event
  @param {Function} method
  @param {Object} context
  @param {Object} options
 */
EventEmitter.prototype.on = function on (event, method, context, options) {
  var priority = 0;
  if (arguments.length === 4) {
    priority = options.priority || priority;
  }
  _on.call(this, event, method, context, priority);
  this.__events__[event].sort(byPriorityDescending);
};

/**
  Unsubscrive a listener from an event.

  @param {String} event
  @param {Function} method
  @param {Object} context
  @param {Object} options
 */
EventEmitter.prototype.off = function off (event, method, context) { // eslint-disable-line no-unused-vars
  if (arguments.length === 1 && isObject(arguments[0])) {
    _disconnect.call(this, arguments[0]);
  } else {
    _off.apply(this, arguments);
  }
};

EventEmitter.prototype._debugEvents = function _debugEvents () {
  /* eslint-disable no-console */
  console.log('### EventEmitter: ', this);
  forEach(this.__events__, function(handlers, name) {
    console.log("- %s listeners for %s: ", handlers.length, name, handlers);
  });
  /* eslint-enable no-console */
};

prototypeAccessors.__events__.get = function () {
  if (!this.___events___) {
    this.___events___ = {};
  }
  return this.___events___
};

Object.defineProperties( EventEmitter.prototype, prototypeAccessors );

// sort descending as a listener with higher priority should be
// called earlier
function byPriorityDescending(a, b) {
  return b.priority - a.priority
}

/*
  Internal implementation for registering a listener.

  @param {String} event
  @param {Function} method
  @param {Object} context
 */
function _on(event, method, context, priority) {
  /* eslint-disable no-invalid-this */
  var bindings;
  validateMethod( method, context );
  if (this.__events__.hasOwnProperty(event)) {
    bindings = this.__events__[event];
  } else {
    // Auto-initialize bindings list
    bindings = this.__events__[event] = [];
  }
  // Add binding
  bindings.push({
    method: method,
    context: context || null,
    priority: priority
  });
  return this
  /*eslint-enable no-invalid-this */
}

/*
  Remove a listener.

  @param {String} event
  @param {Function} method
  @param {Object} context
 */
function _off(event, method, context) {
  /* eslint-disable no-invalid-this */
  var i, bindings;
  if ( arguments.length === 1 ) {
    // Remove all bindings for event
    delete this.__events__[event];
    return this
  }
  validateMethod( method, context );
  if ( !( event in this.__events__ ) || !this.__events__[event].length ) {
    // No matching bindings
    return this
  }
  // Default to null context
  if ( arguments.length < 3 ) {
    context = null;
  }
  // Remove matching handlers
  bindings = this.__events__[event];
  i = bindings.length;
  while ( i-- ) {
    if ( bindings[i].method === method && bindings[i].context === context ) {
      bindings.splice( i, 1 );
    }
  }
  // Cleanup if now empty
  if ( bindings.length === 0 ) {
    delete this.__events__[event];
  }
  return this
  /* eslint-enable no-invalid-this */
}


/**
  Internal implementation of disconnect.
 */
function _disconnect(context) {
  /* eslint-disable no-invalid-this */
  // Remove all connections to the context
  forEach(this.__events__, function(bindings, event) {
    var this$1 = this;

    for (var i = bindings.length-1; i>=0; i--) {
      // bindings[i] may have been removed by the previous steps
      // so check it still exists
      if (bindings[i] && bindings[i].context === context) {
        _off.call(this$1, event, bindings[i].method, context);
      }
    }
  }.bind(this));
  return this
  /* eslint-enable no-invalid-this */
}

function validateMethod(method, context) {
  // Validate method and context
  if (typeof method === 'string') {
    // Validate method
    if (context === undefined || context === null) {
      throw new Error( 'Method name "' + method + '" has no context.' )
    }
    if (!(method in context)) {
      // Technically the method does not need to exist yet: it could be
      // added before call time. But this probably signals a typo.
      throw new Error( 'Method not found: "' + method + '"' )
    }
    if (typeof context[method] !== 'function') {
      // Technically the property could be replaced by a function before
      // call time. But this probably signals a typo.
      throw new Error( 'Property "' + method + '" is not a function' )
    }
  } else if (typeof method !== 'function') {
    throw new Error( 'Invalid callback. Function or method name expected.' )
  }
}

/*
  Custom error object for all Substance related errors

  @example

  ```js
  import Err from 'substance/util/SubstanceError'
  throw new Err('Document.SelectionUpdateError', {message: 'Could not update selection.'})
  ```

  For better inspection allows you to pass a cause (the error that caused the error).
  That way we can attach context information on each level and we can also ensure
  security, by not passing the cause-chain to the client.

  Resources:
    http://www.bennadel.com/blog/2828-creating-custom-error-objects-in-node-js-with-error-capturestacktrace.htm
    https://gist.github.com/justmoon/15511f92e5216fa2624b
    https://github.com/davepacheco/node-verror/blob/master/lib/verror.js
*/

var SubstanceError = (function (Error) {
  function SubstanceError(name, options) {
    Error.call(this, name, options);
    this.name = name;
    this.message = options.message;
    this.info = options.info;
    this.errorCode = options.errorCode;
    this.cause = options.cause;

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, (SubstanceError));
    }
  }

  if ( Error ) SubstanceError.__proto__ = Error;
  SubstanceError.prototype = Object.create( Error && Error.prototype );
  SubstanceError.prototype.constructor = SubstanceError;

  SubstanceError.prototype.inspect = function inspect () {
    var parts = [];

    // This gives us a full node.js error including error name + message + stack trace
    parts.push(this.stack);

    // We just print additional info here
    if (this.info) {
      parts.push(this.info + '. ');
    }

    // We also print the cause in the same way
    if (this.cause) {
      parts.push('\nCaused by: ');

      if (this.cause.inspect) {
        // If cause is again a Substance error
        parts.push(this.cause.inspect());
      } else {
        // If not we just use Error.toString
        parts.push(this.cause.toString());
      }
    }
    return parts.join('')
  };

  return SubstanceError;
}(Error));


SubstanceError.fromJSON = function(err) {
  if (!err) { return null }
  var error = new SubstanceError(err.name, {
    message: err.message,
    info: err.info,
    errorCode: err.errorCode,
    cause: SubstanceError.fromJSON(err.cause)
  });
  return error
};

function extend() {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return Object.assign.apply(Object, args)
}

function map(iteratee, func) {
  if (!iteratee) { return [] }
  if (!func) { func = function(item) { return item }; }
  if (Array.isArray(iteratee)) {
    return iteratee.map(func)
  } else if (typeof iteratee.length !== 'undefined') {
    var l = iteratee.length;
    var result = [];
    for (var i = 0; i < l; i++) {
      result.push(func(iteratee[i], i));
    }
    return result
  } else {
    return Object.keys(iteratee).map(function(key) {
      return func(iteratee[key], key)
    })
  }
}

function isPlainObject(o) {
  return Boolean(o) && o.constructor === {}.constructor
}

function isArray(a) {
  return Array.isArray(a)
}

function isEqual(a, b) {
  if (a === b) { return true }
  if (isArray(a) && isArray(b)) {
    if (a.length !== b.length) { return false }
    for (var i = 0; i < a.length; i++) {
      if (!isEqual(a[i], b[i])) { return false }
    }
    return true
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    var akeys = Object.keys(a).sort();
    var bkeys = Object.keys(b).sort();
    if (!isEqual(akeys, bkeys)) { return false }
    for (var i$1 = 0; i$1 < akeys.length; i$1++) {
      var key = akeys[i$1];
      if (!isEqual(a[key], b[key])) { return false }
    }
    return true
  }
  return false
}

function clone(val) {
  if (isArray(val)) {
    return val.slice(0)
  }
  if (isObject(val)) {
    return Object.assign({}, val)
  }
  // we do not clone primitives
  // TODO: is that ok?
  return val
}

// Note: in iron-node window is defined - but it has window.process
// which is not there in a real browser env
var inBrowser = ( typeof window !== 'undefined');

function cloneDeep(val) {
  if (isArray(val)) {
    return _cloneArrayDeep(val);
  }
  // HACK: should we clone Files?
  // ATM we only use it when creating FileNodes
  // where the File instance is actually not serialized
  if (inBrowser && val instanceof window.File) {
    return val
  }
  if (isObject(val)) {
    return _cloneObjectDeep(val)
  }
  // primitives don't need to be cloned
  // TODO: is that ok?
  return val
}

function _cloneObjectDeep(obj) {
  var res = {};
  forEach(obj, function (val, key) {
    res[key] = cloneDeep(val);
  });
  return res
}

function _cloneArrayDeep(arr) {
  return arr.map(cloneDeep)
}

/*!
Math.uuid.js (v1.4)
http://www.broofa.com
mailto:robert@broofa.com
Copyright (c) 2010 Robert Kieffer
Dual licensed under the MIT and GPL licenses.
*/

/**
 * Generates a unique id.
 *
 * @param {String} [prefix] if provided the UUID will be prefixed.
 * @param {Number} [len] if provided a UUID with given length will be created.
 * @return A generated uuid.
 */
function uuid(prefix, len) {
  if (prefix && prefix[prefix.length-1] !== "-") {
    prefix = prefix.concat("-");
  }
  var chars = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');
  var uuid = [];
  var radix = 16;
  var idx;
  len = len || 32;
  if (len) {
    // Compact form
    for (idx = 0; idx < len; idx++) { uuid[idx] = chars[0 | Math.random()*radix]; }
  } else {
    // rfc4122, version 4 form
    var r;
    // rfc4122 requires these characters
    uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
    uuid[14] = '4';
    // Fill in random data.  At i==19 set the high bits of clock sequence as
    // per rfc4122, sec. 4.1.5
    for (idx = 0; idx < 36; idx++) {
      if (!uuid[idx]) {
        r = 0 | Math.random()*16;
        uuid[idx] = chars[(idx === 19) ? (r & 0x3) | 0x8 : r];
      }
    }
  }
  return (prefix ? prefix : "") + uuid.join('');
}

function isNumber(n) {
  return typeof n === 'number'
}

function isNil(o) {
  return o === null || o === undefined
}

function isString(s) {
  return typeof s === 'string'
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @type {Function}
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$1 = Array.isArray;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$1(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */
var funcTag = '[object Function]';
var genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto$1.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array and weak map constructors,
  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject$1(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Checks if `value` is a global object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
 */
function checkGlobal(value) {
  return (value && value.Object === Object) ? value : null;
}

/** Detect free variable `global` from Node.js. */
var freeGlobal = checkGlobal(typeof global == 'object' && global);

/** Detect free variable `self`. */
var freeSelf = checkGlobal(typeof self == 'object' && self);

/** Detect `this` as the global object. */
var thisGlobal = checkGlobal(typeof undefined == 'object' && undefined);

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || thisGlobal || Function('return this')();

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = Function.prototype.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$2.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var this$1 = this;

  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this$1.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var this$1 = this;

  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this$1.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root, 'Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$1 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var this$1 = this;

  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this$1.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/** Built-in value references. */
var Symbol = root.Symbol;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$1 = objectProto$4.toString;

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString$1.call(value) == symbolTag);
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined;
var symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(\.|\[\])(?:\4|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  var result = [];
  toString(string).replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray$1(value) ? value : stringToPath(value);
}

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is used in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$3.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]);
    if (isObject$1(nested)) {
      var newValue = value;
      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;
        if (newValue === undefined) {
          newValue = objValue == null
            ? (isIndex(path[index + 1]) ? [] : {})
            : objValue;
        }
      }
      assignValue(nested, key, newValue);
    }
    nested = nested[key];
  }
  return object;
}

/**
 * This method is like `_.set` except that it accepts `customizer` which is
 * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
 * path creation is handled by the method instead. The `customizer` is invoked
 * with three arguments: (nsValue, key, nsObject).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {};
 *
 * _.setWith(object, '[0][1]', 'a', Object);
 * // => { '0': { '1': 'a' } }
 */
function setWith(object, path, value, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  return object == null ? object : baseSet(object, path, value, customizer);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetPrototype = Object.getPrototypeOf;

/**
 * Gets the `[[Prototype]]` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {null|Object} Returns the `[[Prototype]]`.
 */
function getPrototype(value) {
  return nativeGetPrototype(Object(value));
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
  // that are composed entirely of index properties, return `false` for
  // `hasOwnProperty` checks of them.
  return object != null &&
    (hasOwnProperty$4.call(object, key) ||
      (typeof object == 'object' && key in object && getPrototype(object) === null));
}

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array ? array.length : 0;
  return length ? array[length - 1] : undefined;
}

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
}

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);
  object = parent(object, path);

  var key = toKey(last(path));
  return !(object != null && baseHas(object, key)) || delete object[key];
}

/**
 * Removes the property at `path` of `object`.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 7 } }] };
 * _.unset(object, 'a[0].b.c');
 * // => true
 *
 * console.log(object);
 * // => { 'a': [{ 'b': {} }] };
 *
 * _.unset(object, ['a', '0', 'b', 'c']);
 * // => true
 *
 * console.log(object);
 * // => { 'a': [{ 'b': {} }] };
 */
function unset(object, path) {
  return object == null ? true : baseUnset(object, path);
}

/*
  An object that can be access via path API.

  @example

  var obj = new PathObject({a: "aVal", b: {b1: 'b1Val', b2: 'b2Val'}})
*/

var PathObject = function PathObject(root) {
  if (root) {
    this.__root__ = root;
  }
};

PathObject.prototype.contains = function contains (id) {
  return Boolean(this.getRoot()[id])
};

PathObject.prototype.getRoot = function getRoot () {
  if (this.__root__) {
    return this.__root__
  } else {
    return this
  }
};

/**
  Get value at path

  @return {object} The value stored for a given path

  @example

  obj.get(['b', 'b1'])
  => b1Val
*/
PathObject.prototype.get = function get$1 (path) {
  if (!path) {
    return undefined
  }
  if (isString(path)) {
    return this.getRoot()[path]
  }
  if (arguments.length > 1) {
    path = Array.prototype.slice(arguments, 0);
  }
  if (!isArray(path)) {
    throw new Error('Illegal argument for PathObject.get()')
  }
  return get(this.getRoot(), path)
};

PathObject.prototype.set = function set (path, value) {
  if (!path) {
    throw new Error('Illegal argument: PathObject.set(>path<, value) - path is mandatory.')
  }
  if (isString(path)) {
    this.getRoot()[path] = value;
  } else {
    setWith(this.getRoot(), path, value);
  }
};

PathObject.prototype.delete = function delete$1 (path) {
  if (isString(path)) {
    delete this.getRoot()[path];
  } else if (path.length === 1) {
    delete this.getRoot()[path[0]];
  } else {
    var success = unset(this.getRoot(), path);
    if (!success) {
      throw new Error('Could not delete property at path' + path)
    }
  }
};

PathObject.prototype.clear = function clear () {
  var root = this.getRoot();
  for (var key in root) {
    if (root.hasOwnProperty(key)) {
      delete root[key];
    }
  }
};

PathObject.prototype._isPathObject = true;

var Conflict = (function (Error) {
  function Conflict(a, b) {
    Error.call(this, "Conflict: " + JSON.stringify(a) +" vs " + JSON.stringify(b));
    this.a = a;
    this.b = b;
  }

  if ( Error ) Conflict.__proto__ = Error;
  Conflict.prototype = Object.create( Error && Error.prototype );
  Conflict.prototype.constructor = Conflict;

  return Conflict;
}(Error));

var INSERT = "insert";
var DELETE$1 = "delete";

var TextOperation = function TextOperation(data) {
  if (!data || data.type === undefined || data.pos === undefined || data.str === undefined) {
    throw new Error("Illegal argument: insufficient data.")
  }
  // 'insert' or 'delete'
  this.type = data.type;
  // the position where to apply the operation
  this.pos = data.pos;
  // the string to delete or insert
  this.str = data.str;
  // sanity checks
  if(!this.isInsert() && !this.isDelete()) {
    throw new Error("Illegal type.")
  }
  if (!isString(this.str)) {
    throw new Error("Illegal argument: expecting string.")
  }
  if (!isNumber(this.pos) || this.pos < 0) {
    throw new Error("Illegal argument: expecting positive number as pos.")
  }
};

TextOperation.prototype.apply = function apply (str) {
  if (this.isEmpty()) { return str }
  if (this.type === INSERT) {
    if (str.length < this.pos) {
      throw new Error("Provided string is too short.")
    }
    if (str.splice) {
      return str.splice(this.pos, 0, this.str)
    } else {
      return str.slice(0, this.pos).concat(this.str).concat(str.slice(this.pos))
    }
  }
  else /* if (this.type === DELETE) */ {
    if (str.length < this.pos + this.str.length) {
      throw new Error("Provided string is too short.")
    }
    if (str.splice) {
      return str.splice(this.pos, this.str.length)
    } else {
      return str.slice(0, this.pos).concat(str.slice(this.pos + this.str.length))
    }
  }
};

TextOperation.prototype.clone = function clone () {
  return new TextOperation(this)
};

TextOperation.prototype.isNOP = function isNOP () {
  return this.type === "NOP" || this.str.length === 0
};

TextOperation.prototype.isInsert = function isInsert () {
  return this.type === INSERT
};

TextOperation.prototype.isDelete = function isDelete () {
  return this.type === DELETE$1
};

TextOperation.prototype.getLength = function getLength () {
  return this.str.length
};

TextOperation.prototype.invert = function invert () {
  var data = {
    type: this.isInsert() ? DELETE$1 : INSERT,
    pos: this.pos,
    str: this.str
  };
  return new TextOperation(data)
};

TextOperation.prototype.hasConflict = function hasConflict$1 (other) {
  return hasConflict$1(this, other)
};

TextOperation.prototype.isEmpty = function isEmpty () {
  return this.str.length === 0
};

TextOperation.prototype.toJSON = function toJSON () {
  return {
    type: this.type,
    pos: this.pos,
    str: this.str
  }
};

TextOperation.prototype.toString = function toString () {
  return ["(", (this.isInsert() ? INSERT : DELETE$1), ",", this.pos, ",'", this.str, "')"].join('')
};

TextOperation.prototype._isOperation = true;
TextOperation.prototype._isTextOperation = true;

function hasConflict$1(a, b) {
  // Insert vs Insert:
  //
  // Insertions are conflicting iff their insert position is the same.
  if (a.type === INSERT && b.type === INSERT) { return (a.pos === b.pos) }
  // Delete vs Delete:
  //
  // Deletions are conflicting if their ranges overlap.
  if (a.type === DELETE$1 && b.type === DELETE$1) {
    // to have no conflict, either `a` should be after `b` or `b` after `a`, otherwise.
    return !(a.pos >= b.pos + b.str.length || b.pos >= a.pos + a.str.length)
  }
  // Delete vs Insert:
  //
  // A deletion and an insertion are conflicting if the insert position is within the deleted range.
  var del, ins;
  if (a.type === DELETE$1) {
    del = a; ins = b;
  } else {
    del = b; ins = a;
  }
  return (ins.pos >= del.pos && ins.pos < del.pos + del.str.length)
}

// Transforms two Insertions
// --------

function transform_insert_insert(a, b) {
  if (a.pos === b.pos) {
    b.pos += a.str.length;
  }
  else if (a.pos < b.pos) {
    b.pos += a.str.length;
  }
  else {
    a.pos += b.str.length;
  }
}

// Transform two Deletions
// --------
//

function transform_delete_delete$1(a, b, first) {
  // reduce to a normalized case
  if (a.pos > b.pos) {
    return transform_delete_delete$1(b, a, !first)
  }
  if (a.pos === b.pos && a.str.length > b.str.length) {
    return transform_delete_delete$1(b, a, !first)
  }
  // take out overlapping parts
  if (b.pos < a.pos + a.str.length) {
    var s = b.pos - a.pos;
    var s1 = a.str.length - s;
    var s2 = s + b.str.length;
    a.str = a.str.slice(0, s) + a.str.slice(s2);
    b.str = b.str.slice(s1);
    b.pos -= s;
  } else {
    b.pos -= a.str.length;
  }
}

// Transform Insert and Deletion
// --------
//

function transform_insert_delete(a, b) {
  if (a.type === DELETE$1) {
    return transform_insert_delete(b, a)
  }
  // we can assume, that a is an insertion and b is a deletion
  // a is before b
  if (a.pos <= b.pos) {
    b.pos += a.str.length;
  }
  // a is after b
  else if (a.pos >= b.pos + b.str.length) {
    a.pos -= b.str.length;
  }
  // Note: this is a conflict case the user should be noticed about
  // If applied still, the deletion takes precedence
  // a.pos > b.pos && <= b.pos + b.length
  else {
    var s = a.pos - b.pos;
    b.str = b.str.slice(0, s) + a.str + b.str.slice(s);
    a.str = "";
  }
}

function transform$1(a, b, options) {
  options = options || {};
  if (options["no-conflict"] && hasConflict$1(a, b)) {
    throw new Conflict(a, b)
  }
  if (!options.inplace) {
    a = a.clone();
    b = b.clone();
  }
  if (a.type === INSERT && b.type === INSERT) {
    transform_insert_insert(a, b);
  }
  else if (a.type === DELETE$1 && b.type === DELETE$1) {
    transform_delete_delete$1(a, b, true);
  }
  else {
    transform_insert_delete(a,b);
  }
  return [a, b]
}

TextOperation.transform = function() {
  return transform$1.apply(null, arguments)
};

/* Factories */

TextOperation.Insert = function(pos, str) {
  return new TextOperation({ type: INSERT, pos: pos, str: str })
};

TextOperation.Delete = function(pos, str) {
  return new TextOperation({ type: DELETE$1, pos: pos, str: str })
};

TextOperation.INSERT = INSERT;
TextOperation.DELETE = DELETE$1;

TextOperation.fromJSON = function(data) {
  return new TextOperation(data)
};

var NOP$1 = "NOP";
var DELETE$2 = "delete";
var INSERT$1 = "insert";

var ArrayOperation = function ArrayOperation(data) {
  if (!data || !data.type) {
    throw new Error("Illegal argument: insufficient data.")
  }
  this.type = data.type;
  if (this.type === NOP$1) { return }

  if (this.type !== INSERT$1 && this.type !== DELETE$2) {
    throw new Error("Illegal type.")
  }
  // the position where to apply the operation
  this.pos = data.pos;
  // the value to insert or delete
  this.val = data.val;
  if (!isNumber(this.pos) || this.pos < 0) {
    throw new Error("Illegal argument: expecting positive number as pos.")
  }
};

ArrayOperation.prototype.apply = function apply (array) {
  if (this.type === NOP$1) {
    return array
  }
  if (this.type === INSERT$1) {
    if (array.length < this.pos) {
      throw new Error("Provided array is too small.")
    }
    array.splice(this.pos, 0, this.val);
    return array
  }
  // Delete
  else /* if (this.type === DELETE) */ {
    if (array.length < this.pos) {
      throw new Error("Provided array is too small.")
    }
    if (!isEqual(array[this.pos], this.val)) {
      throw Error("Unexpected value at position " + this.pos + ". Expected " + this.val + ", found " + array[this.pos])
    }
    array.splice(this.pos, 1);
    return array
  }
};

ArrayOperation.prototype.clone = function clone () {
  var data = {
    type: this.type,
    pos: this.pos,
    val: cloneDeep(this.val)
  };
  return new ArrayOperation(data)
};

ArrayOperation.prototype.invert = function invert () {
  var data = this.toJSON();
  if (this.type === NOP$1) { data.type = NOP$1; }
  else if (this.type === INSERT$1) { data.type = DELETE$2; }
  else /* if (this.type === DELETE) */ { data.type = INSERT$1; }
  return new ArrayOperation(data)
};

ArrayOperation.prototype.hasConflict = function hasConflict (other) {
  return ArrayOperation.hasConflict(this, other)
};

ArrayOperation.prototype.toJSON = function toJSON () {
  var result = {
    type: this.type,
  };
  if (this.type === NOP$1) { return result }
  result.pos = this.pos;
  result.val = cloneDeep(this.val);
  return result
};

ArrayOperation.prototype.isInsert = function isInsert () {
  return this.type === INSERT$1
};

ArrayOperation.prototype.isDelete = function isDelete () {
  return this.type === DELETE$2
};

ArrayOperation.prototype.getOffset = function getOffset () {
  return this.pos
};

ArrayOperation.prototype.getValue = function getValue () {
  return this.val
};

ArrayOperation.prototype.isNOP = function isNOP () {
  return this.type === NOP$1
};

ArrayOperation.prototype.toString = function toString () {
  return ["(", (this.isInsert() ? INSERT$1 : DELETE$2), ",", this.getOffset(), ",'", this.getValue(), "')"].join('')
};

ArrayOperation.prototype._isOperation = true;
ArrayOperation.prototype._isArrayOperation = true;

function hasConflict$2(a, b) {
  if (a.type === NOP$1 || b.type === NOP$1) { return false }
  if (a.type === INSERT$1 && b.type === INSERT$1) {
    return a.pos === b.pos
  } else {
    return false
  }
}

function transform_insert_insert$1(a, b) {
  if (a.pos === b.pos) {
    b.pos += 1;
  }
  // a before b
  else if (a.pos < b.pos) {
    b.pos += 1;
  }
  // a after b
  else {
    a.pos += 1;
  }
}

function transform_delete_delete$2(a, b) {
  // turn the second of two concurrent deletes into a NOP
  if (a.pos === b.pos) {
    b.type = NOP$1;
    a.type = NOP$1;
    return
  }
  if (a.pos < b.pos) {
    b.pos -= 1;
  } else {
    a.pos -= 1;
  }
}

function transform_insert_delete$1(a, b) {
  // reduce to a normalized case
  if (a.type === DELETE$2) {
    var tmp = a;
    a = b;
    b = tmp;
  }
  if (a.pos <= b.pos) {
    b.pos += 1;
  } else {
    a.pos -= 1;
  }
}

var transform$2 = function(a, b, options) {
  options = options || {};
  // enable conflicts when you want to notify the user of potential problems
  // Note that even in these cases, there is a defined result.
  if (options['no-conflict'] && hasConflict$2(a, b)) {
    throw new Conflict(a, b)
  }
  // this is used internally only as optimization, e.g., when rebasing an operation
  if (!options.inplace) {
    a = a.clone();
    b = b.clone();
  }
  if (a.type === NOP$1 || b.type === NOP$1) {
    // nothing to transform
  }
  else if (a.type === INSERT$1 && b.type === INSERT$1) {
    transform_insert_insert$1(a, b);
  }
  else if (a.type === DELETE$2 && b.type === DELETE$2) {
    transform_delete_delete$2(a, b);
  }
  else {
    transform_insert_delete$1(a, b);
  }
  return [a, b]
};

ArrayOperation.transform = transform$2;
ArrayOperation.hasConflict = hasConflict$2;

/* Factories */

ArrayOperation.Insert = function(pos, val) {
  return new ArrayOperation({type:INSERT$1, pos: pos, val: val})
};

ArrayOperation.Delete = function(pos, val) {
  return new ArrayOperation({ type:DELETE$2, pos: pos, val: val })
};

ArrayOperation.fromJSON = function(data) {
  return new ArrayOperation(data)
};

ArrayOperation.NOP = NOP$1;
ArrayOperation.DELETE = DELETE$2;
ArrayOperation.INSERT = INSERT$1;

var SHIFT = 'shift';

var CoordinateOperation = function CoordinateOperation(data) {
  if (!data || data.type === undefined) {
    throw new Error("Illegal argument: insufficient data.")
  }
  // 'shift'
  this.type = data.type;
  // the position where to apply the operation
  this.val = data.val;
  // sanity checks
  if(!this.isShift()) {
    throw new Error("Illegal type.")
  }
  if (!isNumber(this.val)) {
    throw new Error("Illegal argument: expecting number as shift value.")
  }
};

CoordinateOperation.prototype.apply = function apply (coor) {
  coor.offset = coor.offset + this.val;
};

CoordinateOperation.prototype.isShift = function isShift () {
  return this.type === SHIFT
};

CoordinateOperation.prototype.isNOP = function isNOP () {
  switch (this.type) {
    case SHIFT: {
      return this.val === 0
    }
    default:
      return false
  }
};

CoordinateOperation.prototype.clone = function clone () {
  return new CoordinateOperation(this)
};

CoordinateOperation.prototype.invert = function invert () {
  var data;
  switch (this.type) {
    case SHIFT:
      data = {
        type: SHIFT,
        val: -this.val
      };
      break
    default:
      throw new Error('Invalid type.')
  }
  return new CoordinateOperation(data)
};

CoordinateOperation.prototype.hasConflict = function hasConflict () {
  // TODO: support conflict detection?
  return false
};

CoordinateOperation.prototype.toJSON = function toJSON () {
  return {
    type: this.type,
    val: this.val
  }
};

CoordinateOperation.prototype.toString = function toString () {
  return ["(", (this.type), ",", this.val, "')"].join('')
};

CoordinateOperation.prototype._isOperation = true;
CoordinateOperation.prototype._isCoordinateOperation = true;

function transform_shift_shift(a, b) {
  a.val += b.val;
  b.val += a.val;
}

function transform$3(a, b, options) {
  options = options || {};
  // TODO: support conflict detection?
  if (!options.inplace) {
    a = a.clone();
    b = b.clone();
  }
  if (a.type === SHIFT && b.type === SHIFT) {
    transform_shift_shift(a, b);
  }
  else {
    throw new Error('Illegal type')
  }
  return [a, b]
}

CoordinateOperation.transform = function() {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return transform$3.apply(void 0, args)
};

CoordinateOperation.fromJSON = function(json) {
  return new CoordinateOperation(json)
};

CoordinateOperation.Shift = function(val) {
  return new CoordinateOperation({
    type: SHIFT,
    val: val
  })
};

var NOP = "NOP";
var CREATE = "create";
var DELETE = 'delete';
var UPDATE = 'update';
var SET = 'set';

var ObjectOperation = function ObjectOperation(data) {
  if (!data) {
    throw new Error('Data of ObjectOperation is missing.')
  }
  if (!data.type) {
    throw new Error('Invalid data: type is mandatory.')
  }
  this.type = data.type;
  if (data.type === NOP) {
    return
  }
  this.path = data.path;
  if (!data.path) {
    throw new Error('Invalid data: path is mandatory.')
  }
  if (this.type === CREATE || this.type === DELETE) {
    if (!data.val) {
      throw new Error('Invalid data: value is missing.')
    }
    this.val = data.val;
  }
  else if (this.type === UPDATE) {
    if (data.diff) {
      this.diff = data.diff;
      if (data.diff._isTextOperation) {
        this.propertyType = 'string';
      } else if (data.diff._isArrayOperation) {
        this.propertyType = 'array';
      } else if (data.diff._isCoordinateOperation) {
        this.propertyType = 'coordinate';
      } else {
        throw new Error('Invalid data: diff must be a TextOperation or an ArrayOperation.')
      }
    } else {
      throw new Error("Invalid data: diff is mandatory for update operation.")
    }
  }
  else if (this.type === SET) {
    this.val = data.val;
    this.original = data.original;
  } else {
    throw new Error('Invalid type: '+ data.type)
  }
};

ObjectOperation.prototype.apply = function apply (obj) {
  if (this.type === NOP) { return obj }
  var adapter;
  if (obj._isPathObject) {
    adapter = obj;
  } else {
    adapter = new PathObject(obj);
  }
  if (this.type === CREATE) {
    adapter.set(this.path, cloneDeep(this.val));
    return obj
  }
  if (this.type === DELETE) {
    adapter.delete(this.path, "strict");
  }
  else if (this.type === UPDATE) {
    var diff = this.diff;
    switch (this.propertyType) {
      case 'array': {
        var arr = adapter.get(this.path);
        diff.apply(arr);
        break
      }
      case 'string': {
        var str = adapter.get(this.path);
        if (isNil(str)) { str = ''; }
        str = diff.apply(str);
        adapter.set(this.path, str);
        break
      }
      case 'coordinate': {
        var coor = adapter.get(this.path);
        if (!coor) { throw new Error('No coordinate with path '+this.path) }
        diff.apply(coor);
        break
      }
      default:
        throw new Error('Invalid state.')
    }
  }
  else if (this.type === SET) {
    // clone here as the operations value must not be changed
    adapter.set(this.path, cloneDeep(this.val));
  }
  else {
    throw new Error('Invalid type.')
  }
  return obj
};

ObjectOperation.prototype.clone = function clone () {
  var data = {
    type: this.type,
    path: this.path,
  };
  if (this.val) {
    data.val = cloneDeep(this.val);
  }
  if (this.diff) {
    data.diff = this.diff.clone();
  }
  return new ObjectOperation(data)
};

ObjectOperation.prototype.isNOP = function isNOP () {
  if (this.type === NOP) { return true }
  else if (this.type === UPDATE) { return this.diff.isNOP() }
};

ObjectOperation.prototype.isCreate = function isCreate () {
  return this.type === CREATE
};

ObjectOperation.prototype.isDelete = function isDelete () {
  return this.type === DELETE
};

ObjectOperation.prototype.isUpdate = function isUpdate (propertyType) {
  if (propertyType) {
    return (this.type === UPDATE && this.propertyType === propertyType)
  } else {
    return this.type === UPDATE
  }
};

ObjectOperation.prototype.isSet = function isSet () {
  return this.type === SET
};

ObjectOperation.prototype.invert = function invert () {
  if (this.type === NOP) {
    return new ObjectOperation({ type: NOP })
  }
  var result = new ObjectOperation(this);
  if (this.type === CREATE) {
    result.type = DELETE;
  }
  else if (this.type === DELETE) {
    result.type = CREATE;
  }
  else if (this.type === UPDATE) {
    var invertedDiff;
    if (this.diff._isTextOperation) {
      invertedDiff = TextOperation.fromJSON(this.diff.toJSON()).invert();
    } else if (this.diff._isArrayOperation) {
      invertedDiff = ArrayOperation.fromJSON(this.diff.toJSON()).invert();
    } else if (this.diff._isCoordinateOperation) {
      invertedDiff = CoordinateOperation.fromJSON(this.diff.toJSON()).invert();
    } else {
      throw new Error('Illegal type')
    }
    result.diff = invertedDiff;
  }
  else /* if (this.type === SET) */ {
    result.val = this.original;
    result.original = this.val;
  }
  return result
};

ObjectOperation.prototype.hasConflict = function hasConflict (other) {
  return ObjectOperation.hasConflict(this, other)
};

ObjectOperation.prototype.toJSON = function toJSON () {
  if (this.type === NOP) {
    return { type: NOP }
  }
  var data = {
    type: this.type,
    path: this.path,
  };
  if (this.type === CREATE || this.type === DELETE) {
    data.val = this.val;
  }
  else if (this.type === UPDATE) {
    if (this.diff._isTextOperation) {
      data.propertyType = "string";
    } else if (this.diff._isArrayOperation) {
      data.propertyType = "array";
    } else if (this.diff._isCoordinateOperation) {
      data.propertyType = "coordinate";
    } else {
      throw new Error('Invalid property type.')
    }
    data.diff = this.diff.toJSON();
  }
  else /* if (this.type === SET) */ {
    data.val = this.val;
    data.original = this.original;
  }
  return data
};

ObjectOperation.prototype.getType = function getType () {
  return this.type
};

ObjectOperation.prototype.getPath = function getPath () {
  return this.path
};

ObjectOperation.prototype.getValue = function getValue () {
  return this.val
};

ObjectOperation.prototype.getOldValue = function getOldValue () {
  return this.original
};

ObjectOperation.prototype.getValueOp = function getValueOp () {
  return this.diff
};

ObjectOperation.prototype.toString = function toString () {
  switch (this.type) {
    case CREATE:
      return ["(+,", JSON.stringify(this.path), JSON.stringify(this.val), ")"].join('')
    case DELETE:
      return ["(-,", JSON.stringify(this.path), JSON.stringify(this.val), ")"].join('')
    case UPDATE:
      return ["(>>,", JSON.stringify(this.path), this.propertyType, this.diff.toString(), ")"].join('')
    case SET:
      return ["(=,", JSON.stringify(this.path), this.val, this.original, ")"].join('')
    case NOP:
      return "NOP"
    default:
      throw new Error('Invalid type')
  }
};

ObjectOperation.prototype._isOperation = true;
ObjectOperation.prototype._isObjectOperation = true;

/* Low level implementation */

function hasConflict(a, b) {
  if (a.type === NOP || b.type === NOP) { return false }
  return isEqual(a.path, b.path)
}

function transform_delete_delete(a, b) {
  // both operations have the same effect.
  // the transformed operations are turned into NOPs
  a.type = NOP;
  b.type = NOP;
}

function transform_create_create() {
  throw new Error("Can not transform two concurring creates of the same property")
}

function transform_delete_create() {
  throw new Error('Illegal state: can not create and delete a value at the same time.')
}

function transform_delete_update(a, b, flipped) {
  if (a.type !== DELETE) {
    return transform_delete_update(b, a, true)
  }
  var op;
  switch (b.propertyType) {
    case 'string':
      op = TextOperation.fromJSON(b.diff);
      break
    case 'array':
      op = ArrayOperation.fromJSON(b.diff);
      break
    case 'coordinate':
      op = CoordinateOperation.fromJSON(b.diff);
      break
    default:
      throw new Error('Illegal type')
  }
  // (DELETE, UPDATE) is transformed into (DELETE, CREATE)
  if (!flipped) {
    a.type = NOP;
    b.type = CREATE;
    b.val = op.apply(a.val);
  }
  // (UPDATE, DELETE): the delete is updated to delete the updated value
  else {
    a.val = op.apply(a.val);
    b.type = NOP;
  }
}

function transform_create_update() {
  // it is not possible to reasonably transform this.
  throw new Error("Can not transform a concurring create and update of the same property")
}

function transform_update_update(a, b) {
  // Note: this is a conflict the user should know about
  var op_a, op_b, t;
  switch(b.propertyType) {
    case 'string':
      op_a = TextOperation.fromJSON(a.diff);
      op_b = TextOperation.fromJSON(b.diff);
      t = TextOperation.transform(op_a, op_b, {inplace: true});
      break
    case 'array':
      op_a = ArrayOperation.fromJSON(a.diff);
      op_b = ArrayOperation.fromJSON(b.diff);
      t = ArrayOperation.transform(op_a, op_b, {inplace: true});
      break
    case 'coordinate':
      op_a = CoordinateOperation.fromJSON(a.diff);
      op_b = CoordinateOperation.fromJSON(b.diff);
      t = CoordinateOperation.transform(op_a, op_b, {inplace: true});
      break
    default:
      throw new Error('Illegal type')
  }
  a.diff = t[0];
  b.diff = t[1];
}

function transform_create_set() {
  throw new Error('Illegal state: can not create and set a value at the same time.')
}

function transform_delete_set(a, b, flipped) {
  if (a.type !== DELETE) { return transform_delete_set(b, a, true) }
  if (!flipped) {
    a.type = NOP;
    b.type = CREATE;
    b.original = undefined;
  } else {
    a.val = b.val;
    b.type = NOP;
  }
}

function transform_update_set() {
  throw new Error("Unresolvable conflict: update + set.")
}

function transform_set_set(a, b) {
  a.type = NOP;
  b.original = a.val;
}

var _NOP = 0;
var _CREATE = 1;
var _DELETE = 2;
var _UPDATE = 4;
var _SET = 8;

var CODE = (function () {
  var c = {};
  c[NOP] =_NOP;
  c[CREATE] = _CREATE;
  c[DELETE] = _DELETE;
  c[UPDATE] = _UPDATE;
  c[SET] = _SET;
  return c
})();

var __transform__ = (function () {
  /* eslint-disable no-multi-spaces */
  var t = {};
  t[_DELETE | _DELETE] = transform_delete_delete;
  t[_DELETE | _CREATE] = transform_delete_create;
  t[_DELETE | _UPDATE] = transform_delete_update;
  t[_CREATE | _CREATE] = transform_create_create;
  t[_CREATE | _UPDATE] = transform_create_update;
  t[_UPDATE | _UPDATE] = transform_update_update;
  t[_CREATE | _SET   ] = transform_create_set;
  t[_DELETE | _SET   ] = transform_delete_set;
  t[_UPDATE | _SET   ] = transform_update_set;
  t[_SET    | _SET   ] = transform_set_set;
  /* eslint-enable no-multi-spaces */
  return t
})();

function transform(a, b, options) {
  options = options || {};
  if (options['no-conflict'] && hasConflict(a, b)) {
    throw new Conflict(a, b)
  }
  if (!options.inplace) {
    a = a.clone();
    b = b.clone();
  }
  if (a.isNOP() || b.isNOP()) {
    return [a, b]
  }
  var sameProp = isEqual(a.path, b.path);
  // without conflict: a' = a, b' = b
  if (sameProp) {
    __transform__[CODE[a.type] | CODE[b.type]](a,b);
  }
  return [a, b]
}

ObjectOperation.transform = transform;
ObjectOperation.hasConflict = hasConflict;

/* Factories */

ObjectOperation.Create = function(idOrPath, val) {
  var path;
  if (isString(idOrPath)) {
    path = [idOrPath];
  } else {
    path = idOrPath;
  }
  return new ObjectOperation({type: CREATE, path: path, val: val})
};

ObjectOperation.Delete = function(idOrPath, val) {
  var path;
  if (isString(idOrPath)) {
    path = [idOrPath];
  } else {
    path = idOrPath;
  }
  return new ObjectOperation({type: DELETE, path: path, val: val})
};

ObjectOperation.Update = function(path, op) {
  return new ObjectOperation({
    type: UPDATE,
    path: path,
    diff: op
  })
};

ObjectOperation.Set = function(path, oldVal, newVal) {
  return new ObjectOperation({
    type: SET,
    path: path,
    val: cloneDeep(newVal),
    original: cloneDeep(oldVal)
  })
};

ObjectOperation.fromJSON = function(data) {
  data = cloneDeep(data);
  if (data.type === "update") {
    switch (data.propertyType) {
      case "string":
        data.diff = TextOperation.fromJSON(data.diff);
        break
      case "array":
        data.diff = ArrayOperation.fromJSON(data.diff);
        break
      case "coordinate":
        data.diff = CoordinateOperation.fromJSON(data.diff);
        break
      default:
        throw new Error("Unsupported update diff:" + JSON.stringify(data.diff))
    }
  }
  var op = new ObjectOperation(data);
  return op
};

ObjectOperation.NOP = NOP;
ObjectOperation.CREATE = CREATE;
ObjectOperation.DELETE = DELETE;
ObjectOperation.UPDATE = UPDATE;
ObjectOperation.SET = SET;

/*
  Specification:

  - create:
    ```
    'c <JSON.stringify(data)>'
    'c { id: "1123", type: "paragraph", content: ""}'
    ```
  - delete:
    ```
    'd <JSON.stringify(data)>'
    'd { id: "1123", type: "paragraph", content: ""}'
    ```
  - set a property
    ```
    's <property path> <value> <old value>'
    's p1.content foo'
    ```
  - update a property
    ```
    'u <property path> <primitive op>'
    'u p1.content t+ 4 foo'
    ```

Primitive type operations:

  - insert text
    ```
    't+ <pos> <string>'
    't+ 4 foo'
    ```
  - delete text
    ```
    't- <pos> <string>'
    't- 4 foo'
    ```
  - insert value into array
    ```
    'a+ <pos> <value>'
    'a+ 0 p1'
    ```
  - delete value from array
    ```
    'a- <pos> <value>'
    'a- 0 p1'
    ```
*/

var OperationSerializer = function OperationSerializer() {
  this.SEPARATOR = '\t';
};

OperationSerializer.prototype.serialize = function serialize (op) {
  var out = [];
  switch (op.type) {
    case 'create':
      out.push('c');
      out.push(op.val.id);
      out.push(op.val);
      break
    case 'delete':
      out.push('d');
      out.push(op.val.id);
      out.push(op.val);
      break
    case 'set':
      out.push('s');
      out.push(op.path.join('.'));
      out.push(op.val);
      out.push(op.original);
      break
    case 'update':
      out.push('u');
      out.push(op.path.join('.'));
      Array.prototype.push.apply(out, this.serializePrimitiveOp(op.diff));
      break
    default:
      throw new Error('Unsupported operation type.')
  }
  return out
};

OperationSerializer.prototype.serializePrimitiveOp = function serializePrimitiveOp (op) {
  var out = [];
  if (op._isTextOperation) {
    if (op.isInsert()) {
      out.push('t+');
    } else if (op.isDelete()) {
      out.push('t-');
    }
    out.push(op.pos);
    out.push(op.str);
  } else if (op._isArrayOperation) {
    if (op.isInsert()) {
      out.push('a+');
    } else if (op.isDelete()) {
      out.push('a-');
    }
    out.push(op.pos);
    out.push(op.val);
  } else if (op._isCoordinateOperation) {
    if (op.isShift()) {
      out.push('c>>');
    } else {
      throw new Error('Unsupported CoordinateOperation type.')
    }
    out.push(op.pos);
    out.push(op.val);
  } else {
    throw new Error('Unsupported operation type.')
  }
  return out
};

OperationSerializer.prototype.deserialize = function deserialize (str, tokenizer) {
  if (!tokenizer) {
    tokenizer = new Tokenizer(str, this.SEPARATOR);
  }
  var type = tokenizer.getString();
  var op, path, val, oldVal, diff;
  switch (type) {
    case 'c':
      path = tokenizer.getPath();
      val = tokenizer.getObject();
      op = ObjectOperation.Create(path, val);
      break
    case 'd':
      path = tokenizer.getPath();
      val = tokenizer.getObject();
      op = ObjectOperation.Delete(path, val);
      break
    case 's':
      path = tokenizer.getPath();
      val = tokenizer.getAny();
      oldVal = tokenizer.getAny();
      op = ObjectOperation.Set(path, oldVal, val);
      break
    case 'u':
      path = tokenizer.getPath();
      diff = this.deserializePrimitiveOp(str, tokenizer);
      op = ObjectOperation.Update(path, diff);
      break
    default:
      throw new Error('Illegal type for ObjectOperation: '+ type)
  }
  return op
};

OperationSerializer.prototype.deserializePrimitiveOp = function deserializePrimitiveOp (str, tokenizer) {
  if (!tokenizer) {
    tokenizer = new Tokenizer(str, this.SEPARATOR);
  }
  var type = tokenizer.getString();
  var op, pos, val;
  switch (type) {
    case 't+':
      pos = tokenizer.getNumber();
      val = tokenizer.getString();
      op = TextOperation.Insert(pos, val);
      break
    case 't-':
      pos = tokenizer.getNumber();
      val = tokenizer.getString();
      op = TextOperation.Delete(pos, val);
      break
    case 'a+':
      pos = tokenizer.getNumber();
      val = tokenizer.getAny();
      op = ArrayOperation.Insert(pos, val);
      break
    case 'a-':
      pos = tokenizer.getNumber();
      val = tokenizer.getAny();
      op = ArrayOperation.Delete(pos, val);
      break
    case 'c>>':
      val = tokenizer.getNumber();
      op = CoordinateOperation.Shift(val);
      break
    default:
      throw new Error('Unsupported operation type: ' + type)
  }
  return op
};

var Tokenizer = function Tokenizer(str, sep) {
  if (isArray(arguments[0])) {
    this.tokens = arguments[0];
  } else {
    this.tokens = str.split(sep);
  }
  this.pos = -1;
};

Tokenizer.prototype.error = function error (msg) {
  throw new Error('Parsing error: ' + msg + '\n' + this.tokens[this.pos])
};

Tokenizer.prototype.getString = function getString () {
  this.pos++;
  var str = this.tokens[this.pos];
  if (str[0] === '"') {
    str = str.slice(1, -1);
  }
  return str
};

Tokenizer.prototype.getNumber = function getNumber () {
  this.pos++;
  var number;
  var token = this.tokens[this.pos];
  try {
    if (isNumber(token)) {
      number = token;
    } else {
      number = parseInt(this.tokens[this.pos], 10);
    }
    return number
  } catch (err) {
    this.error('expected number');
  }
};

Tokenizer.prototype.getObject = function getObject () {
  this.pos++;
  var obj;
  var token = this.tokens[this.pos];
  try {
    if (isObject(token)) {
      obj = token;
    } else {
      obj = JSON.parse(this.tokens[this.pos]);
    }
    return obj
  } catch (err) {
    this.error('expected object');
  }
};

Tokenizer.prototype.getAny = function getAny () {
  this.pos++;
  var token = this.tokens[this.pos];
  return token
};

Tokenizer.prototype.getPath = function getPath () {
  var str = this.getString();
  return str.split('.')
};

OperationSerializer.Tokenizer = Tokenizer;

function isArrayEqual(arr1, arr2) {
  if (arr1 === arr2) { return true }
  if (!isArray(arr1) || !isArray(arr2)) { return false }
  if (arr1.length !== arr2.length) { return false }
  var L = arr1.length;
  for (var i = 0; i < L; i++) {
    if (arr1[i] !== arr2[i]) { return false }
  }
  return true
}

/**
  @internal
*/
var Coordinate = function Coordinate(path, offset) {
  // HACK: to allow this class be inherited but without calling this ctor
  if (arguments[0] === 'SKIP') { return }
  if (arguments.length === 1) {
    var data = arguments[0];
    this.path = data.path;
    this.offset = data.offset;
  } else {
    this.path = path;
    this.offset = offset;
  }
  if (!isArray(this.path)) {
    throw new Error('Invalid arguments: path should be an array.')
  }
  if (!isNumber(this.offset) || this.offset < 0) {
    throw new Error('Invalid arguments: offset must be a positive number.')
  }
};

Coordinate.prototype.equals = function equals (other) {
  return (other === this ||
    (isArrayEqual(other.path, this.path) && other.offset === this.offset) )
};

Coordinate.prototype.withCharPos = function withCharPos (offset) {
  return new Coordinate(this.path, offset)
};

Coordinate.prototype.getNodeId = function getNodeId () {
  return this.path[0]
};

Coordinate.prototype.getPath = function getPath () {
  return this.path
};

Coordinate.prototype.getOffset = function getOffset () {
  return this.offset
};

Coordinate.prototype.toJSON = function toJSON () {
  return {
    path: this.path.slice(),
    offset: this.offset
  }
};

Coordinate.prototype.toString = function toString () {
  return "(" + this.path.join('.') + ", " + this.offset + ")"
};

Coordinate.prototype.isPropertyCoordinate = function isPropertyCoordinate () {
  return this.path.length > 1
};

Coordinate.prototype.isNodeCoordinate = function isNodeCoordinate () {
  return this.path.length === 1
};

Coordinate.prototype.hasSamePath = function hasSamePath (other) {
  return isArrayEqual(this.path, other.path)
};

Coordinate.prototype._isCoordinate = true;

/*
  Anchors are special annotations which have a zero width.

  Examples are the start and end anchors of ContainerAnnotations, or a Cursor.

  TODO: in future we will need to introduce a built-in type
  for this so that annotation updates can be compared with
  text operations.

  Sub-Classes: model/ContainerAnnotation.Anchor, model/Selection.Cursor

  @class
  @abstract
*/
var Anchor = (function (Coordinate$$1) {
  function Anchor () {
    Coordinate$$1.apply(this, arguments);
  }

  if ( Coordinate$$1 ) Anchor.__proto__ = Coordinate$$1;
  Anchor.prototype = Object.create( Coordinate$$1 && Coordinate$$1.prototype );
  Anchor.prototype.constructor = Anchor;

  Anchor.prototype.isAnchor = function isAnchor () {
    return true
  };

  return Anchor;
}(Coordinate));

/**
  A document selection. Refers to a Substance document model, not to the DOM.
*/
var Selection = function Selection() {
  // Internal stuff
  var _internal = {};
  Object.defineProperty(this, "_internal", {
    enumerable: false,
    value: _internal
  });
    // set when attached to document
  _internal.doc = null;
};

var prototypeAccessors$1 = { type: {} };

Selection.prototype.clone = function clone () {
  var newSel = this._clone();
  if (this._internal.doc) {
    newSel.attach(this._internal.doc);
  }
  return newSel
};

/**
  @returns {Document} The attached document instance
*/
Selection.prototype.getDocument = function getDocument () {
  var doc = this._internal.doc;
  if (!doc) {
    throw new Error('Selection is not attached to a document.')
  }
  return doc
};

Selection.prototype.isAttached = function isAttached () {
  return Boolean(this._internal.doc)
};

/**
  Attach document to the selection.

  @internal
  @param {Document} doc document to attach
  @returns {this}
*/
Selection.prototype.attach = function attach (doc) {
  this._internal.doc = doc;
  return this
};

/**
  @returns {Boolean} true when selection is null.
*/
Selection.prototype.isNull = function isNull () { return false; };

/**
  @returns {Boolean} true for property selections
*/
Selection.prototype.isPropertySelection = function isPropertySelection () { return false; };

/**
  @returns {Boolean} true if selection is a {@link model/ContainerSelection}
*/
Selection.prototype.isContainerSelection = function isContainerSelection () { return false; };

/**
  @returns {Boolean} true if selection is a {@link model/NodeSelection}
*/
Selection.prototype.isNodeSelection = function isNodeSelection () { return false; };

Selection.prototype.isCustomSelection = function isCustomSelection () { return false; };

/**
  @returns {Boolean} true when selection is collapsed
*/
Selection.prototype.isCollapsed = function isCollapsed () { return true; };

/**
  @returns {Boolean} true if startOffset < endOffset
*/
Selection.prototype.isReverse = function isReverse () { return false; };

Selection.prototype.getType = function getType () {
  throw new Error('Selection.getType() is abstract.')
};

prototypeAccessors$1.type.get = function () {
  return this.getType()
};

/**
  @returns {Boolean} true if selection equals `other` selection
*/
Selection.prototype.equals = function equals (other) {
  if (this === other) {
    return true
  } else if (!other) {
    return false
  } else if (this.isNull() !== other.isNull()) {
    return false
  } else if (this.getType() !== other.getType()) {
    return false
  } else {
    // Note: returning true here, so that sub-classes
    // can call this as a predicate in their expression
    return true
  }
};

/**
  @returns {String} This selection as human readable string.
*/
Selection.prototype.toString = function toString () {
  return "null"
};

/**
  Convert container selection to JSON.

  @abstract
  @returns {Object}
*/
Selection.prototype.toJSON = function toJSON () {
  throw new Error('This method is abstract.')
};

/**
  Get selection fragments for this selection.

  A selection fragment is bound to a single property.
  @returns {Selection.Fragment[]}
*/
Selection.prototype.getFragments = function getFragments () {
  return []
};

Selection.prototype.createWith = function createWith (update) {
  var SelectionClass = this.constructor;
  var data = this.toJSON();
  Object.assign(data, update);
  return SelectionClass.fromJSON(data)
};

Object.defineProperties( Selection.prototype, prototypeAccessors$1 );

// for duck-typed instanceof
Selection.prototype._isSelection = true;

/*
  Class to represent null selections.

  @internal
*/
var NullSelection = (function (Selection) {
  function NullSelection () {
    Selection.apply(this, arguments);
  }

  if ( Selection ) NullSelection.__proto__ = Selection;
  NullSelection.prototype = Object.create( Selection && Selection.prototype );
  NullSelection.prototype.constructor = NullSelection;

  NullSelection.prototype.isNull = function isNull () {
    return true
  };

  NullSelection.prototype.getType = function getType () {
    return 'null'
  };

  NullSelection.prototype.toJSON = function toJSON () {
    return null
  };

  NullSelection.prototype.clone = function clone () {
    return this
  };

  return NullSelection;
}(Selection));

/**
  We use a singleton to represent NullSelections.

  @type {model/Selection}
*/

Selection.nullSelection = Object.freeze(new NullSelection());

/**
  @internal
*/
var SelectionFragment = (function (EventEmitter$$1) {
  function SelectionFragment(path, startOffset, endOffset, full) {
    EventEmitter$$1.call(this);

    this.type = "selection-fragment";
    this.path = path;
    this.startOffset = startOffset;
    this.endOffset = endOffset || startOffset;
    this.full = Boolean(full);
  }

  if ( EventEmitter$$1 ) SelectionFragment.__proto__ = EventEmitter$$1;
  SelectionFragment.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  SelectionFragment.prototype.constructor = SelectionFragment;

  SelectionFragment.prototype.isAnchor = function isAnchor () {
    return false
  };

  SelectionFragment.prototype.isInline = function isInline () {
    return false
  };

  SelectionFragment.prototype.isPropertyFragment = function isPropertyFragment () {
    return true
  };

  SelectionFragment.prototype.isNodeFragment = function isNodeFragment () {
    return false
  };

  SelectionFragment.prototype.isFull = function isFull () {
    return this.full
  };

  SelectionFragment.prototype.isPartial = function isPartial () {
    return !this.full
  };

  SelectionFragment.prototype.getNodeId = function getNodeId () {
    return this.path[0]
  };

  return SelectionFragment;
}(EventEmitter));

Selection.Fragment = SelectionFragment;


var NodeFragment = (function (EventEmitter$$1) {
  function NodeFragment(nodeId) {
    EventEmitter$$1.call(this);

    this.type = "node-fragment";
    this.nodeId = nodeId;
    this.path = [nodeId];
  }

  if ( EventEmitter$$1 ) NodeFragment.__proto__ = EventEmitter$$1;
  NodeFragment.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  NodeFragment.prototype.constructor = NodeFragment;

  NodeFragment.prototype.isAnchor = function isAnchor () {
    return false
  };

  NodeFragment.prototype.isInline = function isInline () {
    return false
  };

  NodeFragment.prototype.isPropertyFragment = function isPropertyFragment () {
    return false
  };

  NodeFragment.prototype.isNodeFragment = function isNodeFragment () {
    return true
  };

  NodeFragment.prototype.isFull = function isFull () {
    return true
  };

  NodeFragment.prototype.isPartial = function isPartial () {
    return false
  };

  NodeFragment.prototype.getNodeId = function getNodeId () {
    return this.nodeId
  };

  return NodeFragment;
}(EventEmitter));

Selection.NodeFragment = NodeFragment;

/**
  Describe the cursor when creating selection fragments.
  This is used for rendering selections.

  @internal
*/
var Cursor = (function (Anchor$$1) {
  function Cursor(path, offset) {
    Anchor$$1.call(this, path, offset);

    this.type = "cursor";
  }

  if ( Anchor$$1 ) Cursor.__proto__ = Anchor$$1;
  Cursor.prototype = Object.create( Anchor$$1 && Anchor$$1.prototype );
  Cursor.prototype.constructor = Cursor;

  Cursor.prototype.isPropertyFragment = function isPropertyFragment () {
    return false
  };

  Cursor.prototype.isNodeFragment = function isNodeFragment () {
    return false
  };

  return Cursor;
}(Anchor));

Selection.Cursor = Cursor;

/**
  A selection which is bound to a property. Implements {@link model/Selection}.

  @example

  ```js
  var propSel = doc.createSelection({
    type: 'property',
    path: ['p1', 'content'],
    startOffset: 3,
    endOffset: 6
  })
*/
var PropertySelection = (function (Selection$$1) {
  function PropertySelection(path, startOffset, endOffset, reverse, containerId, surfaceId) {
    Selection$$1.call(this);

    if (arguments.length === 1) {
      var data = arguments[0];
      path = data.path;
      startOffset = data.startOffset;
      endOffset = data.endOffset;
      reverse = data.reverse;
      containerId = data.containerId;
      surfaceId = data.surfaceId;
    }

    if (!path || !isNumber(startOffset)) {
      throw new Error('Invalid arguments: `path` and `startOffset` are mandatory');
    }

    this.start = new Coordinate(path, startOffset);
    this.end = new Coordinate(path, isNumber(endOffset) ? endOffset : startOffset);

    /**
      Selection direction.
      @type {Boolean}
    */
    this.reverse = Boolean(reverse);

    this.containerId = containerId;

    /**
      Identifier of the surface this selection should be active in.
      @type {String}
    */
    this.surfaceId = surfaceId;
  }

  if ( Selection$$1 ) PropertySelection.__proto__ = Selection$$1;
  PropertySelection.prototype = Object.create( Selection$$1 && Selection$$1.prototype );
  PropertySelection.prototype.constructor = PropertySelection;

  var prototypeAccessors = { path: {},startOffset: {},endOffset: {} };

  prototypeAccessors.path.get = function () {
    return this.start.path
  };

  prototypeAccessors.startOffset.get = function () {
    console.warn('DEPRECATED: Use sel.start.offset instead');
    return this.start.offset
  };

  prototypeAccessors.endOffset.get = function () {
    console.warn('DEPRECATED: Use sel.end.offset instead');
    return this.end.offset
  };

  /**
    Convert container selection to JSON.

    @returns {Object}
  */
  PropertySelection.prototype.toJSON = function toJSON () {
    return {
      type: 'property',
      path: this.start.path,
      startOffset: this.start.offset,
      endOffset: this.end.offset,
      reverse: this.reverse,
      containerId: this.containerId,
      surfaceId: this.surfaceId
    }
  };

  PropertySelection.prototype.isPropertySelection = function isPropertySelection () {
    return true
  };

  PropertySelection.prototype.getType = function getType () {
    return 'property'
  };

  PropertySelection.prototype.isNull = function isNull () {
    return false
  };

  PropertySelection.prototype.isCollapsed = function isCollapsed () {
    return this.start.offset === this.end.offset;
  };

  PropertySelection.prototype.isReverse = function isReverse () {
    return this.reverse
  };

  PropertySelection.prototype.equals = function equals (other) {
    return (
      Selection$$1.prototype.equals.call(this, other) &&
      (this.start.equals(other.start) && this.end.equals(other.end))
    )
  };

  PropertySelection.prototype.toString = function toString () {
    /* istanbul ignore next */
    return [
      "PropertySelection(", JSON.stringify(this.path), ", ",
      this.start.offset, " -> ", this.end.offset,
      (this.reverse?", reverse":""),
      (this.surfaceId?(", "+this.surfaceId):""),
      ")"
    ].join('')
  };

  /**
    Collapse a selection to chosen direction.

    @param {String} direction either left of right
    @returns {PropertySelection}
  */
  PropertySelection.prototype.collapse = function collapse (direction) {
    var offset;
    if (direction === 'left') {
      offset = this.start.offset;
    } else {
      offset = this.end.offset;
    }
    return this.createWithNewRange(offset, offset)
  };

  // Helper Methods
  // ----------------------

  /**
    Get path of a selection, e.g. target property where selected data is stored.

    @returns {String[]} path
  */
  PropertySelection.prototype.getPath = function getPath () {
    return this.start.path;
  };

  PropertySelection.prototype.getNodeId = function getNodeId () {
    return this.start.path[0];
  };

  /**
    Checks if this selection is inside another one.

    @param {Selection} other
    @param {Boolean} [strict] true if should check that it is strictly inside the other
    @returns {Boolean}
  */
  PropertySelection.prototype.isInsideOf = function isInsideOf (other, strict) {
    if (other.isNull()) { return false }
    if (other.isContainerSelection()) {
      return other.contains(this, strict)
    }
    if (strict) {
      return (isArrayEqual(this.path, other.path) &&
        this.start.offset > other.start.offset &&
        this.end.offset < other.end.offset);
    } else {
      return (isArrayEqual(this.path, other.path) &&
        this.start.offset >= other.start.offset &&
        this.end.offset <= other.end.offset);
    }
  };

  /**
    Checks if this selection contains another one.

    @param {Selection} other
    @param {Boolean} [strict] true if should check that it is strictly contains the other
    @returns {Boolean}
  */
  PropertySelection.prototype.contains = function contains (other, strict) {
    if (other.isNull()) { return false }
    return other.isInsideOf(this, strict)
  };

  /**
    Checks if this selection overlaps another one.

    @param {Selection} other
    @param {Boolean} [strict] true if should check that it is strictly overlaps the other
    @returns {Boolean}
  */
  PropertySelection.prototype.overlaps = function overlaps (other, strict) {
    if (other.isNull()) { return false }
    if (other.isContainerSelection()) {
      // console.log('PropertySelection.overlaps: delegating to ContainerSelection.overlaps...')
      return other.overlaps(this)
    }
    if (!isArrayEqual(this.path, other.path)) { return false }
    if (strict) {
      return (! (this.start.offset>=other.end.offset||this.end.offset<=other.start.offset) );
    } else {
      return (! (this.start.offset>other.end.offset||this.end.offset<other.start.offset) );
    }
  };

  /**
    Checks if this selection has the right boundary in common with another one.

    @param {Selection} other
    @returns {Boolean}
  */
  PropertySelection.prototype.isRightAlignedWith = function isRightAlignedWith (other) {
    if (other.isNull()) { return false }
    if (other.isContainerSelection()) {
      // console.log('PropertySelection.isRightAlignedWith: delegating to ContainerSelection.isRightAlignedWith...')
      return other.isRightAlignedWith(this)
    }
    return (isArrayEqual(this.path, other.path) &&
      this.end.offset === other.end.offset);
  };

  /**
    Checks if this selection has the left boundary in common with another one.

    @param {Selection} other
    @returns {Boolean}
  */
  PropertySelection.prototype.isLeftAlignedWith = function isLeftAlignedWith (other) {
    if (other.isNull()) { return false }
    if (other.isContainerSelection()) {
      // console.log('PropertySelection.isLeftAlignedWith: delegating to ContainerSelection.isLeftAlignedWith...')
      return other.isLeftAlignedWith(this)
    }
    return (isArrayEqual(this.path, other.path) &&
      this.start.offset === other.start.offset);
  };

  /**
    Expands selection to include another selection.

    @param {Selection} other
    @returns {Selection} a new selection
  */
  PropertySelection.prototype.expand = function expand (other) {
    if (other.isNull()) { return this }

    // if the other is a ContainerSelection
    // we delegate to that implementation as it is more complex
    // and can deal with PropertySelections, too
    if (other.isContainerSelection()) {
      return other.expand(this)
    }
    if (!isArrayEqual(this.path, other.path)) {
      throw new Error('Can not expand PropertySelection to a different property.')
    }
    var newStartOffset = Math.min(this.start.offset, other.start.offset);
    var newEndOffset = Math.max(this.end.offset, other.end.offset);
    return this.createWithNewRange(newStartOffset, newEndOffset);
  };

  /**
    Creates a new selection by truncating this one by another selection.

    @param {Selection} other
    @returns {Selection} a new selection
  */
  PropertySelection.prototype.truncateWith = function truncateWith (other) {
    if (other.isNull()) { return this }
    if (other.isInsideOf(this, 'strict')) {
      // the other selection should overlap only on one side
      throw new Error('Can not truncate with a contained selections')
    }
    if (!this.overlaps(other)) {
      return this
    }
    var otherStartOffset, otherEndOffset;
    if (other.isPropertySelection()) {
      otherStartOffset = other.start.offset;
      otherEndOffset = other.end.offset;
    } else if (other.isContainerSelection()) {
      // either the startPath or the endPath must be the same
      if (isArrayEqual(other.start.path, this.start.path)) {
        otherStartOffset = other.start.offset;
      } else {
        otherStartOffset = this.start.offset;
      }
      if (isArrayEqual(other.end.path, this.start.path)) {
        otherEndOffset = other.end.offset;
      } else {
        otherEndOffset = this.end.offset;
      }
    } else {
      return this
    }

    var newStartOffset;
    var newEndOffset;
    if (this.start.offset > otherStartOffset && this.end.offset > otherEndOffset) {
      newStartOffset = otherEndOffset;
      newEndOffset = this.end.offset;
    } else if (this.start.offset < otherStartOffset && this.end.offset < otherEndOffset) {
      newStartOffset = this.start.offset;
      newEndOffset = otherStartOffset;
    } else if (this.start.offset === otherStartOffset) {
      if (this.end.offset <= otherEndOffset) {
        return Selection$$1.nullSelection;
      } else {
        newStartOffset = otherEndOffset;
        newEndOffset = this.end.offset;
      }
    } else if (this.end.offset === otherEndOffset) {
      if (this.start.offset >= otherStartOffset) {
        return Selection$$1.nullSelection;
      } else {
        newStartOffset = this.start.offset;
        newEndOffset = otherStartOffset;
      }
    } else if (other.contains(this)) {
      return Selection$$1.nullSelection
    } else {
      // FIXME: if this happens, we have a bug somewhere above
      throw new Error('Illegal state.')
    }
    return this.createWithNewRange(newStartOffset, newEndOffset)
  };

  /**
    Creates a new selection with given range and same path.

    @param {Number} startOffset
    @param {Number} endOffset
    @returns {Selection} a new selection
  */
  PropertySelection.prototype.createWithNewRange = function createWithNewRange (startOffset, endOffset) {
    var sel = new PropertySelection(this.path, startOffset, endOffset, false, this.containerId, this.surfaceId);
    var doc = this._internal.doc;
    if (doc) {
      sel.attach(doc);
    }
    return sel
  };

  /**
    Return fragments for a given selection.

    @returns {Selection.Fragment[]}
  */
  PropertySelection.prototype.getFragments = function getFragments () {
    if(this._internal.fragments) {
      return this._internal.fragments
    }

    var fragments;

    if (this.isCollapsed()) {
      fragments = [new Selection$$1.Cursor(this.path, this.start.offset)];
    } else {
      fragments = [new Selection$$1.Fragment(this.path, this.start.offset, this.end.offset)];
    }

    this._internal.fragments = fragments;
    return fragments
  };

  PropertySelection.prototype._clone = function _clone () {
    return new PropertySelection(this.start.path, this.start.offset, this.end.offset, this.reverse, this.containerId, this.surfaceId);
  };

  Object.defineProperties( PropertySelection.prototype, prototypeAccessors );

  return PropertySelection;
}(Selection));

PropertySelection.fromJSON = function(json) {
  return new PropertySelection(json)
};

/**
  A selection spanning multiple nodes.

  @class
  @extends PropertySelection

  @example

  ```js
  var containerSel = doc.createSelection({
    type: 'container',
    containerId: 'body',
    startPath: ['p1', 'content'],
    startOffset: 5,
    endPath: ['p3', 'content'],
    endOffset: 4,
  });
  ```
*/
var ContainerSelection = (function (Selection$$1) {
  function ContainerSelection(containerId, startPath, startOffset, endPath, endOffset, reverse, surfaceId) {
    Selection$$1.call(this);

    if (arguments.length === 1) {
      var data = arguments[0];
      containerId = data.containerId;
      startPath = data.startPath;
      startOffset = data.startOffset;
      endPath = data.endPath;
      endOffset = data.endOffset;
      reverse = data.reverse;
      surfaceId = data.surfaceId;
    }

    /**
      @type {String}
    */
    this.containerId = containerId;
    if (!this.containerId) { throw new Error('Invalid arguments: `containerId` is mandatory'); }

    this.start = new Coordinate(startPath, startOffset);
    this.end = new Coordinate(isNil(endPath) ? startPath : endPath, isNil(endOffset) ? startOffset : endOffset);

    this.reverse = Boolean(reverse);

    this.surfaceId = surfaceId;
  }

  if ( Selection$$1 ) ContainerSelection.__proto__ = Selection$$1;
  ContainerSelection.prototype = Object.create( Selection$$1 && Selection$$1.prototype );
  ContainerSelection.prototype.constructor = ContainerSelection;

  var prototypeAccessors = { startPath: {},startOffset: {},endPath: {},endOffset: {},path: {} };

  prototypeAccessors.startPath.get = function () {
    console.warn('DEPRECATED: use sel.start.path instead.');
    return this.start.path
  };

  prototypeAccessors.startOffset.get = function () {
    console.warn('DEPRECATED: use sel.start.offset instead.');
    return this.start.offset
  };

  prototypeAccessors.endPath.get = function () {
    console.warn('DEPRECATED: use sel.end.path instead.');
    return this.end.path
  };

  prototypeAccessors.endOffset.get = function () {
    console.warn('DEPRECATED: use sel.end.offset instead.');
    return this.end.offset
  };

  ContainerSelection.prototype.toJSON = function toJSON () {
    return {
      type: 'container',
      containerId: this.containerId,
      startPath: this.start.path,
      startOffset: this.start.offset,
      endPath: this.end.path,
      endOffset: this.end.offset,
      reverse: this.reverse,
      surfaceId: this.surfaceId
    };
  };


  ContainerSelection.prototype.isContainerSelection = function isContainerSelection () {
    return true;
  };

  ContainerSelection.prototype.getType = function getType () {
    return 'container';
  };

  ContainerSelection.prototype.isNull = function isNull () {
    return false;
  };

  ContainerSelection.prototype.isCollapsed = function isCollapsed () {
    return this.start.equals(this.end);
  };

  ContainerSelection.prototype.isReverse = function isReverse () {
    return this.reverse;
  };

  ContainerSelection.prototype.equals = function equals (other) {
    return (
      Selection$$1.prototype.equals.call(this, other) &&
      this.containerId === other.containerId &&
      (this.start.equals(other.start) && this.end.equals(other.end))
    );
  };

  ContainerSelection.prototype.toString = function toString () {
    /* istanbul ignore next */
    return [
      "ContainerSelection(",
      this.containerId, ", ",
      JSON.stringify(this.start.path), ", ", this.start.offset,
      " -> ",
      JSON.stringify(this.end.path), ", ", this.end.offset,
      (this.reverse?", reverse":""),
      (this.surfaceId?(", "+this.surfaceId):""),
      ")"
    ].join('');
  };

  /**
    @return {model/Container} The container node instance for this selection.
  */
  ContainerSelection.prototype.getContainer = function getContainer () {
    if (!this._internal.container) {
      this._internal.container = this.getDocument().get(this.containerId);
    }
    return this._internal.container;
  };

  ContainerSelection.prototype.isInsideOf = function isInsideOf (other, strict) {
    // Note: this gets called from PropertySelection.contains()
    // because this implementation can deal with mixed selection types.
    if (other.isNull()) { return false; }
    strict = Boolean(strict);
    var r1 = this._range(this);
    var r2 = this._range(other);
    return (r2.start.isBefore(r1.start, strict) &&
      r1.end.isBefore(r2.end, strict));
  };

  ContainerSelection.prototype.contains = function contains (other, strict) {
    // Note: this gets called from PropertySelection.isInsideOf()
    // because this implementation can deal with mixed selection types.
    if (other.isNull()) { return false; }
    strict = Boolean(strict);
    var r1 = this._range(this);
    var r2 = this._range(other);
    return (r1.start.isBefore(r2.start, strict) &&
      r2.end.isBefore(r1.end, strict));
  };

  ContainerSelection.prototype.containsNode = function containsNode (nodeId, strict) {
    var container = this.getContainer();
    var coor = new Coordinate([nodeId], 0);
    var address = container.getAddress(coor);
    var r = this._range(this);
    // console.log('ContainerSelection.containsNode()', address, 'is within', r.start, '->', r.end, '?');
    var contained = r.start.isBefore(address, strict);
    if (contained) {
      address.offset = 1;
      contained = r.end.isAfter(address, strict);
    }
    return contained;
  };

  ContainerSelection.prototype.overlaps = function overlaps (other) {
    var r1 = this._range(this);
    var r2 = this._range(other);
    // it overlaps if they are not disjunct
    return !(r1.end.isBefore(r2.start, false) ||
      r2.end.isBefore(r1.start, false));
  };

  ContainerSelection.prototype.isLeftAlignedWith = function isLeftAlignedWith (other) {
    var r1 = this._range(this);
    var r2 = this._range(other);
    return r1.start.isEqual(r2.start);
  };

  ContainerSelection.prototype.isRightAlignedWith = function isRightAlignedWith (other) {
    var r1 = this._range(this);
    var r2 = this._range(other);
    return r1.end.isEqual(r2.end);
  };

  /**
    Collapse a selection to chosen direction.

    @param {String} direction either left of right
    @returns {PropertySelection}
  */
  ContainerSelection.prototype.collapse = function collapse (direction) {
    var coor;
    if (direction === 'left') {
      coor = this.start;
    } else {
      coor = this.end;
    }
    return _createNewSelection(this, coor, coor);
  };

  ContainerSelection.prototype.expand = function expand (other) {
    var r1 = this._range(this);
    var r2 = this._range(other);
    var start;
    var end;

    if (r1.start.isEqual(r2.start)) {
      start = new Coordinate(this.start.path, Math.min(this.start.offset, other.start.offset));
    } else if (r1.start.isAfter(r2.start)) {
      start = new Coordinate(other.start.path, other.start.offset);
    } else {
      start = this.start;
    }
    if (r1.end.isEqual(r2.end)) {
      end = new Coordinate(this.end.path, Math.max(this.end.offset, other.end.offset));
    } else if (r1.end.isBefore(r2.end, false)) {
      end = new Coordinate(other.end.path, other.end.offset);
    } else {
      end = this.end;
    }

    return _createNewSelection(this, start, end);
  };

  ContainerSelection.prototype.truncateWith = function truncateWith (other) {
    if (other.isInsideOf(this, 'strict')) {
      // the other selection should overlap only on one side
      throw new Error('Can not truncate with a contained selections');
    }
    if (!this.overlaps(other)) {
      return this;
    }
    var r1 = this._range(this);
    var r2 = this._range(other);
    var start, end;
    if (r2.start.isBefore(r1.start, 'strict') && r2.end.isBefore(r1.end, 'strict')) {
      start = other.end;
      end = this.end;
    } else if (r1.start.isBefore(r2.start, 'strict') && r1.end.isBefore(r2.end, 'strict')) {
      start = this.start;
      end = other.start;
    } else if (r1.start.isEqual(r2.start)) {
      if (r2.end.isBefore(r1.end, 'strict')) {
        start = other.end;
        end = this.end;
      } else {
        // the other selection is larger which eliminates this one
        return Selection$$1.nullSelection;
      }
    } else if (r1.end.isEqual(r2.end)) {
      if (r1.start.isBefore(r2.start, 'strict')) {
        start = this.start;
        end = other.start;
      } else {
        // the other selection is larger which eliminates this one
        return Selection$$1.nullSelection;
      }
    } else if (this.isInsideOf(other)) {
      return Selection$$1.nullSelection;
    } else {
      throw new Error('Could not determine coordinates for truncate. Check input');
    }
    return _createNewSelection(this, start, end);
  };

  /**
    Get the node ids covered by this selection.

    @returns {String[]} an array of ids
  */
  ContainerSelection.prototype.getNodeIds = function getNodeIds () {
    var container = this.getContainer();
    var startPos = container.getPosition(this.start.path[0]);
    var endPos = container.getPosition(this.end.path[0]);
    return container.nodes.slice(startPos, endPos+1)
  };

  /**
    Helper to create selection fragments for this ContainerSelection.

    Used for selection rendering, for instance.

    @returns {Selection.Fragment[]} Fragments resulting from splitting this into property selections.
  */
  ContainerSelection.prototype.getFragments = function getFragments () {
    // NOTE: maybe we come up with a helper like this at a later time, when the core concepts are ironed out.
    // If you have used this before, you probably can write a simpler helper, like done in documentHelpers.getTextForSelection()
    console.warn('DEPRECATED: this implementation turned out to be too complicated and will be removed soon.');

    // DANGEROUS: to be absolutely correct this would need to get invalidated
    if(this._internal.fragments) {
      return this._internal.fragments;
    }
    /*
      NOTE:
        This implementation is a bit more complicated
        to simplify implementations at other places.
        A ContainerSelection can be seen as a list of property and node
        fragments.
        The following implementation is covering all cases in a canonical
        way, considering all combinations of start end end coordinates
        either given as ([nodeId, propertyName], offset) or
        ([nodeId], 0|1).
    */
    var fragments = [];

    var doc = this.getDocument();
    var container = this.getContainer();
    var startPos = container.getPosition(this.start.path[0]);
    var endPos = container.getPosition(this.end.path[0]);

    var coor, node, nodeId, fragment, path, offset, text;
    if (startPos !== endPos) {

      // First fragment can either be a property fragment (fully or partial) or a node fragment
      coor = this.start;
      path = coor.path;
      offset = coor.offset;
      nodeId = path[0];
      node = doc.get(nodeId);
      if (!node) {
        throw new Error('Node does not exist:' + nodeId);
      }
      // coordinate is a property coordinate
      if (coor.isPropertyCoordinate()) {
        text = doc.get(path);
        fragment = new Selection$$1.Fragment(path, offset, text.length, (offset === 0));
        fragments.push(fragment);
      }
      // coordinate is a node coordinate (before)
      else if (coor.isNodeCoordinate() && offset === 0) {
        fragments.push(
          new Selection$$1.NodeFragment(node.id)
        );
      }

      // fragments in-between are either full property fragments or node fragments
      for (var pos= startPos+1; pos < endPos; pos++) {
        node = container.getChildAt(pos);
        if (node.isText()) {
          path = [node.id, 'content'];
          text = doc.get(path);
          fragments.push(
            new Selection$$1.Fragment(path, 0, text.length, true)
          );
        } else {
          fragments.push(
            new Selection$$1.NodeFragment(container.nodes[pos])
          );
        }
      }

      // last fragment is again either a property fragment (fully or partial) or a node fragment
      coor = this.end;
      path = coor.path;
      offset = coor.offset;
      nodeId = path[0];
      node = doc.get(nodeId);
      if (!node) {
        throw new Error('Node does not exist:' + nodeId);
      }
      // coordinate is a property coordinate
      if (coor.isPropertyCoordinate()) {
        text = doc.get(path);
        fragment = new Selection$$1.Fragment(path, 0, offset, (offset === text.length));
        fragments.push(fragment);
      }
      // coordinate is a node coordinate (after)
      else if (coor.isNodeCoordinate() && offset > 0) {
        fragments.push(
          new Selection$$1.NodeFragment(node.id)
        );
      }
    } else {
      // startPos === endPos
      path = this.start.path;
      nodeId = path[0];
      node = doc.get(nodeId);
      var startIsNodeCoordinate = this.start.isNodeCoordinate();
      var endIsNodeCoordinate = this.end.isNodeCoordinate();
      if (!node.isText()) {
        fragments.push(
          new Selection$$1.NodeFragment(nodeId)
        );
      } else if (startIsNodeCoordinate && endIsNodeCoordinate && this.start.offset < this.end.offset) {
        fragments.push(
          new Selection$$1.NodeFragment(nodeId)
        );
      } else if (!startIsNodeCoordinate && endIsNodeCoordinate && this.end.offset > 0) {
        text = doc.get(this.start.path);
        fragments.push(
          new Selection$$1.Fragment(path, this.start.offset, text.length, (this.start.offset === 0))
        );
      } else if (startIsNodeCoordinate && !endIsNodeCoordinate && this.start.offset === 0) {
        text = doc.get(this.end.path);
        fragments.push(
          new Selection$$1.Fragment(path, 0, this.end.offset, (this.end.offset === text.length))
        );
      } else if (!startIsNodeCoordinate && !endIsNodeCoordinate) {
        text = doc.get(this.start.path);
        fragments.push(
          new Selection$$1.Fragment(path, this.start.offset, this.end.offset, (this.start.offset === 0 && this.end.offset === text.length))
        );
      }
    }

    this._internal.fragments = fragments;

    return fragments;
  };

  /**
    Splits a container selection into property selections.

    @returns {PropertySelection[]}
  */
  ContainerSelection.prototype.splitIntoPropertySelections = function splitIntoPropertySelections () {
    var sels = [];
    var fragments = this.getFragments();
    fragments.forEach(function(fragment) {
      if (fragment instanceof Selection$$1.Fragment) {
        sels.push(
          new PropertySelection(fragment.path, fragment.startOffset,
            fragment.endOffset, false, this.containerId, this.surfaceId)
        );
      }
    }.bind(this));
    return sels;
  };

  ContainerSelection.prototype._clone = function _clone () {
    return new ContainerSelection(this);
  };

  ContainerSelection.prototype._range = function _range (sel) {
    // EXPERIMENTAL: caching the internal address based range
    // as we use it very often.
    // However, this is dangerous as this data can get invalid by a change
    if (sel._internal.addressRange) {
      return sel._internal.addressRange;
    }

    var container = this.getContainer();
    var startAddress = container.getAddress(sel.start);
    var endAddress;
    if (sel.isCollapsed()) {
      endAddress = startAddress;
    } else {
      endAddress = container.getAddress(sel.end);
    }
    var addressRange = {
      start: startAddress,
      end: endAddress
    };
    if (sel._isContainerSelection) {
      sel._internal.addressRange = addressRange;
    }
    return addressRange;
  };

  prototypeAccessors.path.get = function () {
    throw new Error('ContainerSelection has no path property. Use startPath and endPath instead');
  };

  Object.defineProperties( ContainerSelection.prototype, prototypeAccessors );

  return ContainerSelection;
}(Selection));

ContainerSelection.prototype._isContainerSelection = true;

ContainerSelection.fromJSON = function(properties) {
  var sel = new ContainerSelection(properties);
  return sel;
};

function _createNewSelection(containerSel, start, end) {
  var newSel = new ContainerSelection(containerSel.containerId,
    start.path, start.offset, end.path, end.offset, false, containerSel.surfaceId);
  // we need to attach the new selection
  var doc = containerSel._internal.doc;
  if (doc) {
    newSel.attach(doc);
  }
  return newSel;
}

var NodeSelection = (function (Selection$$1) {
  function NodeSelection(containerId, nodeId, mode, reverse, surfaceId) {
    Selection$$1.call(this);

    if (arguments.length === 1) {
      var data = arguments[0];
      containerId = data.containerId;
      nodeId = data.nodeId;
      mode = data.mode;
      reverse = data.reverse;
      surfaceId = data.surfaceId;
    }

    if (!isString(containerId)) {
      throw new Error("'containerId' is mandatory.");
    }
    if (!isString(nodeId)) {
      throw new Error("'nodeId' is mandatory.");
    }
    mode = mode || "full";

    this.containerId = containerId;
    this.nodeId = nodeId;
    this.mode = mode;
    this.reverse = Boolean(reverse);
    this.surfaceId = surfaceId;

    this.start = new Coordinate([nodeId], 0);
    this.end = new Coordinate([nodeId], 1);
  }

  if ( Selection$$1 ) NodeSelection.__proto__ = Selection$$1;
  NodeSelection.prototype = Object.create( Selection$$1 && Selection$$1.prototype );
  NodeSelection.prototype.constructor = NodeSelection;

  NodeSelection.prototype.equals = function equals (other) {
    return (
      Selection$$1.prototype.equals.call(this, other) &&
      this.nodeId === other.nodeId &&
      this.mode === other.mode
    )
  };

  NodeSelection.prototype.isNodeSelection = function isNodeSelection () {
    return true;
  };

  NodeSelection.prototype.getType = function getType () {
    return 'node';
  };

  NodeSelection.prototype.getNodeId = function getNodeId () {
    return this.nodeId;
  };

  NodeSelection.prototype.isFull = function isFull () {
    return this.mode === 'full';
  };

  NodeSelection.prototype.isBefore = function isBefore () {
    return this.mode === 'before';
  };

  NodeSelection.prototype.isAfter = function isAfter () {
    return this.mode === 'after';
  };

  NodeSelection.prototype.isCollapsed = function isCollapsed () {
    return this.mode !== 'full';
  };

  NodeSelection.prototype.toJSON = function toJSON () {
    return {
      type: 'node',
      nodeId: this.nodeId,
      mode: this.mode,
      reverse: this.reverse,
      containerId: this.containerId,
      surfaceId: this.surfaceId
    };
  };

  NodeSelection.prototype.toString = function toString () {
    /* istanbul ignore next */
    return [
      "NodeSelection(",
      this.containerId, ".", this.nodeId, ", ",
      this.mode, ", ",
      (this.reverse?", reverse":""),
      (this.surfaceId?(", "+this.surfaceId):""),
      ")"
    ].join('');
  };

  NodeSelection.prototype.collapse = function collapse (direction) {
    if (direction === 'left') {
      if (this.isBefore()) {
        return this;
      } else {
        return new NodeSelection(this.containerId, this.nodeId, 'before', this.reverse, this.surfaceId);
      }
    } else if (direction === 'right') {
      if (this.isAfter()) {
        return this;
      } else {
        return new NodeSelection(this.containerId, this.nodeId, 'after', this.reverse, this.surfaceId);
      }
    } else {
      throw new Error("'direction' must be either 'left' or 'right'");
    }
  };

  NodeSelection.prototype._getCoordinate = function _getCoordinate () {
    if (this.mode === 'before') {
      return new Coordinate([this.nodeId], 0);
    } else if (this.mode === 'after') {
      return new Coordinate([this.nodeId], 1);
    }
  };

  NodeSelection.prototype._clone = function _clone () {
    return new NodeSelection(this);
  };

  return NodeSelection;
}(Selection));

NodeSelection.prototype._isNodeSelection = true;

NodeSelection.fromJSON = function(json) {
  return new NodeSelection(json);
};

// TODO: is this used?
NodeSelection._createFromCoordinate = function(coor) {
  var containerId = coor.containerId;
  var nodeId = coor.getNodeId();
  var mode = coor.offset === 0 ? 'before' : 'after';
  return new NodeSelection(containerId, nodeId, mode, false);
};

var CustomSelection = (function (Selection$$1) {
  function CustomSelection(customType, data, surfaceId) {
    Selection$$1.call(this);

    if (arguments.length === 1) {
      var _data = arguments[0];
      customType = _data.customType;
      data = _data.data;
      surfaceId = _data.surfaceId;
    }

    this.customType = customType;
    this.data = data || {};
    this.surfaceId = surfaceId;
  }

  if ( Selection$$1 ) CustomSelection.__proto__ = Selection$$1;
  CustomSelection.prototype = Object.create( Selection$$1 && Selection$$1.prototype );
  CustomSelection.prototype.constructor = CustomSelection;

  CustomSelection.prototype.isCustomSelection = function isCustomSelection () {
    return true;
  };

  CustomSelection.prototype.getType = function getType () {
    return 'custom';
  };

  CustomSelection.prototype.getCustomType = function getCustomType () {
    return this.customType;
  };

  CustomSelection.prototype.toJSON = function toJSON () {
    return {
      type: 'custom',
      customType: this.customType,
      data: cloneDeep(this.data),
      surfaceId: this.surfaceId
    };
  };

  CustomSelection.prototype.toString = function toString () {
    /* istanbul ignore next */
    return [
      'CustomSelection(',
      this.customType,', ',
      JSON.stringify(this.data),
      ")"
    ].join('');
  };

  CustomSelection.prototype.equals = function equals (other) {
    return (
      Selection$$1.prototype.equals.call(this, other) &&
      other.isCustomSelection() &&
      isEqual(this.data, other.data)
    );
  };

  CustomSelection.prototype._clone = function _clone () {
    return new CustomSelection(this)
  };

  return CustomSelection;
}(Selection));

CustomSelection.prototype._isCustomSelection = true;

CustomSelection.fromJSON = function(json) {
  return new CustomSelection(json);
};

function last$2(arr) {
  return arr[arr.length-1]
}

function fromJSON(json) {
  if (!json) { return Selection.nullSelection }
  var type = json.type;
  switch(type) {
    case 'property':
      return PropertySelection.fromJSON(json)
    case 'container':
      return ContainerSelection.fromJSON(json)
    case 'node':
      return NodeSelection.fromJSON(json)
    case 'custom':
      return CustomSelection.fromJSON(json)
    default:
      // console.error('Selection.fromJSON(): unsupported selection data', json)
      return Selection.nullSelection
  }
}

/*
  Helper to check if a coordinate is the first position of a node.
*/
function isFirst(doc, coor) {
  if (coor.isNodeCoordinate() && coor.offset === 0) { return true }
  var node = doc.get(coor.path[0]).getRoot();
  if (node.isText() && coor.offset === 0) { return true }
  if (node.isList()) {
    var itemId = coor.path[0];
    if (node.items[0] === itemId && coor.offset === 0) { return true }
  }
}

/*
  Helper to check if a coordinate is the last position of a node.
*/
function isLast(doc, coor) {
  if (coor.isNodeCoordinate() && coor.offset > 0) { return true }
  var node = doc.get(coor.path[0]).getRoot();
  if (node.isText() && coor.offset >= node.getLength()) { return true }
  if (node.isList()) {
    var itemId = coor.path[0];
    var item = doc.get(itemId);
    if (last$2(node.items) === itemId && coor.offset === item.getLength()) { return true }
  }
}

function isEntirelySelected(doc, node, start, end) {
  var ref = getRangeInfo(doc, node, start, end);
  var isEntirelySelected = ref.isEntirelySelected;
  return isEntirelySelected
}

function getRangeInfo(doc, node, start, end) {
  var isFirst = true;
  var isLast = true;
  if (node.isText()) {
    if (start && start.offset !== 0) { isFirst = false; }
    if (end && end.offset < node.getLength()) { isLast = false; }
  } else if (node.isList()) {
    if (start) {
      var itemId = start.path[0];
      var itemPos = node.getItemPosition(itemId);
      if (itemPos > 0 || start.offset !== 0) { isFirst = false; }
    }
    if (end) {
      var itemId$1 = end.path[0];
      var itemPos$1 = node.getItemPosition(itemId$1);
      var item = doc.get(itemId$1);
      if (itemPos$1 < node.items.length-1 || end.offset < item.getLength()) { isLast = false; }
    }
  }
  var isEntirelySelected = isFirst && isLast;
  return {isFirst: isFirst, isLast: isLast, isEntirelySelected: isEntirelySelected}
}

function setCursor(tx, node, containerId, mode) {
  if (node.isText()) {
    var offset = 0;
    if (mode === 'after') {
      var text = node.getText();
      offset = text.length;
    }
    tx.setSelection({
      type: 'property',
      path: node.getTextPath(),
      startOffset: offset,
      containerId: containerId
    });
  } else if (node.isList()) {
    var item, offset$1;
    if (mode === 'after') {
      item = node.getLastItem();
      offset$1 = item.getLength();
    } else {
      item = node.getFirstItem();
      offset$1 = 0;
    }
    tx.setSelection({
      type: 'property',
      path: item.getTextPath(),
      startOffset: offset$1,
      containerId: containerId
    });
  } else {
    tx.setSelection({
      type: 'node',
      containerId: containerId,
      nodeId: node.id,
      // NOTE: ATM we mostly use 'full' NodeSelections
      // Still, they are supported internally
      // mode: mode
    });
  }
}

function selectNode(tx, nodeId, containerId) {
  tx.setSelection(createNodeSelection({ doc: tx, nodeId: nodeId, containerId: containerId }));
}

function createNodeSelection(ref) {
  var doc = ref.doc;
  var nodeId = ref.nodeId;
  var containerId = ref.containerId;
  var mode = ref.mode;
  var reverse = ref.reverse;
  var surfaceId = ref.surfaceId;

  var node = doc.get(nodeId);
  if (!node) { return Selection.nullSelection }
  node = node.getRoot();
  if (node.isText()) {
    return new PropertySelection({
      path: node.getTextPath(),
      startOffset: mode === 'after' ? node.getLength() : 0,
      endOffset: mode === 'before' ? 0 : node.getLength(),
      reverse: reverse,
      containerId: containerId,
      surfaceId: surfaceId
    })
  } else if (node.isList() && node.getLength()>0) {
    var first = node.getFirstItem();
    var last = node.getLastItem();
    var start = {
      path: first.getTextPath(),
      offset: 0
    };
    var end = {
      path: last.getTextPath(),
      offset: last.getLength()
    };
    if (mode === 'after') { start = end; }
    else if (mode === 'before') { end = start; }
    return new ContainerSelection({
      startPath: start.path,
      startOffset: start.offset,
      endPath: end.path,
      endOffset: end.offset,
      reverse: reverse,
      containerId: containerId,
      surfaceId: surfaceId
    })
  } else {
    return new NodeSelection({ nodeId: nodeId, mode: mode, reverse: reverse, containerId: containerId, surfaceId: surfaceId })
  }
}

/*

  States:

  - Provisional:

    Change has been applied to the document already. Subsequent changes might be merged
    into it, to achieve a more natural representation.

  - Final:

    Change has been finalized.

  - Pending:

    Change has been committed to the collaboration hub.

  - Acknowledged:

    Change has been applied and acknowledged by the server.
*/
var DocumentChange = function DocumentChange(ops, before, after) {
  if (arguments.length === 1 && isObject(arguments[0])) {
    var data = arguments[0];
    // a unique id for the change
    this.sha = data.sha;
    // when the change has been applied
    this.timestamp = data.timestamp;
    // application state before the change was applied
    this.before = data.before || {};
    // array of operations
    this.ops = data.ops;
    this.info = data.info; // custom change info
    // application state after the change was applied
    this.after = data.after || {};
  } else if (arguments.length === 3) {
    this.sha = uuid();
    this.info = {};
    this.timestamp = Date.now();
    this.ops = ops.slice(0);
    this.before = before || {};
    this.after = after || {};
  } else {
    throw new Error('Illegal arguments.')
  }
  // a hash with all updated properties
  this.updated = null;
  // a hash with all created nodes
  this.created = null;
  // a hash with all deleted nodes
  this.deleted = null;
};

/*
  Extract aggregated information about which nodes and properties have been affected.
  This gets called by Document after applying the change.
*/
DocumentChange.prototype._extractInformation = function _extractInformation (doc) {
  var ops = this.ops;
  var created = {};
  var deleted = {};
  var updated = {};
  var affectedContainerAnnos = [];

  // TODO: we will introduce a special operation type for coordinates
  function _checkAnnotation(op) {
    switch (op.type) {
      case "create":
      case "delete": {
        var node = op.val;
        if (node.hasOwnProperty('start')) {
          updated[node.start.path] = true;
        }
        if (node.hasOwnProperty('end')) {
          updated[node.end.path] = true;
        }
        break
      }
      case "update":
      case "set": {
        // HACK: detecting annotation changes in an opportunistic way
        var node$1 = doc.get(op.path[0]);
        if (node$1) {
          if (node$1._isPropertyAnnotation) {
            updated[node$1.start.path] = true;
          } else if (node$1._isContainerAnnotation) {
            affectedContainerAnnos.push(node$1);
          }
        }
        break
      }
      default:
        throw new Error('Illegal state')
    }
  }

  for (var i = 0; i < ops.length; i++) {
    var op = ops[i];
    if (op.type === "create") {
      created[op.val.id] = op.val;
      delete deleted[op.val.id];
    }
    if (op.type === "delete") {
      delete created[op.val.id];
      deleted[op.val.id] = op.val;
    }
    if (op.type === "set" || op.type === "update") {
      updated[op.path] = true;
      // also mark the node itself as dirty
      updated[op.path[0]] = true;
    }
    _checkAnnotation(op);
  }

  affectedContainerAnnos.forEach(function(anno) {
    var container = doc.get(anno.containerId, 'strict');
    var startPos = container.getPosition(anno.start.path[0]);
    var endPos = container.getPosition(anno.end.path[0]);
    for (var pos = startPos; pos <= endPos; pos++) {
      var node = container.getChildAt(pos);
      var path;
      if (node.isText()) {
        path = [node.id, 'content'];
      } else {
        path = [node.id];
      }
      if (!deleted[node.id]) {
        updated[path] = true;
      }
    }
  });

  // remove all deleted nodes from updated
  if(Object.keys(deleted).length > 0) {
    forEach(updated, function(_, key) {
      var nodeId = key.split(',')[0];
      if (deleted[nodeId]) {
        delete updated[key];
      }
    });
  }

  this.created = created;
  this.deleted = deleted;
  this.updated = updated;
};

DocumentChange.prototype.invert = function invert () {
    var this$1 = this;

  // shallow cloning this
  var copy = this.toJSON();
  copy.ops = [];
  // swapping before and after
  var tmp = copy.before;
  copy.before = copy.after;
  copy.after = tmp;
  var inverted = DocumentChange.fromJSON(copy);
  var ops = [];
  for (var i = this.ops.length - 1; i >= 0; i--) {
    ops.push(this$1.ops[i].invert());
  }
  inverted.ops = ops;
  return inverted
};

// Inspection API used by DocumentChange listeners
// ===============================================

DocumentChange.prototype.isAffected = function isAffected (path) {
  return this.updated[path]
};

DocumentChange.prototype.isUpdated = function isUpdated (path) {
  // TODO: decide which API we prefer
  return this.isAffected(path)
};

/*
  TODO serializers and deserializers should allow
  for application data in 'after' and 'before'
*/

DocumentChange.prototype.serialize = function serialize () {
  var opSerializer = new OperationSerializer();
  var data = this.toJSON();
  data.ops = this.ops.map(function(op) {
    return opSerializer.serialize(op)
  });
  return JSON.stringify(data)
};

DocumentChange.prototype.clone = function clone$$1 () {
  return DocumentChange.fromJSON(this.toJSON())
};

DocumentChange.prototype.toJSON = function toJSON () {
  var data = {
    // to identify this change
    sha: this.sha,
    // before state
    before: clone(this.before),
    ops: map(this.ops, function(op) {
      return op.toJSON()
    }),
    info: this.info,
    // after state
    after: clone(this.after),
  };

  // Just to make sure rich selection objects don't end up
  // in the JSON result
  data.after.selection = undefined;
  data.before.selection = undefined;

  var sel = this.before.selection;
  if (sel && sel._isSelection) {
    data.before.selection = sel.toJSON();
  }
  sel = this.after.selection;
  if (sel && sel._isSelection) {
    data.after.selection = sel.toJSON();
  }
  return data
};

DocumentChange.deserialize = function(str) {
  var opSerializer = new OperationSerializer();
  var data = JSON.parse(str);
  data.ops = data.ops.map(function(opData) {
    return opSerializer.deserialize(opData)
  });
  if (data.before.selection) {
    data.before.selection = fromJSON(data.before.selection);
  }
  if (data.after.selection) {
    data.after.selection = fromJSON(data.after.selection);
  }
  return new DocumentChange(data)
};

DocumentChange.fromJSON = function(data) {
  // Don't write to original object on deserialization
  var change = cloneDeep(data);
  change.ops = data.ops.map(function(opData) {
    return ObjectOperation.fromJSON(opData)
  });
  change.before.selection = fromJSON(data.before.selection);
  change.after.selection = fromJSON(data.after.selection);
  return new DocumentChange(change)
};

/*
  Transforms change A with B, as if A was done before B.
  A' and B' can be used to update two clients to get to the
  same document content.

     / A - B' \
  v_n          v_n+1
     \ B - A' /
*/
DocumentChange.transformInplace = function(A, B) {
  _transformInplaceBatch(A, B);
};

function _transformInplaceSingle(a, b) {
  for (var i = 0; i < a.ops.length; i++) {
    var a_op = a.ops[i];
    for (var j = 0; j < b.ops.length; j++) {
      var b_op = b.ops[j];
      // ATTENTION: order of arguments is important.
      // First argument is the dominant one, i.e. it is treated as if it was applied before
      ObjectOperation.transform(a_op, b_op, {inplace: true});
    }
  }
  if (a.before) {
    _transformSelectionInplace(a.before.selection, b);
  }
  if (a.after) {
    _transformSelectionInplace(a.after.selection, b);
  }
  if (b.before) {
    _transformSelectionInplace(b.before.selection, a);
  }
  if (b.after) {
    _transformSelectionInplace(b.after.selection, a);
  }
}

function _transformInplaceBatch(A, B) {
  if (!isArray(A)) {
    A = [A];
  }
  if (!isArray(B)) {
    B = [B];
  }
  for (var i = 0; i < A.length; i++) {
    var a = A[i];
    for (var j = 0; j < B.length; j++) {
      var b = B[j];
      _transformInplaceSingle(a,b);
    }
  }
}

function _transformSelectionInplace(sel, a) {
  if (!sel || (!sel.isPropertySelection() && !sel.isContainerSelection()) ) {
    return false
  }
  var ops = a.ops;
  var hasChanged = false;
  var isCollapsed = sel.isCollapsed();
  for(var i=0; i<ops.length; i++) {
    var op = ops[i];
    hasChanged |= _transformCoordinateInplace(sel.start, op);
    if (!isCollapsed) {
      hasChanged |= _transformCoordinateInplace(sel.end, op);
    } else {
      if (sel.isContainerSelection()) {
        sel.end.path = sel.start.path;
      }
      sel.end.offset = sel.start.offset;
    }
  }
  return hasChanged
}

DocumentChange.transformSelection = function(sel, a) {
  var newSel = sel.clone();
  var hasChanged = _transformSelectionInplace(newSel, a);
  if (hasChanged) {
    return newSel
  } else {
    return sel
  }
};

function _transformCoordinateInplace(coor, op) {
  if (!isEqual(op.path, coor.path)) { return false }
  var hasChanged = false;
  if (op.type === 'update' && op.propertyType === 'string') {
    var diff = op.diff;
    var newOffset;
    if (diff.isInsert() && diff.pos <= coor.offset) {
      newOffset = coor.offset + diff.str.length;
      // console.log('Transforming coordinate after inserting %s chars:', diff.str.length, coor.toString(), '->', newOffset)
      coor.offset = newOffset;
      hasChanged = true;
    } else if (diff.isDelete() && diff.pos <= coor.offset) {
      newOffset = Math.max(diff.pos, coor.offset - diff.str.length);
      // console.log('Transforming coordinate after deleting %s chars:', diff.str.length, coor.toString(), '->', newOffset)
      coor.offset = newOffset;
      hasChanged = true;
    }
  }
  return hasChanged
}

var ServerRequest = function ServerRequest(message, ws) {
  this.message = message;
  this.ws = ws;
  this.isAuthenticated = false;
  this.isAuhorized = false;
};

/*
  Marks a request as authenticated
*/
ServerRequest.prototype.setAuthenticated = function setAuthenticated (session) {
  this.isAuthenticated = true;
  this.session = session;
};

/*
  Marks a request as authorized (authorizationData is optional)
*/
ServerRequest.prototype.setAuthorized = function setAuthorized (authorizationData) {
  this.isAuthorized = true;
  this.authorizationData = authorizationData;
};

/*
  Sets the isEnhanced flag
*/
ServerRequest.prototype.setEnhanced = function setEnhanced () {
  this.isEnhanced = true;
};

var ServerResponse = function ServerResponse() {
  this.isReady = false; // once the response has been set using send
  this.isEnhanced = false; // after response has been enhanced by enhancer
  this.isSent = false; // after response has been sent
  this.err = null;
  this.data = null;
};

/*
  Sends an error response

  @example

  ```js
  res.error({
    type: 'syncError',
    errorName: 'AuthenticationError',
    documentId: 'doc-1'
  });
  ```
*/
ServerResponse.prototype.error = function error (err) {
  this.err = err;
  this.isReady = true;
};

/*
  Send response data
*/
ServerResponse.prototype.send = function send (data) {
  this.data = data;
  this.isReady = true;
};

/*
  Sets the isEnhanced flag
*/
ServerResponse.prototype.setEnhanced = function setEnhanced () {
  this.isEnhanced = true;
};

ServerResponse.prototype.setSent = function setSent () {
  this.isSent = true;
};

function deleteFromArray(array, value) {
  if (!array) { return }
  for (var i = 0; i < array.length; i++) {
    if (array[i] === value) {
      array.splice(i, 1);
      i--;
    }
  }
}

// simplified version of TreeIndex for arrays
var ArrayTree = function ArrayTree () {};

ArrayTree.prototype.add = function add (path, val) {
  if (!this[path]) {
    this[path] = [];
  }
  this[path].push(val);
};
ArrayTree.prototype.remove = function remove (path, val) {
  if (this[path]) {
    deleteFromArray(this[path], val);
  }
};

var MarkersManager = function MarkersManager(editorSession) {
  this.editorSession = editorSession;

  // registry
  this._textProperties = {};
  this._dirtyProps = {};

  this._markers = new MarkersIndex(editorSession);

  editorSession.onUpdate(this._onChange, this);
  editorSession.onRender(this._updateProperties, this);
};

MarkersManager.prototype.dispose = function dispose () {
  this.editorSession.off(this);
  this._markers.dispose();
};

MarkersManager.prototype.register = function register (textProperyComponent) {
  var path = String(textProperyComponent.getPath());
  // console.log('registering property', path)
  var textProperties = this._textProperties[path];
  if (!textProperties) {
    textProperties = this._textProperties[path] = [];
  }
  textProperties.push(textProperyComponent);
};

MarkersManager.prototype.deregister = function deregister (textProperyComponent) {
  var path = String(textProperyComponent.getPath());
  // console.log('deregistering property', path)
  var textProperties = this._textProperties[path];
  if (!textProperties) {
    // FIXME: happens in test suite
    return
  }
  deleteFromArray(this._textProperties[path], textProperyComponent);
  if (textProperties.length === 0) {
    delete this._textProperties[path];
  }
};

MarkersManager.prototype.getMarkers = function getMarkers (path, opts) {
  opts = opts || {};
  var doc = this.editorSession.getDocument();
  var annos = doc.getAnnotations(path) || [];
  var markers = this._markers.get(path, opts.surfaceId, opts.containerId);
  return annos.concat(markers)
};

MarkersManager.prototype._onChange = function _onChange (editorSession) {
    var this$1 = this;

  if (editorSession.hasDocumentChanged()) {
    // mark all updated props per se as dirty
    if (editorSession.hasDocumentChanged()) {
      var change = editorSession.getChange();
      forEach(change.updated, function (val, id) {
        this$1._dirtyProps[id] = true;
      });
    }
    Object.assign(this._dirtyProps, this._markers._collectDirtyProps());
  }
};

MarkersManager.prototype._updateProperties = function _updateProperties () {
    var this$1 = this;

  Object.keys(this._dirtyProps).forEach(function (path) {
    var textProperties = this$1._textProperties[path];
    if (textProperties) {
      textProperties.forEach(this$1._updateTextProperty.bind(this$1));
    }
  });
  this._dirtyProps = {};
};

MarkersManager.prototype._updateTextProperty = function _updateTextProperty (textPropertyComponent) {
  var path = textPropertyComponent.getPath();
  var markers = this.getMarkers(path, {
    surfaceId: textPropertyComponent.getSurfaceId(),
    containerId: textPropertyComponent.getContainerId()
  });
  // console.log('## providing %s markers for %s', markers.length, path)
  textPropertyComponent.setState({
    markers: markers
  });
};

/*
  A DocumentIndex implementation for keeping track of markers
*/
var MarkersIndex = function MarkersIndex(editorSession) {
  this.editorSession = editorSession;
  this.document = editorSession.getDocument();
  this._documentMarkers = new ArrayTree();
  this._surfaceMarkers = {};
  this._containerMarkers = {};

  this._dirtyProps = {};

  this.document.addIndex('markers', this);
  editorSession.onUpdate('document', this._onDocumentChange, this);
};

MarkersIndex.prototype.dispose = function dispose () {
  // TODO: add an API to remove a custom index
  // and we should add a test which disposes the editor session
  delete this.document.data.indexes['markers'];
  this.editorSession.off(this);
};

MarkersIndex.prototype.reset = function reset () {
    var this$1 = this;

  this._documentMarkers = new ArrayTree();
  this._surfaceMarkers = {};
  this._containerMarkers = {};
  var doc = this.document;
  forEach(doc.getNodes(), function (node) {
    if (this$1.select(node)) {
      this$1.create(node);
    }
  });
};

MarkersIndex.prototype.select = function select (node) {
  return node._isMarker
};

MarkersIndex.prototype.create = function create (marker) {
  // console.log('Indexing marker', marker)
  switch (marker.constructor.scope) {
    case 'document': {
      this._dirtyProps[marker.path] = true;
      this._documentMarkers.add(marker.path, marker);
      break
    }
    case 'surface': {
      if (!this._surfaceMarkers[marker.surfaceId]) {
        this._surfaceMarkers[marker.surfaceId] = new ArrayTree();
      }
      this._dirtyProps[marker.path] = true;
      this._surfaceMarkers[marker.surfaceId].add(marker.path, marker);
      break
    }
    case 'container': {
      console.warn('Container scoped markers are not supported yet');
      break
    }
    default:
      console.error('Invalid marker scope.');
  }
};

MarkersIndex.prototype.delete = function delete$1 (marker) {
  switch (marker.constructor.scope) {
    case 'document': {
      this._dirtyProps[marker.path] = true;
      this._documentMarkers.remove(marker.path, marker);
      break
    }
    case 'surface': {
      if (!this._surfaceMarkers[marker.surfaceId]) {
        this._surfaceMarkers[marker.surfaceId] = new ArrayTree();
      }
      this._dirtyProps[marker.path] = true;
      this._surfaceMarkers[marker.surfaceId].remove(marker.path, marker);
      break
    }
    case 'container': {
      console.warn('Container scoped markers are not supported yet');
      break
    }
    default:
      console.error('Invalid marker scope.');
  }
};

MarkersIndex.prototype.get = function get (path, surfaceId) {
  var markers = this._documentMarkers[path] || [];
  if (surfaceId && this._surfaceMarkers[surfaceId]) {
    var surfaceMarkers = this._surfaceMarkers[surfaceId][path];
    if (surfaceMarkers) { markers = markers.concat(surfaceMarkers); }
  }
  // TODO support container scoped markers
  return markers
};

MarkersIndex.prototype._collectDirtyProps = function _collectDirtyProps () {
  var dirtyProps = this._dirtyProps;
  this._dirtyProps = {};
  return dirtyProps
};

// used for applying transformations
MarkersIndex.prototype._getAllCustomMarkers = function _getAllCustomMarkers (path) {
    var this$1 = this;

  var markers = this._documentMarkers[path] || [];
  for(var surfaceId in this$1._surfaceMarkers) {
    if (!this$1._surfaceMarkers.hasOwnProperty(surfaceId)) { continue }
    var surfaceMarkers = this$1._surfaceMarkers[surfaceId][path];
    if (surfaceMarkers) { markers = markers.concat(surfaceMarkers); }
  }
  // TODO: support container markers
  return markers
};

MarkersIndex.prototype._onDocumentChange = function _onDocumentChange (change) {
    var this$1 = this;

  var doc = this.doc;
  change.ops.forEach(function (op) {
    var markers = this$1._getAllCustomMarkers(op.path);
    if (op.type === 'update' && op.diff._isTextOperation) {
      var diff = op.diff;
      switch (diff.type) {
        case 'insert':
          this$1._transformInsert(doc, markers, diff);
          break
        case 'delete':
          this$1._transformDelete(doc, markers, diff);
          break
        default:
          //
      }
    }
  });
};

MarkersIndex.prototype._transformInsert = function _transformInsert (doc, markers, op) {
  var pos = op.pos;
  var length = op.str.length;
  if (length === 0) { return }
  markers.forEach(function(marker) {
    // console.log('Transforming marker after insert')
    var start = marker.start.offset;
    var end = marker.end.offset;
    var newStart = start;
    var newEnd = end;
    if (pos >= end) { return }
    if (pos <= start) {
      newStart += length;
      newEnd += length;
      marker.start.offset = newStart;
      marker.end.offset = newEnd;
      return
    }
    if (pos < end) {
      newEnd += length;
      marker.end.offset = newEnd;
      if (marker.invalidate) { marker.invalidate(); }
    }
  });
};

MarkersIndex.prototype._transformDelete = function _transformDelete (doc, markers, op) {
  var pos1 = op.pos;
  var length = op.str.length;
  var pos2 = pos1 + length;
  if (pos1 === pos2) { return }
  markers.forEach(function (marker) {
    var start = marker.start.offset;
    var end = marker.end.offset;
    var newStart = start;
    var newEnd = end;
    if (pos2 <= start) {
      newStart -= length;
      newEnd -= length;
      marker.start.offset = newStart;
      marker.end.offset = newEnd;
    } else if (pos1 >= end) {
      // nothing
    }
    // the marker needs to be changed
    // now, there might be cases where the marker gets invalid, such as a spell-correction
    else {
      if (pos1 <= start) {
        newStart = start - Math.min(pos2-pos1, start-pos1);
      }
      if (pos1 <= end) {
        newEnd = end - Math.min(pos2-pos1, end-pos1);
      }
      // TODO: we should do something special when the change occurred inside the marker
      if (start !== end && newStart === newEnd) {
        marker.remove();
        return
      }
      if (start !== newStart) {
        marker.start.offset = newStart;
      }
      if (end !== newEnd) {
        marker.end.offset = newEnd;
      }
      if (marker.invalidate) { marker.invalidate(); }
    }
  });
};

var TreeNode = function TreeNode () {};

/*
 * A tree-structure for indexes.
 *
 * @class TreeIndex
 * @param {object} [obj] An object to operate on
 * @memberof module:Basics
 * @example
 *
 * var index = new TreeIndex({a: "aVal", b: {b1: 'b1Val', b2: 'b2Val'}});
 */

var TreeIndex = function TreeIndex () {};

TreeIndex.prototype.get = function get$1 (path) {
  if (arguments.length > 1) {
    path = Array.prototype.slice(arguments, 0);
  }
  if (isString(path)) {
    path = [path];
  }
  return get(this, path);
};

TreeIndex.prototype.getAll = function getAll (path) {
  if (arguments.length > 1) {
    path = Array.prototype.slice(arguments, 0);
  }
  if (isString(path)) {
    path = [path];
  }
  if (!isArray(path)) {
    throw new Error('Illegal argument for TreeIndex.get()');
  }
  var node = get(this, path);
  return this._collectValues(node);
};

TreeIndex.prototype.set = function set (path, value) {
  if (isString(path)) {
    path = [path];
  }
  setWith(this, path, value, function(val) {
    if (!val) { return new TreeNode(); }
  });
};

TreeIndex.prototype.delete = function delete$1 (path) {
  if (isString(path)) {
    delete this[path];
  } else if(path.length === 1) {
    delete this[path[0]];
  } else {
    var key = path[path.length-1];
    path = path.slice(0, -1);
    var parent = get(this, path);
    if (parent) {
      delete parent[key];
    }
  }
};

TreeIndex.prototype.clear = function clear () {
  var root = this;
  for (var key in root) {
    if (root.hasOwnProperty(key)) {
      delete root[key];
    }
  }
};

TreeIndex.prototype.traverse = function traverse (fn) {
  this._traverse(this, [], fn);
};

TreeIndex.prototype.forEach = function forEach () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

  (ref = this).traverse.apply(ref, args);
    var ref;
};

TreeIndex.prototype._traverse = function _traverse (root, path, fn) {
    var this$1 = this;

  var id;
  for (id in root) {
    if (!root.hasOwnProperty(id)) { continue; }
    var child = root[id];
    var childPath = path.concat([id]);
    if (child instanceof TreeNode) {
      this$1._traverse(child, childPath, fn);
    } else {
      fn(child, childPath);
    }
  }
};

TreeIndex.prototype._collectValues = function _collectValues (root) {
  // TODO: don't know if this is the best solution
  // We use this only for indexes, e.g., to get all annotation on one node
  var vals = {};
  this._traverse(root, [], function(val, path) {
    var key = path[path.length-1];
    vals[key] = val;
  });
  return vals;
};

var TreeIndexArrays = (function (TreeIndex) {
  function TreeIndexArrays () {
    TreeIndex.apply(this, arguments);
  }

  if ( TreeIndex ) TreeIndexArrays.__proto__ = TreeIndex;
  TreeIndexArrays.prototype = Object.create( TreeIndex && TreeIndex.prototype );
  TreeIndexArrays.prototype.constructor = TreeIndexArrays;

  TreeIndexArrays.prototype.contains = function contains (path) {
    var val = TreeIndex.prototype.get.call(this, path);
    return Boolean(val)
  };

  TreeIndexArrays.prototype.get = function get$$1 (path) {
    var val = TreeIndex.prototype.get.call(this, path);
    if (val instanceof TreeNode) {
      val = val.__values__ || [];
    }
    return val;
  };

  TreeIndexArrays.prototype.set = function set (path, arr) {
    var val = TreeIndex.prototype.get.call(this, path);
    val.__values__ = arr;
  };

  TreeIndexArrays.prototype.add = function add (path, value) {
    if (isString(path)) {
      path = [path];
    }
    if (!isArray(path)) {
      throw new Error('Illegal arguments.');
    }
    var arr;

    // We are using setWith, as it allows us to create nodes on the way down
    // setWith can be controlled via a hook called for each key in the path
    // If val is not defined, a new node must be created and returned.
    // If val is defined, then we must return undefined to keep the original tree node
    // __dummy__ is necessary as setWith is used to set a value, but we want
    // to append to the array
    setWith(this, path.concat(['__values__','__dummy__']), undefined, function(val, key) {
      if (key === '__values__') {
        if (!val) { val = []; }
        arr = val;
      } else if (!val) {
        val = new TreeNode();
      }
      return val;
    });
    delete arr.__dummy__;
    arr.push(value);
  };

  TreeIndexArrays.prototype.remove = function remove (path, value) {
    var arr = get(this, path);
    if (arr instanceof TreeNode) {
      if (arguments.length === 1) {
        delete arr.__values__;
      } else {
        deleteFromArray(arr.__values__, value);
      }
    }
  };

  TreeIndexArrays.prototype._collectValues = function _collectValues (root) {
    var vals = [];
    this._traverse(root, [], function(val) {
      vals.push(val);
    });
    vals = Array.prototype.concat.apply([], vals);
    return vals
  };

  return TreeIndexArrays;
}(TreeIndex));

TreeIndex.Arrays = TreeIndexArrays;

function isFunction$2(f) {
  return typeof f === 'function'
}

function filter(iteratee, fn) {
  if (!iteratee) { return [] }
  if (iteratee.constructor.prototype.filter && isFunction$2(iteratee.constructor.prototype.filter)) {
    return iteratee.filter(fn)
  }
  var result = [];
  forEach(iteratee, function (val, key) {
    if (fn(val, key)) {
      result.push(val);
    }
  });
  return result
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr)
}

/**
  Index for Nodes.

  Node indexes are first-class citizens in {@link model/data/Data}.
  I.e., they are updated after each operation, and before any other listener is notified.

  @abstract

 */
var NodeIndex = function NodeIndex () {};

NodeIndex.prototype.select = function select (node) { // eslint-disable-line no-unused-vars
  throw new Error('This method is abstract.')
};

/**
  Called when a node has been created.

  @param {Node} node
 */
NodeIndex.prototype.create = function create (node) { // eslint-disable-line no-unused-vars
  throw new Error('This method is abstract.')
};

/**
  Called when a node has been deleted.

  @param {model/data/Node} node
 */
NodeIndex.prototype.delete = function delete$1 (node) { // eslint-disable-line no-unused-vars
  throw new Error('This method is abstract.')
};

NodeIndex.prototype.set = function set (node, path, newValue, oldValue) {
  this.update(node, path, newValue, oldValue);
};

/**
  Called when a property has been updated.

  @private
  @param {Node} node
 */
NodeIndex.prototype.update = function update (node, path, newValue, oldValue) { // eslint-disable-line no-unused-vars
  throw new Error('This method is abstract.')
};

/**
  Reset the index using a Data instance.

  @private
 */
NodeIndex.prototype.reset = function reset (data) {
  this._clear();
  this._initialize(data);
};

/**
  Clone this index.

  @return A cloned NodeIndex.
 */
NodeIndex.prototype.clone = function clone () {
  var NodeIndexClass = this.constructor;
  var clone = new NodeIndexClass();
  return clone
};

NodeIndex.prototype._clear = function _clear () {
  throw new Error('This method is abstract')
};

NodeIndex.prototype._initialize = function _initialize (data) {
  forEach(data.getNodes(), function(node) {
    if (this.select(node)) {
      this.create(node);
    }
  }.bind(this));
};

/**
  Create a new NodeIndex using the given prototype as mixin.

  @param {Object} prototype
  @returns {NodeIndex} A customized NodeIndex.
 */
NodeIndex.create = function(prototype) {
  var index = Object.assign(new NodeIndex(), prototype);
  index.clone = function() {
    return NodeIndex.create(prototype)
  };
  return index
};

/**
  Create a filter to filter nodes by type.

  @param {String} type
  @returns {function}
 */
NodeIndex.filterByType = function(type) {
  return function(node) {
    return node.isInstanceOf(type)
  }
};

var DocumentIndex = (function (NodeIndex$$1) {
	function DocumentIndex () {
		NodeIndex$$1.apply(this, arguments);
	}if ( NodeIndex$$1 ) DocumentIndex.__proto__ = NodeIndex$$1;
	DocumentIndex.prototype = Object.create( NodeIndex$$1 && NodeIndex$$1.prototype );
	DocumentIndex.prototype.constructor = DocumentIndex;

	

	return DocumentIndex;
}(NodeIndex));

// A collection of methods to update annotations
// --------
//
// As we treat annotations as overlay of plain text we need to keep them up-to-date during editing.

var annotationHelpers = {
  insertedText: insertedText,
  deletedText: deletedText,
  transferAnnotations: transferAnnotations,
  expandAnnotation: expandAnnotation,
  fuseAnnotation: fuseAnnotation,
  truncateAnnotation: truncateAnnotation
};

function insertedText(doc, coordinate, length) {
  if (!length) { return; }
  var index = doc.getIndex('annotations');
  var annotations = index.get(coordinate.path);
  for (var i = 0; i < annotations.length; i++) {
    var anno = annotations[i];
    var pos = coordinate.offset;
    var start = anno.start.offset;
    var end = anno.end.offset;
    var newStart = start;
    var newEnd = end;
    if ( (pos < start) ||
         (pos === start) ) {
      newStart += length;
    }
    // inline nodes do not expand automatically
    if ( (pos < end) ||
         (pos === end && !anno.isInline()) ) {
      newEnd += length;
    }
    // TODO: Use coordintate ops!
    if (newStart !== start) {
      doc.set([anno.id, 'start', 'offset'], newStart);
    }
    if (newEnd !== end) {
      doc.set([anno.id, 'end', 'offset'], newEnd);
    }
  }

  // TODO: fix support for container annotations
  // // same for container annotation anchors
  // index = doc.getIndex('container-annotation-anchors');
  // var anchors = index.get(coordinate.path);
  // forEach(anchors, function(anchor) {
  //   var pos = coordinate.offset;
  //   var start = anchor.offset;
  //   var changed = false;
  //   if ( (pos < start) ||
  //        (pos === start && !coordinate.after) ) {
  //     start += length;
  //     changed = true;
  //   }
  //   if (changed) {
  //     let coor = (anchor.isStart?'start':'end');
  //     // TODO: Use coordintate ops!
  //     doc.set([anchor.id, coor, 'offset'], start);
  //   }
  // });
}

function deletedText(doc, path, startOffset, endOffset) {
  if (startOffset === endOffset) { return; }
  var index = doc.getIndex('annotations');
  var annotations = index.get(path);
  var length = endOffset - startOffset;
  for (var i = 0; i < annotations.length; i++) {
    var anno = annotations[i];
    var pos1 = startOffset;
    var pos2 = endOffset;
    var start = anno.start.offset;
    var end = anno.end.offset;
    var newStart = start;
    var newEnd = end;
    if (pos2 <= start) {
      newStart -= length;
      newEnd -= length;
      doc.set([anno.id, 'start', 'offset'], newStart);
      doc.set([anno.id, 'end', 'offset'], newEnd);
    } else {
      if (pos1 <= start) {
        newStart = start - Math.min(pos2-pos1, start-pos1);
      }
      if (pos1 <= end) {
        newEnd = end - Math.min(pos2-pos1, end-pos1);
      }
      // delete the annotation if it has collapsed by this delete
      if (start !== end && newStart === newEnd) {
        doc.delete(anno.id);
      } else {
        // TODO: Use coordintate ops!
        if (start !== newStart) {
          doc.set([anno.id, 'start', 'offset'], newStart);
        }
        if (end !== newEnd) {
          doc.set([anno.id, 'end', 'offset'], newEnd);
        }
      }
    }
  }
  // TODO: fix support for container annotations
  // // same for container annotation anchors
  // index = doc.getIndex('container-annotation-anchors');
  // var anchors = index.get(path);
  // var containerAnnoIds = [];
  // forEach(anchors, function(anchor) {
  //   containerAnnoIds.push(anchor.id);
  //   var pos1 = startOffset;
  //   var pos2 = endOffset;
  //   var start = anchor.offset;
  //   var changed = false;
  //   if (pos2 <= start) {
  //     start -= length;
  //     changed = true;
  //   } else {
  //     if (pos1 <= start) {
  //       var newStart = start - Math.min(pos2-pos1, start-pos1);
  //       if (start !== newStart) {
  //         start = newStart;
  //         changed = true;
  //       }
  //     }
  //   }
  //   if (changed) {
  //     // TODO: Use coordintate ops!
  //     let coor = (anchor.isStart?'start':'end');
  //     doc.set([anchor.id, coor, 'offset'], start);
  //   }
  // });
  // // check all anchors after that if they have collapsed and remove the annotation in that case
  // forEach(uniq(containerAnnoIds), function(id) {
  //   var anno = doc.get(id);
  //   var annoSel = anno.getSelection();
  //   if(annoSel.isCollapsed()) {
  //     // console.log("...deleting container annotation because it has collapsed" + id);
  //     doc.delete(id);
  //   }
  // });
}

// used when breaking a node to transfer annotations to the new property
function transferAnnotations(doc, path, offset, newPath, newOffset) {
  var index = doc.getIndex('annotations');
  var annotations = index.get(path, offset);
  for (var i = 0; i < annotations.length; i++) {
    var a = annotations[i];
    var isInside = (offset > a.start.offset && offset < a.end.offset);
    var start = a.start.offset;
    var end = a.end.offset;
    // 1. if the cursor is inside an annotation it gets either split or truncated
    if (isInside) {
      // create a new annotation if the annotation is splittable
      if (a.canSplit()) {
        var newAnno = a.toJSON();
        newAnno.id = uuid(a.type + "_");
        newAnno.start.path = newPath;
        newAnno.start.offset = newOffset;
        newAnno.end.path = newPath;
        newAnno.end.offset = newOffset + a.end.offset - offset;
        doc.create(newAnno);
      }
      // in either cases truncate the first part
      var newStartOffset = a.start.offset;
      var newEndOffset = offset;
      // if after truncate the anno is empty, delete it
      if (newEndOffset === newStartOffset) {
        doc.delete(a.id);
      }
      // ... otherwise update the range
      else {
        // TODO: Use coordintate ops!
        if (newStartOffset !== start) {
          doc.set([a.id, 'start', 'offset'], newStartOffset);
        }
        if (newEndOffset !== end) {
          doc.set([a.id, 'end', 'offset'], newEndOffset);
        }
      }
    }
    // 2. if the cursor is before an annotation then simply transfer the annotation to the new node
    else if (a.start.offset >= offset) {
      // TODO: Use coordintate ops!
      // Note: we are preserving the annotation so that anything which is connected to the annotation
      // remains valid.
      doc.set([a.id, 'start', 'path'], newPath);
      doc.set([a.id, 'start', 'offset'], newOffset + a.start.offset - offset);
      doc.set([a.id, 'end', 'path'], newPath);
      doc.set([a.id, 'end', 'offset'], newOffset + a.end.offset - offset);
    }
  }

  // TODO: fix support for container annotations
  // // same for container annotation anchors
  // index = doc.getIndex('container-annotation-anchors');
  // var anchors = index.get(path);
  // var containerAnnoIds = [];
  // forEach(anchors, function(anchor) {
  //   containerAnnoIds.push(anchor.id);
  //   var start = anchor.offset;
  //   if (offset <= start) {
  //     // TODO: Use coordintate ops!
  //     let coor = anchor.isStart?'start':'end'
  //     doc.set([anchor.id, coor, 'path'], newPath);
  //     doc.set([anchor.id, coor, 'offset'], newOffset + anchor.offset - offset);
  //   }
  // });
  // // check all anchors after that if they have collapsed and remove the annotation in that case
  // forEach(uniq(containerAnnoIds), function(id) {
  //   var anno = doc.get(id);
  //   var annoSel = anno.getSelection();
  //   if(annoSel.isCollapsed()) {
  //     // console.log("...deleting container annotation because it has collapsed" + id);
  //     doc.delete(id);
  //   }
  // });
}

/*
 @param {model/Document} tx
 @param {model/PropertyAnnotation} args.anno annotation which should be expanded
 @param {model/Selection}  args.selection selection to which to expand
*/
function truncateAnnotation(tx, anno, sel) {
  if (!sel || !sel._isSelection) { throw new Error('Argument "selection" is required.') }
  if (!anno || !anno._isAnnotation) { throw new Error('Argument "anno" is required.') }
  var annoSel = anno.getSelection();
  var newAnnoSel = annoSel.truncateWith(sel);
  anno._updateRange(tx, newAnnoSel);
  return anno
}

/*
 @param {model/Document} tx
 @param {model/PropertyAnnotation} args.anno annotation which should be expanded
 @param {model/Selection}  args.selection selection to which to expand
*/
function expandAnnotation(tx, anno, sel) {
  if (!sel || !sel._isSelection) { throw new Error('Argument "selection" is required.') }
  if (!anno || !anno._isAnnotation) { throw new Error('Argument "anno" is required.') }
  var annoSel = anno.getSelection();
  var newAnnoSel = annoSel.expand(sel);
  anno._updateRange(tx, newAnnoSel);
  return anno
}

/*
 @param {model/Document} tx
 @param {model/PropertyAnnotation[]} args.annos annotations which should be fused
*/
function fuseAnnotation(tx, annos) {
  if (!isArray(annos) || annos.length < 2) {
    throw new Error('fuseAnnotation(): at least two annotations are necessary.')
  }
  var sel, annoType;
  annos.forEach(function(anno, idx) {
    if (idx === 0) {
      sel = anno.getSelection();
      annoType = anno.type;
    } else {
      if (anno.type !== annoType) {
        throw new Error('fuseAnnotation(): all annotations must be of the same type.')
      }
      sel = sel.expand(anno.getSelection());
    }
  });
  // expand the first and delete the others
  for (var i = 1; i < annos.length; i++) {
    tx.delete(annos[i].id);
  }
  expandAnnotation(tx, annos[0], sel);
  tx.setSelection(sel);
}

/**
  Some helpers for working with Documents.

  @module
  @example

  ```js
  import { documentHelpers } from 'substance'
  documentHelpers.isContainerAnnotation(doc, 'comment')
  ```
*/
var documentHelpers = {
  isContainerAnnotation: isContainerAnnotation,
  getPropertyAnnotationsForSelection: getPropertyAnnotationsForSelection,
  getContainerAnnotationsForSelection: getContainerAnnotationsForSelection,
  getAnnotationsForSelection: getAnnotationsForSelection,
  getTextForSelection: getTextForSelection,
  getMarkersForSelection: getMarkersForSelection,
  getChangeFromDocument: getChangeFromDocument,
  copyNode: copyNode,
  deleteNode: deleteNode,
  deleteTextRange: deleteTextRange,
  deleteListRange: deleteListRange,
  mergeListItems: mergeListItems
};

/**
  @param {Document} doc
  @param {String} type
  @return {Boolean} `true` if given type is a {@link ContainerAnnotation}
*/
function isContainerAnnotation(doc, type) {
  var schema = doc.getSchema();
  return schema.isInstanceOf(type, 'container-annotation');
}

/**
  For a given selection get all property annotations

  @param {Document} doc
  @param {Selection} sel
  @return {PropertyAnnotation[]} An array of property annotations.
          Returns an empty array when selection is a container selection.
*/
function getPropertyAnnotationsForSelection(doc, sel, options) {
  options = options || {};
  if (!sel.isPropertySelection()) {
    return [];
  }
  var path = sel.getPath();
  var annotations = doc.getIndex('annotations').get(path, sel.start.offset, sel.end.offset);
  if (options.type) {
    annotations = filter(annotations, DocumentIndex.filterByType(options.type));
  }
  return annotations;
}

/**
  For a given selection get all container annotations

  @param {Document} doc
  @param {Selection} sel
  @param {String} containerId
  @param {String} options.type provides only annotations of that type
  @return {Array} An array of container annotations
*/
function getContainerAnnotationsForSelection(doc, sel, containerId, options) {
  // ATTENTION: looking for container annotations is not as efficient as property
  // selections, as we do not have an index that has notion of the spatial extend
  // of an annotation. Opposed to that, common annotations are bound
  // to properties which make it easy to lookup.
  if (!containerId) {
    throw new Error("'containerId' is required.");
  }
  options = options || {};
  var index = doc.getIndex('container-annotations');
  var annotations = index.get(containerId, options.type);
  annotations = filter(annotations, function(anno) {
    return sel.overlaps(anno.getSelection());
  });
  return annotations;
}

/**
  For a given selection, get annotations of a certain type

  @param {Document} doc
  @param {Selection} sel
  @param {string} annotationType
  @param {string} containerId (only needed when type is a container annotation)
  @return {array} all matching annotations
*/
function getAnnotationsForSelection(doc, sel, annotationType, containerId) {
  var annos;
  var isContainerAnno = isContainerAnnotation(doc, annotationType);

  if (isContainerAnno) {
    var container = doc.get(containerId, 'strict');
    annos = getContainerAnnotationsForSelection(doc, sel, container, {
      type: annotationType
    });
  } else {
    annos = getPropertyAnnotationsForSelection(doc, sel, { type: annotationType });
  }
  return annos;
}

/**
  For a given selection, get the corresponding text string

  @param {Document} doc
  @param {Selection} sel
  @return {string} text enclosed by the annotation
*/
function getTextForSelection(doc, sel) {
  if (!sel || sel.isNull()) {
    return "";
  } else if (sel.isPropertySelection()) {
    var text = doc.get(sel.start.path);
    return text.substring(sel.start.offset, sel.end.offset);
  } else if (sel.isContainerSelection()) {
    var result = [];
    var nodeIds = sel.getNodeIds();
    var L = nodeIds.length;
    for (var i = 0; i < L; i++) {
      var id = nodeIds[i];
      var node = doc.get(id);
      if (node.isText()) {
        var text$1 = node.getText();
        if (i === L-1) {
          text$1 = text$1.slice(0, sel.end.offset);
        }
        if (i === 0) {
          text$1 = text$1.slice(sel.start.offset);
        }
        result.push(text$1);
      }
    }
    return result.join('\n');
  }
}

function getMarkersForSelection(doc, sel) {
  // only PropertySelections are supported right now
  if (!sel || !sel.isPropertySelection()) { return [] }
  var path = sel.getPath();
  // markers are stored as one hash for each path, grouped by marker key
  var markers = doc.getIndex('markers').get(path);
  var filtered = filter(markers, function(m) {
    return m.containsSelection(sel)
  });
  return filtered
}

function getChangeFromDocument(doc) {
  var nodes = doc.getNodes();
  var annotations = [];
  var contentNodes = [];
  var containers = [];

  forEach(nodes, function (node) {
    if (node._isAnnotation) {
      annotations.push(node);
    } else if (node._isContainer) {
      containers.push(node);
    } else {
      contentNodes.push(node);
    }
  });

  var ops = contentNodes.concat(containers).concat(annotations).map(function (node) {
    return ObjectOperation.Create([node.id], node.toJSON())
  });

  return new DocumentChange({ops: ops})
}

/*
  Deletes a node and its children and attached annotations
  and removes it from a given container
*/
function deleteNode(doc, node) {
  if (!node) {
    console.warn('Invalid arguments');
    return
  }
  if (node.isText()) {
    // remove all associated annotations
    var annos = doc.getIndex('annotations').get(node.id);
    for (var i = 0; i < annos.length; i++) {
      doc.delete(annos[i].id);
    }
  }
  // delete recursively
  // ATM we do a cascaded delete if the property has type 'id' or ['array', 'id'] and property 'owned' set,
  // or if it 'file'
  var nodeSchema = node.getSchema();
  forEach(nodeSchema, function (prop) {
    if ((prop.isReference() && prop.isOwned()) || (prop.type === 'file')) {
      if (prop.isArray()) {
        var ids = node[prop.name];
        ids.forEach(function (id) {
          deleteNode(doc, doc.get(id));
        });
      } else {
        deleteNode(doc, doc.get(node[prop.name]));
      }
    }
  });
  doc.delete(node.id);
}

/*
  Creates a 'deep' JSON copy of a node returning an array of JSON objects
  that can be used to create the object tree owned by the given root node.

  @param {DocumentNode} node
*/
function copyNode(node) {
  var nodes = [];
  // EXPERIMENTAL: using schema reflection to determine whether to do a 'deep' copy or just shallow
  var nodeSchema = node.getSchema();
  var doc = node.getDocument();
  forEach(nodeSchema, function (prop) {
    // ATM we do a cascaded copy if the property has type 'id', ['array', 'id'] and is owned by the node,
    // or it is of type 'file'
    if ((prop.isReference() && prop.isOwned()) || (prop.type === 'file')) {
      var val = node[prop.name];
      nodes.push(_copyChildren(val));
    }
  });
  nodes.push(node.toJSON());
  var annotationIndex = node.getDocument().getIndex('annotations');
  var annotations = annotationIndex.get([node.id]);
  forEach(annotations, function(anno) {
    nodes.push(anno.toJSON());
  });
  var result = flatten(nodes).filter(Boolean);
  // console.log('copyNode()', node, result)
  return result

  function _copyChildren(val) {
    if (!val) { return null }
    if (isArray(val)) {
      return flatten(val.map(_copyChildren))
    } else {
      var id = val;
      if (!id) { return null }
      var child = doc.get(id);
      if (!child) { return }
      return copyNode(child)
    }
  }
}

/*
  <-->: anno
  |--|: area of change
  I: <--> |--|     :   nothing
  II: |--| <-->    :   move both by total span
  III: |-<-->-|    :   delete anno
  IV: |-<-|->      :   move start by diff to start, and end by total span
  V: <-|->-|       :   move end by diff to start
  VI: <-|--|->     :   move end by total span
*/
function deleteTextRange(doc, start, end) {
  if (!start) {
    start = {
      path: end.path,
      offset: 0
    };
  }
  var path = start.path;
  var text = doc.get(path);
  if (!end) {
    end = {
      path: start.path,
      offset: text.length
    };
  }
  if (!isArrayEqual(start.path, end.path)) { throw new Error('Unsupported state: selection should be on one property') }
  var startOffset = start.offset;
  var endOffset = end.offset;
  doc.update(path, { type: 'delete', start: startOffset, end: endOffset });
  // update annotations
  var annos = doc.getAnnotations(path);
  annos.forEach(function(anno) {
    var annoStart = anno.start.offset;
    var annoEnd = anno.end.offset;
    // I anno is before
    if (annoEnd<=startOffset) {
      return
    }
    // II anno is after
    else if (annoStart>=endOffset) {
      doc.update([anno.id, 'start'], { type: 'shift', value: startOffset-endOffset });
      doc.update([anno.id, 'end'], { type: 'shift', value: startOffset-endOffset });
    }
    // III anno is deleted
    else if (annoStart>=startOffset && annoEnd<=endOffset) {
      doc.delete(anno.id);
    }
    // IV anno.start between and anno.end after
    else if (annoStart>=startOffset && annoEnd>=endOffset) {
      if (annoStart>startOffset) {
        doc.update([anno.id, 'start'], { type: 'shift', value: startOffset-annoStart });
      }
      doc.update([anno.id, 'end'], { type: 'shift', value: startOffset-endOffset });
    }
    // V anno.start before and anno.end between
    else if (annoStart<=startOffset && annoEnd<=endOffset) {
      doc.update([anno.id, 'end'], { type: 'shift', value: startOffset-annoEnd });
    }
    // VI anno.start before and anno.end after
    else if (annoStart<startOffset && annoEnd >= endOffset) {
      doc.update([anno.id, 'end'], { type: 'shift', value: startOffset-endOffset });
    }
    else {
      console.warn('TODO: handle annotation update case.');
    }
  });
}

function deleteListRange(doc, list, start, end) {
  if (doc !== list.getDocument()) {
    list = doc.get(list.id);
  }
  if (!start) {
    start = {
      path: list.getItemAt(0).getTextPath(),
      offset: 0
    };
  }
  if (!end) {
    var item = list.getLastItem();
    end = {
      path: item.getTextPath(),
      offset: item.getLength()
    };
  }
  var startId = start.path[0];
  var startPos = list.getItemPosition(startId);
  var endId = end.path[0];
  var endPos = list.getItemPosition(endId);
  // range within the same item
  if (startPos === endPos) {
    deleteTextRange(doc, start, end);
    return
  }
  // normalize the range if it is 'reverse'
  if (startPos > endPos) {
    var assign;
    (assign = [end, start], start = assign[0], end = assign[1]);
    var assign$1;
    (assign$1 = [endPos, startPos], startPos = assign$1[0], endPos = assign$1[1]);
    var assign$2;
    (assign$2 = [endId, startId], startId = assign$2[0], endId = assign$2[1]);
  }
  var firstItem = doc.get(startId);
  var lastItem = doc.get(endId);
  var firstEntirelySelected = isEntirelySelected(doc, firstItem, start, null);
  var lastEntirelySelected = isEntirelySelected(doc, lastItem, null, end);

  // delete or truncate last node
  if (lastEntirelySelected) {
    list.removeItemAt(endPos);
    deleteNode(doc, lastItem);
  } else {
    deleteTextRange(doc, null, end);
  }

  // delete inner nodes
  for (var i = endPos-1; i > startPos; i--) {
    var itemId = list.items[i];
    list.removeItemAt(i);
    deleteNode(doc, doc.get(itemId));
  }

  // delete or truncate the first node
  if (firstEntirelySelected) {
    list.removeItemAt(startPos);
    deleteNode(doc, firstItem);
  } else {
    deleteTextRange(doc, start, null);
  }

  if (!firstEntirelySelected && !lastEntirelySelected) {
    mergeListItems(doc, list.id, startPos);
  }
}

function mergeListItems(doc, listId, itemPos) {
  // HACK: make sure that the list is really from the doc
  var list = doc.get(listId);
  var target = list.getItemAt(itemPos);
  var targetPath = target.getTextPath();
  var targetLength = target.getLength();
  var source = list.getItemAt(itemPos+1);
  var sourcePath = source.getTextPath();
  // hide source
  list.removeItemAt(itemPos+1);
  // append the text
  doc.update(targetPath, { type: 'insert', start: targetLength, text: source.getText() });
  // transfer annotations
  annotationHelpers.transferAnnotations(doc, sourcePath, 0, targetPath, targetLength);
  doc.delete(source.id);
}

// import printStacktrace from '../util/printStacktrace'

var SelectionState = function SelectionState(doc) {
  this.document = doc;

  this.selection = Selection.nullSelection;
  this._state = {};
  this._resetState();
};

SelectionState.prototype.setSelection = function setSelection (sel) {
  // printStacktrace()
  if (!sel) {
    sel = Selection.nullSelection;
  } else {
    sel.attach(this.document);
  }
  // TODO: selection state is selection plus derived state,
  // thus we need to return false only if both did not change
  this._deriveState(sel);
  this.selection = sel;
  return true
};

SelectionState.prototype.getSelection = function getSelection () {
  return this.selection
};

SelectionState.prototype.getAnnotationsForType = function getAnnotationsForType (type) {
  var state = this._state;
  if (state.annosByType) {
    return state.annosByType.get(type) || []
  }
  return []
};

SelectionState.prototype.getMarkers = function getMarkers () {
  // returns markers under the current selection
  return this._state.markers || []
};

SelectionState.prototype.isInlineNodeSelection = function isInlineNodeSelection () {
  return this._state.isInlineNodeSelection
};

SelectionState.prototype.getContainer = function getContainer () {
  return this._state.container
};

SelectionState.prototype.getPreviousNode = function getPreviousNode () {
  return this._state.previousNode
};

SelectionState.prototype.getNextNode = function getNextNode () {
  return this._state.nextNode
};

/*
  @returns if the previous node is one char away
*/
SelectionState.prototype.isFirst = function isFirst$$1 () {
  return Boolean(this._state.isFirst)
};

/*
  @returns if the next node is one char away
*/
SelectionState.prototype.isLast = function isLast$$1 () {
  return Boolean(this._state.isLast)
};

SelectionState.prototype.get = function get (key) {
  return this._state[key]
};

// used to store custom states (e.g. IsolatedNodeComponent uses this)
SelectionState.prototype.set = function set (key, value) {
  if (this._state[key]) {
    throw new Error(("State " + key + " is already set"))
  }
  this._state[key] = value;
};

SelectionState.prototype._deriveState = function _deriveState (sel) {
  this._resetState();
  this._deriveContainerSelectionState(sel);
  this._deriveAnnoState(sel);
  if (this.document.getIndex('markers')) {
    this._deriveMarkerState(sel);
  }
  // console.log('SelectionState:', this._state)
};

SelectionState.prototype._deriveContainerSelectionState = function _deriveContainerSelectionState (sel) {
  var state = this._state;
  var doc = this.document;
  if (sel.containerId) {
    var container = doc.get(sel.containerId);
    state.container = container;
    var startId = sel.start.getNodeId();
    var endId = sel.end.getNodeId();
    var startNode = doc.get(startId).getRoot();
    var startPos = container.getPosition(startNode);
    if (startPos > 0) {
      state.previousNode = container.getNodeAt(startPos-1);
    }
    state.isFirst = isFirst(doc, sel.start);
    var endNode, endPos;
    if (endId === startId) {
      endNode = startNode;
      endPos = startPos;
    } else {
      endNode = doc.get(endId).getRoot();
      endPos = container.getPosition(endNode);
    }
    if (endPos < container.getLength()-1) {
      state.nextNode = container.getNodeAt(endPos+1);
    }
    state.isLast = isLast(doc, sel.end);
  }
};

SelectionState.prototype._deriveAnnoState = function _deriveAnnoState (sel) {
  var doc = this.document;
  var state = this._state;

  // create a mapping by type for the currently selected annotations
  var annosByType = new TreeIndex.Arrays();
  var propAnnos = documentHelpers.getPropertyAnnotationsForSelection(doc, sel);
  propAnnos.forEach(function(anno) {
    annosByType.add(anno.type, anno);
  });

  if (propAnnos.length === 1 && propAnnos[0].isInline()) {
    state.isInlineNodeSelection = propAnnos[0].getSelection().equals(sel);
  }

  var containerId = sel.containerId;
  if (containerId) {
    var containerAnnos = documentHelpers.getContainerAnnotationsForSelection(doc, sel, containerId);
    containerAnnos.forEach(function(anno) {
      annosByType.add(anno.type, anno);
    });
  }
  state.annosByType = annosByType;
};

SelectionState.prototype._deriveMarkerState = function _deriveMarkerState (sel) {
  var doc = this.document;
  var state = this._state;
  var markers = documentHelpers.getMarkersForSelection(doc, sel);
  state.markers = markers;
};

SelectionState.prototype._resetState = function _resetState () {
  this._state = {
    // all annotations under the current selection
    annosByType: null,
    // markers under the current selection
    markers: null,
    // flags for inline nodes
    isInlineNodeSelection: false,
    // container information (only for ContainerSelection)
    container: null,
    previousNode: null,
    nextNode: null,
    // if the previous node is one char away
    isFirst: false,
    // if the next node is one char away
    isLast: false
  };
  return this._state
};

var ChangeHistory = function ChangeHistory() {
  // undo list
  this.doneChanges = [];
  // redo list
  this.undoneChanges = [];
  // last change for accumlation
  this.lastChange = null;
};

ChangeHistory.prototype.canUndo = function canUndo () {
  return this.doneChanges.length > 0
};

ChangeHistory.prototype.canRedo = function canRedo () {
  return this.undoneChanges.length > 0
};

ChangeHistory.prototype.push = function push (change) {
  this.doneChanges.push(change);
  this.undoneChanges = [];
};

var SurfaceManager = function SurfaceManager(editorSession) {
  this.editorSession = editorSession;
  this.surfaces = {};
  this._state = {
    focusedSurfaceId: null,
    selection: null,
  };
  editorSession.onUpdate('selection', this._onSelectionChanged, this);
  editorSession.onPostRender(this._recoverDOMSelection, this);
};

SurfaceManager.prototype.dispose = function dispose () {
  this.editorSession.off(this);
};

/**
 * Get Surface instance
 *
 * @param {String} name Name under which the surface is registered
 * @return {ui/Surface} The surface instance
 */
SurfaceManager.prototype.getSurface = function getSurface (name) {
  if (name) {
    return this.surfaces[name]
  }
};

/**
 * Get the currently focused Surface.
 *
 * @return {ui/Surface} Surface instance
 */
SurfaceManager.prototype.getFocusedSurface = function getFocusedSurface () {
  if (this._state.focusedSurfaceId) {
    return this.getSurface(this._state.focusedSurfaceId)
  }
};

SurfaceManager.prototype.getSurfaces = function getSurfaces () {
    var this$1 = this;

  // HACK: not yet. we would need a polyfill
  // return Object.values(this.surfaces)
  return Object.keys(this.surfaces).map(function (key) { return this$1.surfaces[key]; })
};

/**
 * Register a surface
 *
 * @param surface {ui/Surface} A new surface instance to register
 */
SurfaceManager.prototype.registerSurface = function registerSurface (surface) {
  this.surfaces[surface.getId()] = surface;
};

/**
 * Unregister a surface
 *
 * @param surface {ui/Surface} A surface instance to unregister
 */
SurfaceManager.prototype.unregisterSurface = function unregisterSurface (surface) {
  surface.off(this);
  var surfaceId = surface.getId();
  var registeredSurface = this.surfaces[surfaceId];
  if (registeredSurface === surface) {
    var focusedSurface = this.getFocusedSurface();
    delete this.surfaces[surfaceId];
    if (surface && focusedSurface === surface) {
      this._state.focusedSurfaceId = null;
    }
  }
};

SurfaceManager.prototype._onSelectionChanged = function _onSelectionChanged (selection) {
  var state = this._state;
  state.selection = selection;
  state.focusedSurfaceId = selection.surfaceId;
  // HACK: removing DOM selection *and* blurring when having a CustomSelection
  // otherwise we will receive events on the wrong surface
  // instead of bubbling up to GlobalEventManager
  if (selection && selection.isCustomSelection() && inBrowser) {
    window.getSelection().removeAllRanges();
    window.document.activeElement.blur();
  }
};

SurfaceManager.prototype._recoverDOMSelection = function _recoverDOMSelection () {
  // at the end of the update flow, make sure the surface is focused
  // and displays the right DOM selection.
  var focusedSurface = this.getFocusedSurface();
  if (focusedSurface && !focusedSurface.isDisabled()) {
    // console.log('Rendering selection on surface', focusedSurface.getId(), this.editorSession.getSelection().toString());
    focusedSurface.focus();
    focusedSurface.rerenderDOMSelection();
  }
};

var PropertyIndex = (function (NodeIndex$$1) {
  function PropertyIndex(property) {
    NodeIndex$$1.call(this);

    this._property = property || 'id';
    this.index = new TreeIndex();
  }

  if ( NodeIndex$$1 ) PropertyIndex.__proto__ = NodeIndex$$1;
  PropertyIndex.prototype = Object.create( NodeIndex$$1 && NodeIndex$$1.prototype );
  PropertyIndex.prototype.constructor = PropertyIndex;

  /**
    Get all indexed nodes for a given path.

    @param {Array<String>} path
    @returns A node or an object with ids and nodes as values.
   */
  PropertyIndex.prototype.get = function get (path) {
    return this.index.get(path) || {}
  };

  /**
    Collects nodes recursively.

    @returns An object with ids as keys and nodes as values.
   */
  PropertyIndex.prototype.getAll = function getAll (path) {
    return this.index.getAll(path)
  };

  /**
    Check if a node should be indexed.

    Used internally only. Override this in subclasses to achieve a custom behavior.

    @private
    @param {Node}
    @returns {Boolean} true if the given node should be added to the index.
   */
  PropertyIndex.prototype.select = function select (node) { // eslint-disable-line
    return true
  };

  /**
    Called when a node has been created.

    Override this in subclasses for customization.

    @private
    @param {Node} node
   */
  PropertyIndex.prototype.create = function create (node) {
    var values = node[this._property];
    if (!isArray(values)) {
      values = [values];
    }
    forEach(values, function(value) {
      this.index.set([value, node.id], node);
    }.bind(this));
  };

  /**
   * Called when a node has been deleted.
   *
   * Override this in subclasses for customization.
   *
   * @private
   * @param {model/data/Node} node
   */
  PropertyIndex.prototype.delete = function delete$1 (node) {
    var values = node[this._property];
    if (!isArray(values)) {
      values = [values];
    }
    forEach(values, function(value) {
      this.index.delete([value, node.id]);
    }.bind(this));
  };

  /**
    Called when a property has been updated.

    Override this in subclasses for customization.

    @private
    @param {Node} node
   */
  PropertyIndex.prototype.update = function update (node, path, newValue, oldValue) {
    if (!this.select(node) || path[1] !== this._property) { return }
    var values = oldValue;
    if (!isArray(values)) {
      values = [values];
    }
    forEach(values, function(value) {
      this.index.delete([value, node.id]);
    }.bind(this));
    values = newValue;
    if (!isArray(values)) {
      values = [values];
    }
    forEach(values, function(value) {
      this.index.set([value, node.id], node);
    }.bind(this));
  };

  PropertyIndex.prototype.set = function set (node, path, newValue, oldValue) {
    this.update(node, path, newValue, oldValue);
  };

  PropertyIndex.prototype._clear = function _clear () {
    this.index.clear();
  };

  PropertyIndex.prototype._initialize = function _initialize (data) {
    forEach(data.getNodes(), function(node) {
      if (this.select(node)) {
        this.create(node);
      }
    }.bind(this));
  };

  return PropertyIndex;
}(NodeIndex));

/*
  Index for Annotations.

  @example
  Lets us look up existing annotations by path and type

  To get all annotations for the content of a text node

    var aIndex = doc.annotationIndex
    aIndex.get(["text_1", "content"])

  You can also scope for a specific range

    aIndex.get(["text_1", "content"], 23, 45)
*/
var AnnotationIndex = (function (DocumentIndex$$1) {
  function AnnotationIndex() {
    DocumentIndex$$1.call(this);

    this.byPath = new TreeIndex();
    this.byType = new TreeIndex();
  }

  if ( DocumentIndex$$1 ) AnnotationIndex.__proto__ = DocumentIndex$$1;
  AnnotationIndex.prototype = Object.create( DocumentIndex$$1 && DocumentIndex$$1.prototype );
  AnnotationIndex.prototype.constructor = AnnotationIndex;

  AnnotationIndex.prototype.select = function select (node) {
    return Boolean(node._isPropertyAnnotation)
  };

  AnnotationIndex.prototype.reset = function reset (data) {
    this.byPath.clear();
    this.byType.clear();
    this._initialize(data);
  };

  // TODO: use object interface? so we can combine filters (path and type)
  AnnotationIndex.prototype.get = function get (path, start, end, type) {
    var annotations;
    if (isString(path) || path.length === 1) {
      annotations = this.byPath.getAll(path) || {};
    } else {
      annotations = this.byPath.get(path);
    }
    annotations = map(annotations);
    if (isNumber(start)) {
      annotations = filter(annotations, AnnotationIndex.filterByRange(start, end));
    }
    if (type) {
      annotations = filter(annotations, DocumentIndex$$1.filterByType(type));
    }
    return annotations
  };

  AnnotationIndex.prototype.create = function create (anno) {
    this.byType.set([anno.type, anno.id], anno);
    this.byPath.set(anno.start.path.concat([anno.id]), anno);
  };

  AnnotationIndex.prototype.delete = function delete$1 (anno) {
    this._delete(anno.type, anno.id, anno.start.path);
  };

  AnnotationIndex.prototype._delete = function _delete (type, id, path) {
    this.byType.delete([type, id]);
    this.byPath.delete(path.concat([id]));
  };

  AnnotationIndex.prototype.update = function update (node, path, newValue, oldValue) {
    // TODO: this should better be a coordinate op
    if (this.select(node) && path[1] === 'start' && path[2] === "path") {
      this._delete(node.type, node.id, oldValue);
      this.create(node);
    }
  };

  return AnnotationIndex;
}(DocumentIndex));

AnnotationIndex.filterByRange = function(start, end) {
  return function(anno) {
    var aStart = anno.start.offset;
    var aEnd = anno.end.offset;
    var overlap = (aEnd >= start);
    // Note: it is allowed to omit the end part
    if (isNumber(end)) {
      overlap = overlap && (aStart <= end);
    }
    return overlap
  }
};

var ContainerAnnotationIndex = (function (DocumentIndex$$1) {
  function ContainerAnnotationIndex() {
    DocumentIndex$$1.call(this);
    this.byId = new TreeIndex();
  }

  if ( DocumentIndex$$1 ) ContainerAnnotationIndex.__proto__ = DocumentIndex$$1;
  ContainerAnnotationIndex.prototype = Object.create( DocumentIndex$$1 && DocumentIndex$$1.prototype );
  ContainerAnnotationIndex.prototype.constructor = ContainerAnnotationIndex;

  ContainerAnnotationIndex.prototype.select = function select (node) {
    return Boolean(node._isContainerAnnotation)
  };

  ContainerAnnotationIndex.prototype.reset = function reset (data) {
    this.byId.clear();
    this._initialize(data);
  };

  ContainerAnnotationIndex.prototype.get = function get (containerId, type) {
    var annotations = map(this.byId.get(containerId));
    if (isString(type)) {
      annotations = filter(annotations, DocumentIndex$$1.filterByType);
    }
    return annotations
  };

  ContainerAnnotationIndex.prototype.create = function create (anno) {
    this.byId.set([anno.containerId, anno.id], anno);
  };

  ContainerAnnotationIndex.prototype.delete = function delete$1 (anno) {
    this.byId.delete([anno.containerId, anno.id]);
  };

  ContainerAnnotationIndex.prototype.update = function update (node, path, newValue, oldValue) { // eslint-disable-line
    // TODO should we support moving a container anno from one container to another?
  };

  return ContainerAnnotationIndex;
}(DocumentIndex));

var PathEventProxy = function PathEventProxy(doc) {
  this.listeners = new TreeIndex.Arrays();
  this._list = [];
  this.doc = doc;
};

PathEventProxy.prototype.on = function on (path, method, context) {
  this._add(context, path, method);
};

// proxy.off(this)
// proxy.off(this, path)
// proxy.off(this, path, this.onPropertyUpdate)
PathEventProxy.prototype.off = function off (context, path, method) {
  this._remove(context, path, method);
};

PathEventProxy.prototype.connect = function connect (listener, path, method) {
  console.warn('DEPRECATED: use proxy.on(path, this.onPropertyChange, this) instead');
  this.on(path, method, listener);
};

PathEventProxy.prototype.disconnect = function disconnect (listener) {
  console.warn('DEPRECATED: use proxy.off(this) instead');
  this.off(listener);
};

PathEventProxy.prototype.onDocumentChanged = function onDocumentChanged (change, info, doc) {
  // stop if no listeners registered
  if (this._list.length === 0) {
    return
  }
  var listeners = this.listeners;
  forEach(change.updated, function(_, pathStr) {
    var scopedListeners = listeners.get(pathStr.split(','));
    if (isArray(scopedListeners)) { scopedListeners = scopedListeners.slice(0); }
    forEach(scopedListeners, function(entry) {
      entry.method.call(entry.listener, change, info, doc);
    });
  });
};

PathEventProxy.prototype._add = function _add (listener, path, method) {
  if (!method) {
    throw new Error('Invalid argument: expected function but got ' + method)
  }
  var entry = { listener: listener, path: path, method: method };
  this.listeners.add(path, entry);
  this._list.push(entry);
};

PathEventProxy.prototype._remove = function _remove (listener, path, method) {
    var this$1 = this;

  for (var i = 0; i < this._list.length; i++) {
    var item = this$1._list[i];
    var match = (
      (!path || isEqual(item.path, path)) &&
      (!listener || item.listener === listener) &&
      (!method || item.method !== method)
    );
    if (match) {
      var entry = this$1._list[i];
      this$1._list.splice(i, 1);
      this$1.listeners.remove(entry.path, entry);
    }
  }
};

var NodeFactory = function NodeFactory(nodeRegistry) {
  this.nodeRegistry = nodeRegistry;
};

NodeFactory.prototype.create = function create (nodeType, nodeData) {
  var NodeClass = this.nodeRegistry.get(nodeType);
  if (!NodeClass) {
    throw new Error('No Node registered by that name: ' + nodeType)
  }
  return new NodeClass(nodeData)
};

/*
  A data storage implemention that supports data defined via a {@link Schema},
  and incremental updates which are backed by a OT library.

  It forms the underlying implementation for {@link Document}.
 */
var Data = (function (EventEmitter$$1) {
  function Data(schema, options) {
    EventEmitter$$1.call(this);

    options = options || {};
    this.schema = schema;
    this.nodes = {};
    this.indexes = {};
    this.options = options || {};

    this.nodeFactory = options.nodeFactory || new NodeFactory(schema.nodeRegistry);

    // Sometimes necessary to resolve issues with updating indexes in presence
    // of cyclic dependencies
    this.__QUEUE_INDEXING__ = false;
    this.queue = [];
  }

  if ( EventEmitter$$1 ) Data.__proto__ = EventEmitter$$1;
  Data.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Data.prototype.constructor = Data;

  /**
    Check if this storage contains a node with given id.

    @returns {bool} `true` if a node with id exists, `false` otherwise.
   */
  Data.prototype.contains = function contains (id) {
    return Boolean(this.nodes[id])
  };

  /**
    Get a node or value via path.

    @param {String|String[]} path node id or path to property.
    @returns {Node|Object|Primitive|undefined} a Node instance, a value or undefined if not found.
   */
  Data.prototype.get = function get (path, strict) {
    var result = this._get(path);
    if (strict && result === undefined) {
      if (isString(path)) {
        throw new Error("Could not find node with id '"+path+"'.")
      } else if (!this.contains(path[0])) {
        throw new Error("Could not find node with id '"+path[0]+"'.")
      } else {
        throw new Error("Property for path '"+path+"' us undefined.")
      }
    }
    return result
  };

  Data.prototype._get = function _get (path) {
    if (!path) { return undefined }
    var result;
    if (isString(path)) {
      result = this.nodes[path];
    } else if (path.length === 1) {
      result = this.nodes[path[0]];
    } else if (path.length > 1) {
      var context = this.nodes[path[0]];
      for (var i = 1; i < path.length-1; i++) {
        if (!context) { return undefined }
        context = context[path[i]];
      }
      if (!context) { return undefined }
      result = context[path[path.length-1]];
    }
    return result
  };

  /**
    Get the internal storage for nodes.

    @return The internal node storage.
   */
  Data.prototype.getNodes = function getNodes () {
    return this.nodes
  };

  /**
    Create a node from the given data.

    @return {Node} The created node.
   */
  Data.prototype.create = function create (nodeData) {
    var node = this.nodeFactory.create(nodeData.type, nodeData);
    if (!node) {
      throw new Error('Illegal argument: could not create node for data:', nodeData)
    }
    if (this.contains(node.id)) {
      throw new Error("Node already exists: " + node.id)
    }
    if (!node.id || !node.type) {
      throw new Error("Node id and type are mandatory.")
    }
    this.nodes[node.id] = node;

    var change = {
      type: 'create',
      node: node
    };

    if (this.__QUEUE_INDEXING__) {
      this.queue.push(change);
    } else {
      this._updateIndexes(change);
    }

    return node
  };

  /**
    Delete the node with given id.

    @param {String} nodeId
    @returns {Node} The deleted node.
   */
  Data.prototype.delete = function delete$1 (nodeId) {
    var node = this.nodes[nodeId];
    if (!node) { return }
    node.dispose();
    delete this.nodes[nodeId];

    var change = {
      type: 'delete',
      node: node,
    };

    if (this.__QUEUE_INDEXING__) {
      this.queue.push(change);
    } else {
      this._updateIndexes(change);
    }

    return node
  };

  /**
    Set a property to a new value.

    @param {Array} property path
    @param {Object} newValue
    @returns {Node} The deleted node.
   */
  Data.prototype.set = function set (path, newValue) {
    var node = this.get(path[0]);
    var oldValue = this._set(path, newValue);
    var change = {
      type: 'set',
      node: node,
      path: path,
      newValue: newValue,
      oldValue: oldValue
    };
    if (this.__QUEUE_INDEXING__) {
      this.queue.push(change);
    } else {
      this._updateIndexes(change);
    }
    return oldValue
  };

  Data.prototype._set = function _set (path, newValue) {
    var oldValue;
    if (path.length === 2) {
      oldValue = this.nodes[path[0]][path[1]];
      this.nodes[path[0]][path[1]] = newValue;
    } else if (path.length === 3) {
      oldValue = this.nodes[path[0]][path[1]][path[2]];
      this.nodes[path[0]][path[1]][path[2]] = newValue;
    } else {
      throw new Error('Path of length '+path.length+' not supported.')
    }
    return oldValue
  };

  /**
    Update a property incrementally.

    @param {Array} property path
    @param {Object} diff
    @returns {any} The value before applying the update.
  */
  Data.prototype.update = function update (path, diff) {
    var realPath = this.getRealPath(path);
    if (!realPath) {
      console.error('Could not resolve path', path);
      return
    }
    var node = this.get(realPath[0]);
    var oldValue = this._get(realPath);
    var newValue;
    if (diff.isOperation) {
      newValue = diff.apply(oldValue);
    } else {
      diff = this._normalizeDiff(oldValue, diff);
      if (isString(oldValue)) {
        switch (diff.type) {
          case 'delete': {
            newValue = oldValue.split('').splice(diff.start, diff.end-diff.start).join('');
            break
          }
          case 'insert': {
            newValue = [oldValue.substring(0, diff.start), diff.text, oldValue.substring(diff.start)].join('');
            break
          }
          default:
            throw new Error('Unknown diff type')
        }
      } else if (isArray(oldValue)) {
        newValue = oldValue.slice(0);
        switch (diff.type) {
          case 'delete': {
            newValue.splice(diff.pos, 1);
            break
          }
          case 'insert': {
            newValue.splice(diff.pos, 0, diff.value);
            break
          }
          default:
            throw new Error('Unknown diff type')
        }
      } else if (oldValue._isCoordinate) {
        switch (diff.type) {
          case 'shift': {
            // ATTENTION: in this case we do not want to create a new value
            oldValue = { path: oldValue.path, offset: oldValue.offset };
            newValue = oldValue;
            newValue.offset += diff.value;
            break
          }
          default:
            throw new Error('Unknown diff type')
        }
      } else {
        throw new Error('Diff is not supported:', JSON.stringify(diff))
      }
    }
    this._set(realPath, newValue);

    var change = {
      type: 'update',
      node: node,
      path: realPath,
      newValue: newValue,
      oldValue: oldValue
    };

    if (this.__QUEUE_INDEXING__) {
      this.queue.push(change);
    } else {
      this._updateIndexes(change);
    }

    return oldValue
  };

  // normalize to support legacy formats
  Data.prototype._normalizeDiff = function _normalizeDiff (value, diff) {
    if (isString(value)) {
      // legacy
      if (diff['delete']) {
        console.warn('DEPRECATED: use doc.update(path, {type:"delete", start:s, end: e}) instead');
        diff = {
          type: 'delete',
          start: diff['delete'].start,
          end: diff['delete'].end
        };
      } else if (diff['insert']) {
        console.warn('DEPRECATED: use doc.update(path, {type:"insert", start:s, text: t}) instead');
        diff = {
          type: 'insert',
          start: diff['insert'].offset,
          text: diff['insert'].value
        };
      }
    } else if (isArray(value)) {
      // legacy
      if (diff['delete']) {
        console.warn('DEPRECATED: use doc.update(path, {type:"delete", pos:1}) instead');
        diff = {
          type: 'delete',
          pos: diff['delete'].offset
        };
      } else if (diff['insert']) {
        console.warn('DEPRECATED: use doc.update(path, {type:"insert", pos:1, value: "foo"}) instead');
        diff = {
          type: 'insert',
          pos: diff['insert'].offset,
          value: diff['insert'].value
        };
      }
    } else if (value._isCoordinate) {
      if (diff.hasOwnProperty('shift')) {
        console.warn('DEPRECATED: use doc.update(path, {type:"shift", value:2}) instead');
        diff = {
          type: 'shift',
          value: diff['shift']
        };
      }
    }
    return diff
  };

  /*
    DEPRECATED: We moved away from having JSON as first-class exchange format.
    We will remove this soon.

    @internal
    @deprecated
   */
  Data.prototype.toJSON = function toJSON () {
    var nodes = {};
    forEach(this.nodes, function (node){
      nodes[node.id] = node.toJSON();
    });
    return {
      schema: [this.schema.id, this.schema.version],
      nodes: nodes
    }
  };

  /**
    Clear nodes.

    @internal
   */
  Data.prototype.reset = function reset () {
    this.nodes.clear();
  };

  /**
    Add a node index.

    @param {String} name
    @param {NodeIndex} index
   */
  Data.prototype.addIndex = function addIndex (name, index) {
    if (this.indexes[name]) {
      console.error('Index with name %s already exists.', name);
    }
    index.reset(this);
    this.indexes[name] = index;
    return index
  };

  /**
    Get the node index with given name.

    @param {String} name
    @returns {NodeIndex} The node index.
   */
  Data.prototype.getIndex = function getIndex (name) {
    return this.indexes[name]
  };

  /**
    Update a node index by providing of change object.

    @param {Object} change
   */
  Data.prototype._updateIndexes = function _updateIndexes (change) {
    if (!change || this.__QUEUE_INDEXING__) { return }
    forEach(this.indexes, function(index) {
      if (index.select(change.node)) {
        if (!index[change.type]) {
          console.error('Contract: every NodeIndex must implement ' + change.type);
        }
        index[change.type](change.node, change.path, change.newValue, change.oldValue);
      }
    });
  };

  /**
    Stops indexing process, all changes will be collected in indexing queue.

    @private
  */
  Data.prototype._stopIndexing = function _stopIndexing () {
    this.__QUEUE_INDEXING__ = true;
  };

  /**
    Update all index changes from indexing queue.

    @private
  */
  Data.prototype._startIndexing = function _startIndexing () {
    var this$1 = this;

    this.__QUEUE_INDEXING__ = false;
    while(this.queue.length >0) {
      var change = this$1.queue.shift();
      this$1._updateIndexes(change);
    }
  };

  return Data;
}(EventEmitter));

/**
  Incremental data storage implemention.

  @internal
 */
var IncrementalData = (function (Data$$1) {
  function IncrementalData () {
    Data$$1.apply(this, arguments);
  }

  if ( Data$$1 ) IncrementalData.__proto__ = Data$$1;
  IncrementalData.prototype = Object.create( Data$$1 && Data$$1.prototype );
  IncrementalData.prototype.constructor = IncrementalData;

  IncrementalData.prototype.create = function create (nodeData) {
    if (nodeData._isNode) {
      nodeData = nodeData.toJSON();
    }
    var op = ObjectOperation.Create([nodeData.id], nodeData);
    this.apply(op);
    return op
  };

  /**
    Delete a node.

    @param {String} nodeId
    @returns {ObjectOperation} The applied operation.
   */
  IncrementalData.prototype.delete = function delete$1 (nodeId) {
    var op = null;
    var node = this.get(nodeId);
    if (node) {
      var nodeData = node.toJSON();
      op = ObjectOperation.Delete([nodeId], nodeData);
      this.apply(op);
    }
    return op
  };

  /**
    Update a property incrementally.

    The diff can be of the following forms (depending on the updated property type):
      - String:
        - `{ insert: { offset: Number, value: Object } }`
        - `{ delete: { start: Number, end: Number } }`
      - Array:
        - `{ insert: { offset: Number, value: Object } }`
        - `{ delete: { offset: Number } }`

    @param {array} path
    @param {object} diff
    @returns {ObjectOperation} The applied operation.
  */
  IncrementalData.prototype.update = function update (path, diff) {
    var diffOp = this._getDiffOp(path, diff);
    var op = ObjectOperation.Update(path, diffOp);
    this.apply(op);
    return op
  };

  /**
    Set a property to a new value

    @param {Array} path
    @param {Object} newValue
    @returns {ObjectOperation} The applied operation.
   */
  IncrementalData.prototype.set = function set (path, newValue) {
    var oldValue = this.get(path);
    var op = ObjectOperation.Set(path, oldValue, newValue);
    this.apply(op);
    return op
  };

  /**
    Apply a given operation.

    @param {ObjectOperation} op
   */
  IncrementalData.prototype.apply = function apply (op) {
    if (op.type === ObjectOperation.NOP) { return }
    else if (op.type === ObjectOperation.CREATE) {
      // clone here as the operations value must not be changed
      Data$$1.prototype.create.call(this, cloneDeep(op.val));
    } else if (op.type === ObjectOperation.DELETE) {
      Data$$1.prototype.delete.call(this, op.val.id);
    } else if (op.type === ObjectOperation.UPDATE) {
      var oldVal = this.get(op.path);
      var diff = op.diff;
      if (op.propertyType === 'array') {
        if (! (diff._isArrayOperation) ) {
          diff = ArrayOperation.fromJSON(diff);
        }
        // array ops work inplace
        diff.apply(oldVal);
      } else if (op.propertyType === 'string') {
        if (!(diff._isTextOperation) ) {
          diff = TextOperation.fromJSON(diff);
        }
        var newVal = diff.apply(oldVal);
        Data$$1.prototype.set.call(this, op.path, newVal);
      } else if (op.propertyType === 'coordinate') {
        if (!(diff._isCoordinateOperation) ) {
          diff = CoordinateOperation.fromJSON(diff);
        }
        diff.apply(oldVal);
      } else {
        throw new Error("Unsupported type for operational update.")
      }
    } else if (op.type === ObjectOperation.SET) {
      Data$$1.prototype.set.call(this, op.path, op.val);
    } else {
      throw new Error("Illegal state.")
    }
    this.emit('operation:applied', op, this);
  };

  /**
    Creates proper operation based on provided node path and diff.

    @param {Array} path
    @param {Object} diff
    @returns {ObjectOperation} operation.
    @private
  */
  IncrementalData.prototype._getDiffOp = function _getDiffOp (path, diff) {
    var diffOp = null;
    if (diff.isOperation) {
      diffOp = diff;
    } else {
      var value = this.get(path);
      diff = this._normalizeDiff(value, diff);
      if (value === null || value === undefined) {
        throw new Error('Property has not been initialized: ' + JSON.stringify(path))
      } else if (isString(value)) {
        switch (diff.type) {
          case 'delete': {
            diffOp = TextOperation.Delete(diff.start, value.substring(diff.start, diff.end));
            break
          }
          case 'insert': {
            diffOp = TextOperation.Insert(diff.start, diff.text);
            break
          }
          default:
            throw new Error('Unknown diff type')
        }
      } else if (isArray(value)) {
        switch (diff.type) {
          case 'delete': {
            diffOp = ArrayOperation.Delete(diff.pos, value[diff.pos]);
            break
          }
          case 'insert': {
            diffOp = ArrayOperation.Insert(diff.pos, diff.value);
            break
          }
          default:
            throw new Error('Unknown diff type')
        }
      } else if (value._isCoordinate) {
        switch (diff.type) {
          case 'shift': {
            diffOp = CoordinateOperation.Shift(diff.value);
            break
          }
          default:
            throw new Error('Unknown diff type')
        }
      }
    }
    if (!diffOp) {
      throw new Error('Unsupported diff: ' + JSON.stringify(diff))
    }
    return diffOp
  };

  return IncrementalData;
}(Data));

var DocumentNodeFactory = function DocumentNodeFactory(doc) {
  this.doc = doc;
};

DocumentNodeFactory.prototype.create = function create (nodeType, nodeData) {
  var NodeClass = this.doc.schema.getNodeClass(nodeType);
  if (!NodeClass) {
    throw new Error('No node registered by that name: ' + nodeType)
  }
  return new NodeClass(this.doc, nodeData)
};

var Range = function Range(start, end, reverse, containerId, surfaceId) {
  // HACK: to allow this class be inherited but without calling this ctor
  if (arguments[0] === 'SKIP') { return }
  if (arguments.length === 1 && isPlainObject(arguments[0])) {
    var data = arguments[0];
    this.start = data.start;
    this.end = data.end;
    this.reverse = Boolean(data.reverse);
    this.containerId = data.containerId;
    this.surfaceId = data.surfaceId;
  } else {
    this.start = start;
    this.end = end;
    this.reverse = Boolean(reverse);
    this.containerId = containerId;
    this.surfaceId = surfaceId;
  }
};

Range.prototype.isCollapsed = function isCollapsed () {
  return this.start.equals(this.end)
};

Range.prototype.equals = function equals (other) {
  if (this === other) { return true }
  else {
    return (
      this.containerId === other.containerId &&
      this.start.equals(other.start) &&
      this.end.equals(other.end)
    )
  }
};

Range.prototype.isReverse = function isReverse () {
  return this.reverse
};

Range.prototype.toString = function toString () {
  var str = [this.start.toString(), '->', this.end.toString()];
  if (this.isReverse()) {
    str.push('[reverse]');
  }
  if (this.containerId) {
    str.push('[container='+this.containerId+']');
  }
  if (this.surfaceId) {
    str.push('[surface='+this.surfaceId+']');
  }
  return str.join('')
};

Range.prototype._isRange = true;

var JSONConverter = function JSONConverter () {};

JSONConverter.prototype.importDocument = function importDocument (doc, json) {
  if (!json.nodes) {
    throw new Error('Invalid JSON format.')
  }
  var schema = doc.getSchema();
  if (json.schema && schema.name !== json.schema.name) {
    throw new Error('Incompatible schema.')
  }
  // the json should just be an array of nodes
  var nodes = json.nodes;
  // import data in a block with deactivated indexers and listeners
  // as the data contains cyclic references which
  // cause problems.
  doc.import(function(tx) {
    forEach(nodes, function(node) {
      // overwrite existing nodes
      if (tx.get(node.id)) {
        tx.delete(node.id);
      }
      tx.create(node);
    });
  });
  return doc
};

JSONConverter.prototype.exportDocument = function exportDocument (doc) {
  var schema = doc.getSchema();
  var json = {
    schema: {
      name: schema.name
    },
    nodes: {}
  };
  forEach(doc.getNodes(), function(node) {
    if (node._isDocumentNode) {
      json.nodes[node.id] = node.toJSON();
    }
  });
  return json
};

/*
  This is an experiment trying to have better support for data types with a hierarchical
  nature, such as Lists, Tables etc.

  Our data model is inherently flat, and does not have any special support for hierarchical data types.
  The flat data model is essential for a simple OT implementation. Hierarchy is achieved by storing ids
  to reference child nodes.

  After longer discussions we agreed that we are very happy with the overlay nature
  of annotations, i.e., text is essentially modelled as plain text, and annotations are attached to it.
  This way we can map complex text manipulation to primitive object operations.
  For many other content types it would often be extremly helpful being able to traverse the structure in both
  directions, from parent to children (which is already possible), and back from children to parent.

  We do not want to store a the id of a parent node into the children, as this would be redundant, and would increase the amount of necessary operations.
  Instead we want to establish a link dynamically on the Node instance when the id is set in the parent (during construction or when updated).

  The most in-obstrusive implementation is to add an 'operation:applied' hook, watching for such changes
  and setting the reference. First we will apply this only for specific node types.
  Later this will be derived from the schema.
  With Texture we want to investigate a further option: replacing the node model with a DOM.
*/

var ParentNodeHook = function ParentNodeHook(doc) {
  this.doc = doc;
  this.table = {};
  doc.data.on('operation:applied', this._onOperationApplied, this);
};

ParentNodeHook.prototype._onOperationApplied = function _onOperationApplied (op) {
  var doc = this.doc;
  var table = this.table;
  var node = doc.get(op.path[0]);
  // TODO: instead of hard coding this here we should compile a matcher
  // based on the document schema
  switch(op.type) {
    case 'create': {
      switch (node.type) {
        case 'list':
          _setParent(node, node.items);
          break
        case 'list-item': {
          _setRegisteredParent(node);
          break
        }
        case 'table':
          _setParent(node, node.cells);
          break
        case 'table-cell': {
          _setRegisteredParent(node);
          break
        }
        default:
          //
      }
      break
    }
    case 'update': {
      // ATTENTION: we only set parents but don't remove when they are deleted
      // assuming that if the parent gets deleted, the children get deleted too
      var update = op.diff;
      switch(node.type) {
        case 'list':
          if (op.path[1] === 'items') {
            if (update.isInsert()) {
              _setParent(node, update.getValue());
            }
          }
          break
        case 'table':
          if (op.path[1] === 'cells') {
            if (update.isInsert()) {
              _setParent(node, update.getValue());
            }
          }
          break
        default:
          //
      }
      break
    }
    case 'set': {
      switch(node.type) {
        case 'list':
          if (op.path[1] === 'items') {
            _setParent(node, op.getValue());
          }
          break
        case 'table':
          if (op.path[1] === 'cells') {
            _setParent(node, op.getValue());
          }
          break
        default:
          //
      }
      break
    }
    default:
      //
  }

  function _setParent(parent, ids) {
    if (ids) {
      if (isArray(ids)) {
        ids.forEach(_set);
      } else {
        _set(ids);
      }
    }
    function _set(id) {
      // Note: it can happen, e.g. during deserialization, that the child node
      // is created later than the parent node
      // so we store the parent for later
      table[id] = parent;
      var child = doc.get(id);
      if (child) {
        child.parent = parent;
      }
    }
  }
  function _setRegisteredParent(child) {
    var parent = table[child.id];
    if (parent) {
      child.parent = parent;
    }
  }
};

ParentNodeHook.register = function(doc) {
  return new ParentNodeHook(doc)
};

// import AnchorIndex from './AnchorIndex'
var converter = new JSONConverter();

/**
  Basic implementation of a Document.

  @example

  ```js
  import { Document } from 'substance'

  class MyArticle extends Document {
    constructor(...args) {
      super(...args)

      this.addIndex('foo', FooIndex)
    }
  }
  ```
*/

var Document = (function (EventEmitter$$1) {
  function Document(schema) {
    EventEmitter$$1.call(this);

    // HACK: to be able to inherit but not execute this ctor
    if (arguments[0] === 'SKIP') { return }

    this.__id__ = uuid();

    if (!schema) {
      throw new Error('A document needs a schema for reflection.')
    }

    this.schema = schema;
    this.nodeFactory = new DocumentNodeFactory(this);
    this.data = new IncrementalData(schema, {
      nodeFactory: this.nodeFactory
    });

    // all by type
    this.addIndex('type', new PropertyIndex('type'));

    // special index for (property-scoped) annotations
    this.addIndex('annotations', new AnnotationIndex());

    // TODO: these are only necessary if there is a container annotation
    // in the schema
    // special index for (container-scoped) annotations
    this.addIndex('container-annotations', new ContainerAnnotationIndex());
    // this.addIndex('container-annotation-anchors', new AnchorIndex())

    // change event proxies are triggered after a document change has been applied
    // before the regular document:changed event is fired.
    // They serve the purpose of making the event notification more efficient
    // In earlier days all observers such as node views where listening on the same event 'operation:applied'.
    // This did not scale with increasing number of nodes, as on every operation all listeners where notified.
    // The proxies filter the document change by interest and then only notify a small set of observers.
    // Example: NotifyByPath notifies only observers which are interested in changes to a certain path.
    this.eventProxies = {
      'path': new PathEventProxy(this),
    };
    this.on('document:changed', this._updateEventProxies, this);
    // TODO: maybe we want to have a generalized concept for such low-level hooks
    // e.g. indexes are similar
    ParentNodeHook.register(this);
  }

  if ( EventEmitter$$1 ) Document.__proto__ = EventEmitter$$1;
  Document.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Document.prototype.constructor = Document;

  var prototypeAccessors = { id: {} };

  prototypeAccessors.id.get = function () {
    return this.__id__
  };

  /**
    @returns {model/DocumentSchema} the document's schema.
  */
  Document.prototype.getSchema = function getSchema () {
    return this.schema
  };

  /**
    Check if this storage contains a node with given id.

    @returns {Boolean} `true` if a node with id exists, `false` otherwise.
  */
  Document.prototype.contains = function contains (id) {
    return this.data.contains(id)
  };

  /**
    Get a node or value via path.

    @param {String|String[]} path node id or path to property.
    @returns {DocumentNode|any|undefined} a Node instance, a value or undefined if not found.
  */
  Document.prototype.get = function get (path, strict) {
    return this.data.get(path, strict)
  };

  /**
    @return {Object} A hash of {@link model/DocumentNode} instances.
  */
  Document.prototype.getNodes = function getNodes () {
    return this.data.getNodes()
  };

  /**
    Creates a context like a transaction for importing nodes.
    This is important in presence of cyclic dependencies.
    Indexes will not be updated during the import but will afterwards
    when all nodes are have been created.

    @private
    @param {Function} importer a `function(doc)`, where with `doc` is a `model/AbstractDocument`

    @example

    Consider the following example from our documentation generator:
    We want to have a member index, which keeps track of members of namespaces, modules, and classes.
    grouped by type, and in the case of classes, also grouped by 'instance' and 'class'.

    ```
    ui
      - class
        - ui/Component
    ui/Component
      - class
        - method
          - mount
      - instance
        - method
          - render
    ```

    To decide which grouping to apply, the parent type of a member needs to be considered.
    Using an incremental approach, this leads to the problem, that the parent must exist
    before the child. At the same time, e.g. when deserializing, the parent has already
    a field with all children ids. This cyclic dependency is best address, by turning
    off all listeners (such as indexes) until the data is consistent.

  */
  Document.prototype.import = function import$1 (importer) {
    try {
      this.data._stopIndexing();
      importer(this);
      this.data._startIndexing();
    } finally {
      this.data.queue = [];
      this.data._startIndexing();
    }
  };

  /**
    Create a node from the given data.

    @param {Object} plain node data.
    @return {DocumentNode} The created node.

    @example

    ```js
    doc.transaction(function(tx) {
      tx.create({
        id: 'p1',
        type: 'paragraph',
        content: 'Hi I am a Substance paragraph.'
      })
    })
    ```
  */
  Document.prototype.create = function create (nodeData) {
    if (!nodeData.id) {
      nodeData.id = uuid(nodeData.type);
    }
    var op = this._create(nodeData);
    var change = new DocumentChange([op], {}, {});
    change._extractInformation(this);
    this._notifyChangeListeners(change, { hidden: true });
    return this.data.get(nodeData.id)
  };

  /**
    Delete the node with given id.

    @param {String} nodeId
    @returns {DocumentNode} The deleted node.

    @example

    ```js
    doc.transaction(function(tx) {
      tx.delete('p1')
    })
    ```
  */
  Document.prototype.delete = function delete$1 (nodeId) {
    var node = this.get(nodeId);
    var op = this._delete(nodeId);
    var change = new DocumentChange([op], {}, {});
    change._extractInformation(this);
    this._notifyChangeListeners(change, { hidden: true });
    return node
  };

  /**
    Set a property to a new value.

    @param {String[]} property path
    @param {any} newValue
    @returns {DocumentNode} The deleted node.

    @example

    ```js
    doc.transaction(function(tx) {
      tx.set(['p1', 'content'], "Hello there! I'm a new paragraph.")
    })
    ```
  */
  Document.prototype.set = function set (path, value) {
    var oldValue = this.get(path);
    var op = this._set(path, value);
    var change = new DocumentChange([op], {}, {});
    change._extractInformation(this);
    this._notifyChangeListeners(change, { hidden: true });
    return oldValue
  };

  /**
    Update a property incrementally.

    @param {Array} property path
    @param {Object} diff
    @returns {any} The value before applying the update.

    @example


    Inserting text into a string property:
    ```
    doc.update(['p1', 'content'], { insert: {offset: 3, value: "fee"} })
    ```
    would turn "Foobar" into "Foofeebar".

    Deleting text from a string property:
    ```
    doc.update(['p1', 'content'], { delete: {start: 0, end: 3} })
    ```
    would turn "Foobar" into "bar".

    Inserting into an array:
    ```
    doc.update(['p1', 'content'], { insert: {offset: 2, value: 0} })
    ```
    would turn `[1,2,3,4]` into `[1,2,0,3,4]`.

    Deleting from an array:
    ```
    doc.update(['body', 'nodes'], { delete: 2 })
    ```
    would turn `[1,2,3,4]` into `[1,2,4]`.
  */
  Document.prototype.update = function update (path, diff) {
    var op = this._update(path, diff);
    var change = new DocumentChange([op], {}, {});
    change._extractInformation(this);
    this._notifyChangeListeners(change, { hidden: true });
    return op
  };

  /**
    Add a document index.

    @param {String} name
    @param {DocumentIndex} index
  */
  Document.prototype.addIndex = function addIndex (name, index) {
    return this.data.addIndex(name, index)
  };

  /**
    @param {String} name
    @returns {DocumentIndex} the node index with given name.
  */
  Document.prototype.getIndex = function getIndex (name) {
    return this.data.getIndex(name)
  };

  /**
    Creates a selection which is attached to this document.
    Every selection implementation provides its own
    parameter format which is basically a JSON representation.

    @param {model/Selection} sel An object describing the selection.

    @example

    Creating a PropertySelection:

    ```js
    doc.createSelection({
      type: 'property',
      path: [ 'text1', 'content'],
      startOffset: 10,
      endOffset: 20,
      containerId: 'body'
    })
    ```

    Creating a ContainerSelection:

    ```js
    doc.createSelection({
      type: 'container',
      containerId: 'body',
      startPath: [ 'p1', 'content'],
      startOffset: 10,
      endPath: [ 'p2', 'content'],
      endOffset: 20
    })
    ```

    Creating a NullSelection:

    ```js
    doc.createSelection(null)
    ```
  */
  Document.prototype.createSelection = function createSelection (data) {
    var sel;
    if (isNil(data)) { return Selection.nullSelection }
    if (arguments.length !== 1 || !isPlainObject(data)) {
      sel = _createSelectionLegacy(this, arguments);
    } else {
      switch (data.type) {
        case 'property': {
          if (isNil(data.endOffset)) {
            data.endOffset = data.startOffset;
          }
          if (!data.hasOwnProperty('reverse')) {
            if (data.startOffset>data.endOffset) {
              var assign;
              (assign = [data.endOffset, data.startOffset], data.startOffset = assign[0], data.endOffset = assign[1]);
              data.reverse = !data.reverse;
            }
          }
          // integrity checks:
          var text = this.get(data.path, 'strict');
          if (data.startOffset < 0 || data.startOffset > text.length) {
            throw new Error('Invalid startOffset: target property has length '+text.length+', given startOffset is ' + data.startOffset)
          }
          if (data.endOffset < 0 || data.endOffset > text.length) {
            throw new Error('Invalid startOffset: target property has length '+text.length+', given endOffset is ' + data.endOffset)
          }
          sel = new PropertySelection(data);
          break
        }
        case 'container': {
          var container = this.get(data.containerId, 'strict');
          if (!container) { throw new Error('Can not create ContainerSelection: container "'+data.containerId+'" does not exist.') }
          var start = this._normalizeCoor({ path: data.startPath, offset: data.startOffset});
          var end = this._normalizeCoor({ path: data.endPath, offset: data.endOffset});
          var startAddress = container.getAddress(start);
          var endAddress = container.getAddress(end);
          if (!startAddress) {
            throw new Error('Invalid arguments for ContainerSelection: ', start.toString())
          }
          if (!endAddress) {
            throw new Error('Invalid arguments for ContainerSelection: ', end.toString())
          }
          if (!data.hasOwnProperty('reverse')) {
            if (endAddress.isBefore(startAddress, 'strict')) {
              var assign$1;
              (assign$1 = [end, start], start = assign$1[0], end = assign$1[1]);
              data.reverse = true;
            }
          }
          sel = new ContainerSelection(container.id, start.path, start.offset, end.path, end.offset, data.reverse, data.surfaceId);
          break
        }
        case 'node': {
          sel = createNodeSelection({
            doc: this,
            nodeId: data.nodeId,
            mode: data.mode,
            containerId: data.containerId,
            reverse: data.reverse,
            surfaceId: data.surfaceId
          });
          break
        }
        case 'custom': {
          sel = CustomSelection.fromJSON(data);
          break
        }
        default:
          throw new Error('Illegal selection type', data)
      }
    }
    if (!sel.isNull()) {
      sel.attach(this);
    }
    return sel
  };

  Document.prototype.getEventProxy = function getEventProxy (name) {
    return this.eventProxies[name]
  };

  Document.prototype.newInstance = function newInstance () {
    var DocumentClass = this.constructor;
    return new DocumentClass(this.schema)
  };

  // useful in combination with paste transformation
  Document.prototype.createSnippet = function createSnippet () {
    var snippet = this.newInstance();
    var snippetContainer = snippet.create({
      type: 'container',
      id: Document.SNIPPET_ID
    });
    snippet.getContainer = function() {
      return snippetContainer
    };
    snippet.show = function() {
      snippetContainer.show.apply(snippetContainer, arguments);
    };
    return snippet
  };

  Document.prototype.fromSnapshot = function fromSnapshot (data) {
    var doc = this.newInstance();
    doc.loadSeed(data);
    return doc
  };

  Document.prototype.getDocumentMeta = function getDocumentMeta () {
    return this.get('document')
  };

  Document.prototype._apply = function _apply (documentChange) {
    forEach(documentChange.ops, function(op) {
      this.data.apply(op);
      this.emit('operation:applied', op);
    }.bind(this));
    // extract aggregated information, such as which property has been affected etc.
    documentChange._extractInformation(this);
  };

  Document.prototype._notifyChangeListeners = function _notifyChangeListeners (change, info) {
    info = info || {};
    this.emit('document:changed', change, info, this);
  };

  Document.prototype._updateEventProxies = function _updateEventProxies (change, info) {
    forEach(this.eventProxies, function(proxy) {
      proxy.onDocumentChanged(change, info, this);
    }.bind(this));
  };

  /**
   * DEPRECATED: We will drop support as this should be done in a more
   *             controlled fashion using an importer.
   * @skip
   */
  Document.prototype.loadSeed = function loadSeed (seed) {
    // clear all existing nodes (as they should be there in the seed)
    forEach(this.data.nodes, function(node) {
      this.delete(node.id);
    }.bind(this));
    // create nodes
    forEach(seed.nodes, function(nodeData) {
      this.create(nodeData);
    }.bind(this));
  };

  /**
    Convert to JSON.

    @returns {Object} Plain content.
  */
  Document.prototype.toJSON = function toJSON () {
    return converter.exportDocument(this)
  };

  Document.prototype.getTextForSelection = function getTextForSelection (sel) {
    console.warn('DEPRECATED: use documentHelpers.getTextForSelection() instead.');
    return documentHelpers.getTextForSelection(this, sel)
  };

  Document.prototype.setText = function setText (path, text, annotations) {
    var this$1 = this;

    // TODO: this should go into document helpers.
    var idx;
    var oldAnnos = this.getIndex('annotations').get(path);
    // TODO: what to do with container annotations
    for (idx = 0; idx < oldAnnos.length; idx++) {
      this$1.delete(oldAnnos[idx].id);
    }
    this.set(path, text);
    for (idx = 0; idx < annotations.length; idx++) {
      this$1.create(annotations[idx]);
    }
  };

  Document.prototype.getAnnotations = function getAnnotations (path) {
    return this.getIndex('annotations').get(path)
  };

  Document.prototype._create = function _create (nodeData) {
    var op = this.data.create(nodeData);
    return op
  };

  Document.prototype._delete = function _delete (nodeId) {
    var op = this.data.delete(nodeId);
    return op
  };

  Document.prototype._update = function _update (path, diff) {
    var op = this.data.update(path, diff);
    return op
  };

  Document.prototype._set = function _set (path, value) {
    var op = this.data.set(path, value);
    return op
  };

  // NOTE: this is still here because DOMSelection is using it
  Document.prototype._createSelectionFromRange = function _createSelectionFromRange (range) {
    if (!range) { return Selection.nullSelection }
    var inOneNode = isEqual(range.start.path, range.end.path);
    if (inOneNode) {
      if (range.start.isNodeCoordinate()) {
        // ATTENTION: we only create full NodeSelections
        // when mapping from the DOM to Model  return new NodeSelection(range.containerId, range.start.getNodeId(), mode, range.reverse, range.surfaceId)
        return new NodeSelection(range.containerId, range.start.getNodeId(), 'full', range.reverse, range.surfaceId)
      } else {
        return this.createSelection({
          type: 'property',
          path: range.start.path,
          startOffset: range.start.offset,
          endOffset: range.end.offset,
          reverse: range.reverse,
          containerId: range.containerId,
          surfaceId: range.surfaceId
        })
      }
    } else {
      return this.createSelection({
        type: 'container',
        startPath: range.start.path,
        startOffset: range.start.offset,
        endPath: range.end.path,
        endOffset: range.end.offset,
        reverse: range.reverse,
        containerId: range.containerId,
        surfaceId: range.surfaceId
      })
    }
  };

  Document.prototype._normalizeCoor = function _normalizeCoor (ref) {
    var path = ref.path;
    var offset = ref.offset;

    // NOTE: normalizing so that a node coordinate is used only for 'isolated nodes'
    if (path.length === 1) {
      var node = this.get(path[0]).getRoot();
      if (node.isText()) {
        // console.warn("DEPRECATED: don't use node coordinates for TextNodes. Use selectionHelpers instead to set cursor at first or last position conveniently.")
        return new Coordinate(node.getTextPath(), offset === 0 ? 0 : node.getLength())
      } else if (node.isList()) {
        // console.warn("DEPRECATED: don't use node coordinates for ListNodes. Use selectionHelpers instead to set cursor at first or last position conveniently.")
        if (offset === 0) {
          var item = node.getItemAt(0);
          return new Coordinate(item.getTextPath(), 0)
        } else {
          var item$1 = this.get(last$2(node.items));
          return new Coordinate(item$1.getTextPath(), item$1.getLength())
        }
      }
    }
    return new Coordinate(path, offset)
  };

  Object.defineProperties( Document.prototype, prototypeAccessors );

  return Document;
}(EventEmitter));

Document.prototype._isDocument = true;

// used by transforms copy, paste
// and by ClipboardImporter/Exporter
Document.SNIPPET_ID = "snippet";

Document.TEXT_SNIPPET_ID = "text-snippet";


/* Internals */

// DEPRECATED legacy support
function _createSelectionLegacy(doc, args) {
  console.warn('DEPRECATED: use document.createSelection({ type: ... }) instead');
  // createSelection(coor)
  if (args[0] instanceof Coordinate) {
    var coor = args[0];
    if (coor.isNodeCoordinate()) {
      return NodeSelection._createFromCoordinate(coor)
    } else {
      return doc.createSelection({
        type: 'property',
        path: coor.path,
        startOffset: coor.offset,
      })
    }
  }
  // createSelection(range)
  else if (args[0] instanceof Range) {
    return doc._createSelectionFromRange(args[0])
  }
  // createSelection(startPath, startOffset)
  else if (args.length === 2 && isArray(args[0])) {
    return doc.createSelection({
      type: 'property',
      path: args[0],
      startOffset: args[1]
    })
  }
  // createSelection(startPath, startOffset, endOffset)
  else if (args.length === 3 && isArray(args[0])) {
    return doc.createSelection({
      type: 'property',
      path: args[0],
      startOffset: args[1],
      endOffset: args[2]
    })
  }
  // createSelection(containerId, startPath, startOffset, endPath, endOffset)
  else if (args.length === 5 && isString(args[0])) {
    return doc.createSelection({
      type: 'container',
      containerId: args[0],
      startPath: args[1],
      startOffset: args[2],
      endPath: args[3],
      endOffset: args[4]
    })
  } else {
    console.error('Illegal arguments for document.createSelection().', args);
    return doc.createSelection(null)
  }
}

/**
  A {@link Document} instance that is used during transaction.

  During editing a TransactionDocument is kept up-to-date with the real one.
  Whenever a transaction is started on the document, a TransactionDocument is used to
  record changes, which are applied en-bloc when the transaction is saved.

  The transaction document is the common way to manipulate the document.
  It provides a 'turtle-graphics' style API, i.e., it has a state

  @example

  To start a transaction run

  ```
  doc.transaction(function(tx) {
    // use tx to record changes
  })
  ```
*/
var TransactionDocument = (function (Document$$1) {
  function TransactionDocument(document) {
    Document$$1.call(this, 'SKIP');

    this.schema = document.schema;
    this.nodeFactory = new DocumentNodeFactory(this);
    this.data = new IncrementalData(this.schema, {
      nodeFactory: this.nodeFactory
    });

    this.document = document;

    // ops recorded since transaction start
    this.ops = [];
    this.lastOp = null;

    // copy all indexes
    forEach(document.data.indexes, function(index, name) {
      this.data.addIndex(name, index.clone());
    }.bind(this));

    // ATTENTION: this must before loading the seed
    ParentNodeHook.register(this);

    this.loadSeed(document.toJSON());

    // make sure that we mirror all changes that are done outside of transactions
    document.on('document:changed', this._onDocumentChanged, this);
  }

  if ( Document$$1 ) TransactionDocument.__proto__ = Document$$1;
  TransactionDocument.prototype = Object.create( Document$$1 && Document$$1.prototype );
  TransactionDocument.prototype.constructor = TransactionDocument;

  TransactionDocument.prototype.dispose = function dispose () {
    this.document.off(this);
  };

  TransactionDocument.prototype.create = function create (nodeData) {
    if (!nodeData.id) {
      nodeData.id = uuid(nodeData.type);
    }
    if (!nodeData.type) {
      throw new Error('No node type provided')
    }
    this.lastOp = this.data.create(nodeData);
    if (this.lastOp) {
      this.ops.push(this.lastOp);
      return this.data.get(nodeData.id)
    }
  };

  TransactionDocument.prototype.createDefaultTextNode = function createDefaultTextNode (text, dir) {
    return this.create({
      type: this.getSchema().getDefaultTextType(),
      content: text || '',
      direction: dir
    })
  };

  TransactionDocument.prototype.delete = function delete$1 (nodeId) {
    this.lastOp = this.data.delete(nodeId);
    if (this.lastOp) {
      this.ops.push(this.lastOp);
    }
  };

  TransactionDocument.prototype.set = function set (path, value) {
    this.lastOp = this.data.set(path, value);
    if (this.lastOp) {
      this.ops.push(this.lastOp);
    }
  };

  TransactionDocument.prototype.update = function update (path, diffOp) {
    var op = this.lastOp = this.data.update(path, diffOp);
    if (op) {
      this.ops.push(op);
      return op
    }
  };

  TransactionDocument.prototype._onDocumentChanged = function _onDocumentChanged (change) {
    // NOTE: this is hooked to document:changed (low-level), to make sure that we
    // update the transaction document too when the document is manipulated directly, e.g. using `document.create(...)`
    this._apply(change);
  };

  TransactionDocument.prototype._apply = function _apply (documentChange) {
    documentChange.ops.forEach(function(op) {
      this.data.apply(op);
    }.bind(this));
  };

  TransactionDocument.prototype._reset = function _reset () {
    this.ops = [];
    this.lastOp = null;
  };

  TransactionDocument.prototype._rollback = function _rollback () {
    var this$1 = this;

    for (var i = this.ops.length - 1; i >= 0; i--) {
      this$1.data.apply(this$1.ops[i].invert());
    }
    this.ops = [];
    this.lastOp = null;
  };

  TransactionDocument.prototype.newInstance = function newInstance () {
    return this.document.newInstance()
  };

  return TransactionDocument;
}(Document));

TransactionDocument.prototype._isTransactionDocument = true;

/**
  Creates a new document instance containing only the selected content

  @param {Object} args object with `selection`
  @return {Object} with a `doc` property that has a fresh doc with the copied content
*/

function copySelection(doc, selection) {
  if (!selection) { throw new Error("'selection' is mandatory.") }
  var copy = null;
  if (!selection.isNull() && !selection.isCollapsed()) {
    // return a simplified version if only a piece of text is selected
    if (selection.isPropertySelection()) {
      copy = _copyPropertySelection(doc, selection);
    }
    else if (selection.isContainerSelection()) {
      copy = _copyContainerSelection(doc, selection);
    }
    else if (selection.isNodeSelection()) {
      copy = _copyNodeSelection(doc, selection);
    }
    else {
      console.error('Copy is not yet supported for selection type.');
    }
  }
  return copy
}

function _copyPropertySelection(doc, selection) {
  var path = selection.start.path;
  var offset = selection.start.offset;
  var endOffset = selection.end.offset;
  var text = doc.get(path);
  var snippet = doc.createSnippet();
  var containerNode = snippet.getContainer();
  snippet.create({
    type: doc.schema.getDefaultTextType(),
    id: Document.TEXT_SNIPPET_ID,
    content: text.substring(offset, endOffset)
  });
  containerNode.show(Document.TEXT_SNIPPET_ID);
  var annotations = doc.getIndex('annotations').get(path, offset, endOffset);
  forEach(annotations, function(anno) {
    var data = cloneDeep(anno.toJSON());
    var path = [Document.TEXT_SNIPPET_ID, 'content'];
    data.start = {
      path: path,
      offset: Math.max(offset, anno.start.offset)-offset
    };
    data.end = {
      path: path,
      offset: Math.min(endOffset, anno.end.offset)-offset
    };
    snippet.create(data);
  });
  return snippet
}

function _copyContainerSelection(tx, sel) {
  var snippet = tx.createSnippet();
  var container = snippet.getContainer();

  var nodeIds = sel.getNodeIds();
  var L = nodeIds.length;
  if (L === 0) { return snippet }

  var start = sel.start;
  var end = sel.end;

  var skippedFirst = false;
  var skippedLast = false;

  // First copy the whole covered nodes
  var created = {};
  for(var i = 0; i<L; i++) {
    var id = nodeIds[i];
    var node = tx.get(id);
    // skip NIL selections, such as cursor at the end of first node or cursor at the start of last node.
    if (i===0 && isLast(tx, start)) {
      skippedFirst = true;
      continue
    }
    if (i===L-1 && isFirst(tx, end)) {
      skippedLast = true;
      continue
    }
    if (!created[id]) {
      documentHelpers.copyNode(node).forEach(function (nodeData) {
        var copy = snippet.create(nodeData);
        created[copy.id] = true;
      });
      container.show(id);
    }
  }
  if (!skippedFirst) {
    // ATTENTION: we need the root node here, e.g. the list, not the list items
    var startNode = snippet.get(start.getNodeId()).getRoot();
    if (startNode.isText()) {
      documentHelpers.deleteTextRange(snippet, null, start);
    } else if (startNode.isList()) {
      documentHelpers.deleteListRange(snippet, startNode, null, start);
    }
  }
  if (!skippedLast) {
    // ATTENTION: we need the root node here, e.g. the list, not the list items
    var endNode = snippet.get(end.getNodeId()).getRoot();
    if (endNode.isText()) {
      documentHelpers.deleteTextRange(snippet, end, null);
    } else if (endNode.isList()) {
      documentHelpers.deleteListRange(snippet, endNode, end, null);
    }
  }
  return snippet
}

function _copyNodeSelection(doc, selection) {
  var snippet = doc.createSnippet();
  var containerNode = snippet.getContainer();
  var nodeId = selection.getNodeId();
  var node = doc.get(nodeId);
  documentHelpers.copyNode(node).forEach(function (nodeData) {
    snippet.create(nodeData);
  });
  containerNode.show(node.id);
  return snippet
}

/**
  Pastes clipboard content at the current selection

  @param {Object} args object with `selection` and `doc` for Substance content or
  `text` for external HTML content
  @return {Object} with updated `selection`
*/

function paste(tx, args) {
  var sel = tx.selection;
  if (!sel || sel.isNull()) {
    throw new Error("Can not paste, without selection.")
  }
  args = args || {};
  args.text = args.text || '';
  var pasteDoc = args.doc;
  // TODO: is there a better way to detect that this paste is happening within a
  // container?
  var inContainer = Boolean(sel.containerId);

  // when we are in a container, we interpret line-breaks
  // and create a document with multiple paragraphs
  // in a PropertyEditor we paste the text as is
  if (!pasteDoc && !inContainer) {
    tx.insertText(args.text);
    return
  }
  if (!pasteDoc) {
    pasteDoc = _convertPlainTextToDocument(tx, args);
  }
  if (!sel.isCollapsed()) {
    tx.deleteSelection();
  }
  var nodes = pasteDoc.get(Document.SNIPPET_ID).nodes;
  var schema = tx.getSchema();
  if (nodes.length > 0) {
    var first = pasteDoc.get(nodes[0]);
    if (schema.isInstanceOf(first.type, 'text')) {
      _pasteAnnotatedText(tx, pasteDoc);
      // HACK: this changes the container's nodes array.
      // We do this, to be able to call _pasteDocument inserting the remaining nodes
      nodes.shift();
    }
    // if still nodes left > 0
    if (nodes.length > 0) {
      _pasteDocument(tx, pasteDoc);
    }
  }
  return args
}

/*
  Splits plain text by lines and puts them into paragraphs.
*/
function _convertPlainTextToDocument(tx, args) {
  var lines = args.text.split(/\s*\n\s*\n/);
  var pasteDoc = tx.getDocument().newInstance();
  var defaultTextType = pasteDoc.getSchema().getDefaultTextType();
  var container = pasteDoc.create({
    type: 'container',
    id: Document.SNIPPET_ID,
    nodes: []
  });
  var node;
  if (lines.length === 1) {
    node = pasteDoc.create({
      id: Document.TEXT_SNIPPET_ID,
      type: defaultTextType,
      content: lines[0]
    });
    container.show(node.id);
  } else {
    for (var i = 0; i < lines.length; i++) {
      node = pasteDoc.create({
        id: uuid(defaultTextType),
        type: defaultTextType,
        content: lines[i]
      });
      container.show(node.id);
    }
  }
  return pasteDoc
}

function _pasteAnnotatedText(tx, copy) {
  var sel = tx.selection;
  var nodes = copy.get(Document.SNIPPET_ID).nodes;
  var textPath = [nodes[0], 'content'];
  var text = copy.get(textPath);
  var annotations = copy.getIndex('annotations').get(textPath);
  // insert plain text
  var path = sel.start.path;
  var offset = sel.start.offset;
  tx.insertText(text);
  // copy annotations
  forEach(annotations, function(anno) {
    var data = anno.toJSON();
    data.start.path = path.slice(0);
    data.start.offset += offset;
    data.end.offset += offset;
    // create a new uuid if a node with the same id exists already
    if (tx.get(data.id)) { data.id = uuid(data.type); }
    tx.create(data);
  });
}

function _pasteDocument(tx, pasteDoc) {
  var sel = tx.selection;
  var containerId = sel.containerId;
  var container = tx.get(containerId);
  var insertPos;
  if (sel.isPropertySelection()) {
    var startPath = sel.start.path;
    var nodeId = sel.start.getNodeId();
    var startPos = container.getPosition(nodeId, 'strict');
    var text = tx.get(startPath);
    // Break, unless we are at the last character of a node,
    // then we can simply insert after the node
    if (text.length === 0) {
      insertPos = startPos;
      container.hide(nodeId);
      documentHelpers.deleteNode(tx, tx.get(nodeId));
    } else if ( text.length === sel.start.offset ) {
      insertPos = startPos + 1;
    } else {
      tx.break();
      insertPos = startPos + 1;
    }
  } else if (sel.isNodeSelection()) {
    var nodePos = container.getPosition(sel.getNodeId(), 'strict');
    if (sel.isBefore()) {
      insertPos = nodePos;
    } else if (sel.isAfter()) {
      insertPos = nodePos+1;
    } else {
      throw new Error('Illegal state: the selection should be collapsed.')
    }
  }
  // transfer nodes from content document
  var nodeIds = pasteDoc.get(Document.SNIPPET_ID).nodes;
  var insertedNodes = [];
  var visited = {};
  for (var i = 0; i < nodeIds.length; i++) {
    var node = pasteDoc.get(nodeIds[i]);
    // Note: this will on the one hand make sure
    // node ids are changed to avoid collisions in
    // the target doc
    // Plus, it uses reflection to create owned nodes recursively,
    // and to transfer attached annotations.
    var newId = _transferWithDisambiguatedIds(node.getDocument(), tx, node.id, visited);
    // get the node in the targetDocument
    node = tx.get(newId);
    container.show(newId, insertPos++);
    insertedNodes.push(node);
  }

  if (insertedNodes.length > 0) {
    var lastNode = last$2(insertedNodes);
    setCursor(tx, lastNode, containerId, 'after');
  }
}

// We need to disambiguate ids if the target document
// contains a node with the same id.
// Unfortunately, this can be difficult in some cases,
// e.g. other nodes that have a reference to the re-named node
// We only fix annotations for now.
function _transferWithDisambiguatedIds(sourceDoc, targetDoc, id, visited) {
  if (visited[id]) { throw new Error('FIXME: dont call me twice') }
  var node = sourceDoc.get(id, 'strict');
  var oldId = node.id;
  var newId;
  if (targetDoc.contains(node.id)) {
    // change the node id
    newId = uuid(node.type);
    node.id = newId;
  }
  visited[id] = node.id;
  var annotationIndex = sourceDoc.getIndex('annotations');
  var nodeSchema = node.getSchema();
  // collect annotations so that we can create them in the target doc afterwards
  var annos = [];
  // now we iterate all properties of the node schema,
  // to see if there are owned references, which need to be created recursively,
  // and if there are text properties, where annotations could be attached to
  for (var key in nodeSchema) {
    if (key === 'id' || key === 'type' || !nodeSchema.hasOwnProperty(key)) { continue }
    var prop = nodeSchema[key];
    var name = prop.name;
    // Look for references to owned children and create recursively
    if ((prop.isReference() && prop.isOwned()) || (prop.type === 'file')) {
      // NOTE: we need to recurse directly here, so that we can
      // update renamed references
      var val = node[prop.name];
      if (prop.isArray()) {
        _transferArrayOfReferences(sourceDoc, targetDoc, val, visited);
      } else {
        var id$1 = val;
        if (!visited[id$1]) {
          node[name] = _transferWithDisambiguatedIds(sourceDoc, targetDoc, id$1, visited);
        }
      }
    }
    // Look for text properties and create annotations in the target doc accordingly
    else if (prop.isText()) {
      var _annos = annotationIndex.get([node.id]);
      for (var i = 0; i < _annos.length; i++) {
        var anno = _annos[i];
        if (anno.start.path[0] === oldId) {
          anno.start.path[0] = newId;
        }
        if (anno.end.path[0] === oldId) {
          anno.end.path[0] = newId;
        }
        annos.push(anno);
      }
    }
  }
  targetDoc.create(node);
  for (var i$1 = 0; i$1 < annos.length; i$1++) {
    _transferWithDisambiguatedIds(sourceDoc, targetDoc, annos[i$1].id, visited);
  }
  return node.id
}

function _transferArrayOfReferences(sourceDoc, targetDoc, arr, visited) {
  for (var i = 0; i < arr.length; i++) {
    var val = arr[i];
    // multi-dimensional
    if (isArray(val)) {
      _transferArrayOfReferences(sourceDoc, targetDoc, val, visited);
    } else {
      var id = val;
      if (id && !visited[id]) {
        arr[i] = _transferWithDisambiguatedIds(sourceDoc, targetDoc, id, visited);
      }
    }
  }
}

/**
  Core editing implementation, that controls meta behavior
  such as deleting a selection, merging nodes, etc.

  Some of the implementation are then delegated to specific editing behaviors,
  such as manipulating content of a text-property, merging or breaking text nodes

  Note: this is pretty much the same what we did with transforms before.
        We decided to move this here, to switch to a stateful editor implementation (aka turtle-graphics-style)
 */
var Editing = function Editing () {};

Editing.prototype.annotate = function annotate (tx, annotation) {
  var sel = tx.selection;
  if (!sel || sel.isNull() || sel.isCollapsed()) {
    throw new Error('Non-collapsed selection required for tx.annotate()')
  }
  if (sel.isCollapsed()) { return }
  var schema = tx.getSchema();
  var AnnotationClass = schema.getNodeClass(annotation.type);
  if (!AnnotationClass) { throw new Error('Unknown annotation type', annotation) }
  if (sel.isNodeSelection()) {
    throw new Error('Node selections are not supported by tx.annotate()')
  } else if (sel.isCustomSelection()) {
    throw new Error('Custom selections are not supported by tx.annotate()')
  }
  var start = sel.start;
  var end = sel.end;
  var containerId = sel.containerId;
  var nodeData = { start: start, end: end, containerId: containerId };
  if (sel.isPropertySelection()) {
    if (!AnnotationClass.prototype._isAnnotation) {
      throw new Error('Annotation can not be created for a selection.')
    }
  } else if (sel.isContainerSelection()) {
    if (AnnotationClass.prototype._isPropertyAnnotation) {
      console.warn('NOT SUPPORTED YET: creating property annotations for a non collapsed container selection.');
    }
  } else {
    throw new Error('Unsupported selection.')
  }
  Object.assign(nodeData, annotation);
  return tx.create(nodeData)
};

Editing.prototype.break = function break$1 (tx) {
  var sel = tx.selection;
  if (sel.isNodeSelection()) {
    var containerId = sel.containerId;
    var container = tx.get(containerId);
    var nodeId = sel.getNodeId();
    var nodePos = container.getPosition(nodeId, 'strict');
    var textNode = tx.createDefaultTextNode();
    if (sel.isBefore()) {
      tx.update(container.getContentPath(), { type: 'insert', pos: nodePos, value: textNode.id });
      // leave selection as is
    } else {
      tx.update(container.getContentPath(), { type: 'insert', pos: nodePos+1, value: textNode.id });
      setCursor(tx, textNode, containerId, 'before');
    }
  }
  else if (sel.isCustomSelection()) {
    // TODO: what to do with custom selections?
  }
  else if (sel.isCollapsed() || sel.isPropertySelection()) {
    var containerId$1 = sel.containerId;
    if (!sel.isCollapsed()) {
      // delete the selection
      this.deletePropertySelection(tx, sel);
      tx.setSelection(sel.collapse('left'));
    }
    // then break the node
    if (containerId$1) {
      var container$1 = tx.get(containerId$1);
      var nodeId$1 = sel.start.path[0];
      var node = tx.get(nodeId$1);
      this._breakNode(tx, node, sel.start, container$1);
    } else {
      this.insertText(tx, '\n');
    }
  }
  else if (sel.isContainerSelection()) {
    if (sel.start.hasSamePath(sel.end)) {
      this.deleteContainerSelection(tx, sel);
      this.break(tx);
    } else {
      var start = sel.start;
      var containerId$2 = sel.containerId;
      var container$2 = tx.get(containerId$2);
      var startNodeId = start.path[0];
      var nodePos$1 = container$2.getPosition(startNodeId, 'strict');
      this.deleteContainerSelection(tx, sel);
      if (nodePos$1 < container$2.length-1) {
        setCursor(tx, container$2.getNodeAt(nodePos$1+1), containerId$2, 'before');
      } else {
        tx.setSelection(sel.collapse('left'));
        this.break(tx);
      }
    }
  }
};

Editing.prototype.delete = function delete$1 (tx, direction) {
  var sel = tx.selection;
  // special implementation for node selections:
  // either delete the node (replacing with an empty text node)
  // or just move the cursor
  if (sel.isNodeSelection()) {
    this.deleteNodeSelection(tx, sel, direction);
  }
  // TODO: what to do with custom selections?
  else if (sel.isCustomSelection()) {}
  // if the selection is collapsed this is the classical one-character deletion
  // either backwards (backspace) or forward (delete)
  else if (sel.isCollapsed()) {
    // Deletion of a single character leads to a merge
    // if cursor is at a text boundary (TextNode, ListItem)
    // and direction is towards that boundary
    var path = sel.start.path;
    var node = tx.get(path[0]);
    var text = tx.get(path);
    var offset = sel.start.offset;
    var needsMerge = (sel.containerId && (
      (offset === 0 && direction === 'left') ||
      (offset === text.length && direction === 'right')
    ));
    if (needsMerge) {
      // ATTENTION: deviation from standard implementation
      // for list items: Word and GDoc toggle a list item
      // when doing a BACKSPACE at the first position
      var root = node.getRoot();
      if (root.isList() && offset === 0 && direction === 'left') {
        return this.toggleList(tx)
      } else {
        var container = tx.get(sel.containerId);
        this._merge(tx, root, sel.start, direction, container);
      }
    } else {
      var startOffset = (direction === 'left') ? offset-1 : offset;
      var endOffset = startOffset+1;
      var start = { path: path, offset: startOffset };
      var end = { path: path, offset: endOffset };
      documentHelpers.deleteTextRange(tx, start, end);
      tx.setSelection({
        type: 'property',
        path: path,
        startOffset: startOffset,
        containerId: sel.containerId
      });
    }
  }
  // deleting a range of characters within a text property
  else if (sel.isPropertySelection()) {
    documentHelpers.deleteTextRange(tx, sel.start, sel.end);
    tx.setSelection(sel.collapse('left'));
  }
  // deleting a range within a container (across multiple nodes)
  else if (sel.isContainerSelection()) {
    this.deleteContainerSelection(tx, sel);
  }
  else {
    console.warn('Unsupported case: tx.delete(%)', direction, sel);
  }
};

Editing.prototype.deleteNodeSelection = function deleteNodeSelection (tx, sel, direction) {
  var nodeId = sel.getNodeId();
  var container = tx.get(sel.containerId);
  var nodePos = container.getPosition(nodeId, 'strict');
  if (sel.isFull() ||
      sel.isBefore() && direction === 'right' ||
      sel.isAfter() && direction === 'left' ) {
    // replace the node with default text node
    var contentPath = container.getContentPath();
    tx.update(contentPath, { type: 'delete', pos: nodePos });
    tx.delete(nodeId);
    var newNode = tx.createDefaultTextNode();
    tx.update(contentPath, { type: 'insert', pos: nodePos, value: newNode.id });
    tx.setSelection({
      type: 'property',
      path: newNode.getTextPath(),
      startOffset: 0,
      containerId: container.id,
    });
  } else {
    if (sel.isBefore() && direction === 'left') {
      if (nodePos > 0) {
        var previous = container.getNodeAt(nodePos-1);
        if (previous.isText()) {
          tx.setSelection({
            type: 'property',
            path: previous.getTextPath(),
            startOffset: previous.getLength()
          });
          this.delete(tx, direction);
        } else {
          tx.setSelection({
            type: 'node',
            nodeId: previous.id,
            containerId: container.id
          });
        }
      } else {
        // nothing to do
      }
    } else if (sel.isAfter() && direction === 'right') {
      if (nodePos < container.getLength()-1) {
        var next = container.getNodeAt(nodePos+1);
        if (next.isText()) {
          tx.setSelection({
            type: 'property',
            path: next.getTextPath(),
            startOffset: 0
          });
          this.delete(tx, direction);
        } else {
          tx.setSelection({
            type: 'node',
            nodeId: next.id,
            containerId: container.id
          });
        }
      } else {
        // nothing to do
      }
    } else {
      console.warn('Unsupported case: delete(%s)', direction, sel);
    }
  }
};

Editing.prototype.deletePropertySelection = function deletePropertySelection (tx, sel) {
  var path = sel.start.path;
  var start = sel.start.offset;
  var end = sel.end.offset;
  tx.update(path, { type: 'delete', start: start, end: end });
  annotationHelpers.deletedText(tx, path, start, end);
};

// deletes all inner nodes and 'truncates' start and end node
Editing.prototype.deleteContainerSelection = function deleteContainerSelection (tx, sel) {
  var containerId = sel.containerId;
  var container = tx.get(containerId);
  var start = sel.start;
  var end = sel.end;
  var startId = start.getNodeId();
  var endId = end.getNodeId();
  var startPos = container.getPosition(startId, 'strict');
  var endPos = container.getPosition(endId, 'strict');

  // special case: selection within one node
  if (startPos === endPos) {
    // ATTENTION: we need the root node here e.g. the list, not the list-item
    var node = tx.get(startId).getRoot();
    if (node.isText()) {
      documentHelpers.deleteTextRange(tx, start, end);
    } else if (node.isList()) {
      documentHelpers.deleteListRange(tx, node, start, end);
    } else {
      throw new Error('Not supported yet.')
    }
    tx.setSelection(sel.collapse('left'));
    return
  }

  // normalize the range if it is 'reverse'
  if (startPos > endPos) {
    var assign;
      (assign = [end, start], start = assign[0], end = assign[1]);
    var assign$1;
      (assign$1 = [endPos, startPos], startPos = assign$1[0], endPos = assign$1[1]);
    var assign$2;
      (assign$2 = [endId, startId], startId = assign$2[0], endId = assign$2[1]);
  }

  // TODO: document the algorithm

  var firstNode = tx.get(start.getNodeId());
  var lastNode = tx.get(end.getNodeId());
  var firstEntirelySelected = isEntirelySelected(tx, firstNode, start, null);
  var lastEntirelySelected = isEntirelySelected(tx, lastNode, null, end);

  // delete or truncate last node
  if (lastEntirelySelected) {
    tx.update([container.id, 'nodes'], { type: 'delete', pos: endPos });
    documentHelpers.deleteNode(tx, lastNode);
  } else {
    // ATTENTION: we need the root node here e.g. the list, not the list-item
    var node$1 = lastNode.getRoot();
    if (node$1.isText()) {
      documentHelpers.deleteTextRange(tx, null, end);
    } else if (node$1.isList()) {
      documentHelpers.deleteListRange(tx, node$1, null, end);
    } else {
      // IsolatedNodes can not be selected partially
    }
  }

  // delete inner nodes
  for (var i = endPos-1; i > startPos; i--) {
    var nodeId = container.nodes[i];
    tx.update([container.id, 'nodes'], { type: 'delete', pos: i });
    documentHelpers.deleteNode(tx, tx.get(nodeId));
  }

  // delete or truncate the first node
  if (firstEntirelySelected) {
    tx.update([container.id, 'nodes'], { type: 'delete', pos: startPos });
    documentHelpers.deleteNode(tx, firstNode);
  } else {
    // ATTENTION: we need the root node here e.g. the list, not the list-item
    var node$2 = firstNode.getRoot();
    if (node$2.isText()) {
      documentHelpers.deleteTextRange(tx, start, null);
    } else if (node$2.isList()) {
      documentHelpers.deleteListRange(tx, node$2, start, null);
    } else {
      // IsolatedNodes can not be selected partially
    }
  }

  // insert a new TextNode if all has been deleted
  if (firstEntirelySelected && lastEntirelySelected) {
    // insert a new paragraph
    var textNode = tx.createDefaultTextNode();
    tx.update([container.id, 'nodes'], { type: 'insert', pos: startPos, value: textNode.id });
    tx.setSelection({
      type: 'property',
      path: textNode.getTextPath(),
      startOffset: 0,
      containerId: containerId
    });
  } else if (!firstEntirelySelected && !lastEntirelySelected) {
    this._merge(tx, firstNode, sel.start, 'right', container);
    tx.setSelection(sel.collapse('left'));
  } else if (firstEntirelySelected) {
    setCursor(tx, lastNode, container.id, 'before');
  } else {
    setCursor(tx, firstNode, container.id, 'after');
  }
};

/*
  Delete a node and all annotations attached to it,
  and removes the node from the container.

  @param {String} nodeId
  @param {String} [containerId]
 */
Editing.prototype.deleteNode = function deleteNode (tx, nodeId, containerId) {
  if (!nodeId) { throw new Error('Parameter `nodeId` is mandatory.') }
  var node = tx.get(nodeId);
  if (!node) { throw new Error('Node does not exist') }
  if (containerId) {
    var container = tx.get(containerId);
    container.hide(nodeId);
    // TODO: fix support for container annotations
    // transfer anchors of ContainerAnnotations to previous or next node:
    //- start anchors go to the next node
    //- end anchors go to the previous node
    // let anchors = tx.getIndex('container-annotation-anchors').get(nodeId)
    // for (let i = 0; i < anchors.length; i++) {
    // let anchor = anchors[i]
    // container = tx.get(anchor.containerId)
    // // Note: during the course of this loop we might have deleted the node already
    // // so, don't do it again
    // if (!tx.get(anchor.id)) continue
    // let pos = container.getPosition(anchor.path[0])
    // let path, offset
    // if (anchor.isStart) {
    //   if (pos < container.getLength()-1) {
    //     let nextNode = container.getChildAt(pos+1)
    //     if (nextNode.isText()) {
    //       path = [nextNode.id, 'content']
    //     } else {
    //       path = [nextNode.id]
    //     }
    //     tx.set([anchor.id, 'start', 'path'], path)
    //     tx.set([anchor.id, 'start', 'offset'], 0)
    //   } else {
    //     tx.delete(anchor.id)
    //   }
    // } else {
    //   if (pos > 0) {
    //     let previousNode = container.getChildAt(pos-1)
    //     if (previousNode.isText()) {
    //       path = [previousNode.id, 'content']
    //       offset = tx.get(path).length
    //     } else {
    //       path = [previousNode.id]
    //       offset = 1
    //     }
    //     tx.set([anchor.id, 'endPath'], path)
    //     tx.set([anchor.id, 'endOffset'], offset)
    //   } else {
    //     tx.delete(anchor.id)
    //   }
    // }
    // }
  }
  documentHelpers.deleteNode(tx, node);
};

Editing.prototype.insertInlineNode = function insertInlineNode (tx, nodeData) {
  var sel = tx.selection;
  if (!sel.isPropertySelection()) { throw new Error('insertInlineNode requires a PropertySelection') }
  var text = "\uFEFF";
  this.insertText(tx, text);
  sel = tx.selection;
  var endOffset = tx.selection.end.offset;
  var startOffset = endOffset - text.length;
  nodeData = Object.assign({}, nodeData, {
    start: {
      path: sel.path,
      offset: startOffset
    },
    end: {
      path: sel.path,
      offset: endOffset
    }
  });
  return tx.create(nodeData)
};

Editing.prototype.insertBlockNode = function insertBlockNode (tx, nodeData) {
  var sel = tx.selection;
  if (!sel || sel.isNull()) { throw new Error('Selection is null.') }
  // don't create the node if it already exists
  var blockNode;
  if (!nodeData._isNode || !tx.get(nodeData.id)) {
    blockNode = tx.create(nodeData);
  } else {
    blockNode = tx.get(nodeData.id);
  }
  if (sel.isNodeSelection()) {
    var containerId = sel.containerId;
    var container = tx.get(containerId);
    var nodeId = sel.getNodeId();
    var nodePos = container.getPosition(nodeId, 'strict');
    // insert before
    if (sel.isBefore()) {
      tx.update(container.getContentPath(), { type: 'insert', pos: nodePos, value: blockNode.id });
    }
    // insert after
    else if (sel.isAfter()) {
      tx.update(container.getContentPath(), { type: 'insert', pos: nodePos+1, value: blockNode.id });
      tx.setSelection({
        type: 'node',
        containerId: containerId,
        nodeId: blockNode.id,
        mode: 'after'
      });
    } else {
      tx.update(container.getContentPath(), { type: 'delete', pos: nodePos });
      tx.delete(sel.getNodeId());
      tx.update([container.id, 'nodes'], { type: 'insert', pos: nodePos, value: blockNode.id });
      tx.setSelection({
        type: 'node',
        containerId: containerId,
        nodeId: blockNode.id,
        mode: 'after'
      });
    }
  } else if (sel.isPropertySelection()) {
    if (!sel.containerId) { throw new Error('insertBlockNode can only be used within a container.') }
    var container$1 = tx.get(sel.containerId);
    if (!sel.isCollapsed()) {
      this.deletePropertySelection(tx);
      tx.setSelection(sel.collapse('left'));
    }
    var node = tx.get(sel.path[0]);
    if (!node) { throw new Error('Invalid selection.') }
    var nodePos$1 = container$1.getPosition(node.id, 'strict');
    if (node.isText()) {
      var text = node.getText();
      // replace node
      if (text.length === 0) {
        tx.update(container$1.getContentPath(), { type: 'delete', pos: nodePos$1 });
        tx.delete(node.id);
        tx.update([container$1.id, 'nodes'], { type: 'insert', pos: nodePos$1, value: blockNode.id });
        setCursor(tx, blockNode, container$1.id, 'after');
      }
      // insert before
      else if (sel.start.offset === 0) {
        tx.update(container$1.getContentPath(), { type: 'insert', pos: nodePos$1, value: blockNode.id });
      }
      // insert after
      else if (sel.start.offset === text.length) {
        tx.update(container$1.getContentPath(), { type: 'insert', pos: nodePos$1+1, value: blockNode.id });
        setCursor(tx, blockNode, container$1.id, 'before');
      }
      // break
      else {
        this.break(tx);
        tx.update(container$1.getContentPath(), { type: 'insert', pos: nodePos$1+1, value: blockNode.id });
        setCursor(tx, blockNode, container$1.id, 'after');
      }
    } else {
      // TODO: this will be necessary for lists
      console.error('Not yet implemented: insertBlockNode() on a custom node');
    }
  } else if (sel.isContainerSelection()) {
    if (sel.isCollapsed()) {
      var start = sel.start;
      if (start.isPropertyCoordinate()) {
        tx.setSelection({
          type: 'property',
          path: start.path,
          startOffset: start.offset,
          containerId: sel.containerId,
        });
      } else if (start.isNodeCoordinate()) {
        tx.setSelection({
          type: 'node',
          containerId: sel.containerId,
          nodeId: start.path[0],
          mode: start.offset === 0 ? 'before' : 'after',
        });
      } else {
        throw new Error('Unsupported selection for insertBlockNode')
      }
      return this.insertBlockNode(tx, blockNode)
    }
  }
};

Editing.prototype.insertText = function insertText (tx, text) {
  var sel = tx.selection;
  // type over a selected node or insert a paragraph before
  // or after
  if (sel.isNodeSelection()) {
    var containerId = sel.containerId;
    var container = tx.get(containerId);
    var nodeId = sel.getNodeId();
    var nodePos = container.getPosition(nodeId, 'strict');
    var textNode = tx.createDefaultTextNode(text);
    if (sel.isBefore()) {
      container.show(textNode, nodePos);
    } else if (sel.isAfter()) {
      container.show(textNode, nodePos+1);
    } else {
      container.hide(nodeId);
      tx.delete(nodeId);
      container.show(textNode, nodePos);
    }
    setCursor(tx, textNode, sel.containerId, 'after');
  } else if (sel.isCustomSelection()) {
    // TODO: what to do with custom selections?
  } else if (sel.isCollapsed() || sel.isPropertySelection()) {
    // console.log('#### before', sel.toString())
    this._insertText(tx, sel, text);
    // console.log('### setting selection after typing: ', tx.selection.toString())
  } else if (sel.isContainerSelection()) {
    this.deleteContainerSelection(tx, sel);
    this.insertText(tx, text);
  }
};

Editing.prototype.paste = function paste$1 (tx, content) {
  if (!content) { return }
  if (isString(content)) {
    paste(tx, {text: content});
  } else if (content._isDocument) {
    paste(tx, {doc: content});
  } else {
    throw new Error('Illegal content for paste.')
  }
};

/**
  Switch text type for a given node. E.g. from `paragraph` to `heading`.

  @param {Object} args object with `selection`, `containerId` and `data` with new node data
  @return {Object} object with updated `selection`

  @example

  ```js
  switchTextType(tx, {
    selection: bodyEditor.getSelection(),
    containerId: bodyEditor.getContainerId(),
    data: {
      type: 'heading',
      level: 2
    }
  })
  ```
*/
Editing.prototype.switchTextType = function switchTextType (tx, data) {
  var sel = tx.selection;
  if (!sel.isPropertySelection()) {
    throw new Error("Selection must be a PropertySelection.")
  }
  var containerId = sel.containerId;
  if (!containerId) {
    throw new Error("Selection must be within a container.")
  }
  var path = sel.path;
  var nodeId = path[0];
  var node = tx.get(nodeId);
  if (!(node.isInstanceOf('text'))) {
    throw new Error('Trying to use switchTextType on a non text node. Skipping.')
  }
  // create a new node and transfer annotations
  var newNode = Object.assign({
    id: uuid(data.type),
    type: data.type,
    content: node.content,
    direction: node.direction
  }, data);
  var newPath = [newNode.id, 'content'];
  newNode = tx.create(newNode);
  annotationHelpers.transferAnnotations(tx, path, 0, newPath, 0);

  // hide the old one, show the new node
  var container = tx.get(sel.containerId);
  var pos = container.getPosition(nodeId, 'strict');
  container.hide(nodeId);
  container.show(newNode.id, pos);

  // remove the old one from the document
  this.deleteNode(tx, node.id, containerId);
  tx.setSelection({
    type: 'property',
    path: newPath,
    startOffset: sel.start.offset,
    endOffset: sel.end.offset,
    containerId: containerId
  });

  return newNode
};

Editing.prototype.toggleList = function toggleList (tx, params) {
  var sel = tx.selection;
  var container = tx.get(sel.containerId);
  // not possible without container
  if (!container) { return }
  if (sel.isPropertySelection()) {
    var nodeId = sel.start.path[0];
    // ATTENTION: we need the root node here e.g. the list, not the list-item
    var node = tx.get(nodeId).getRoot();
    var nodePos = container.getPosition(node.id, 'strict');
    if (node.isText()) {
      tx.update([container.id, 'nodes'], { type: 'delete', pos: nodePos });
      // TODO: what if this should create a different list-item type?
      var newItem = tx.create({
        type: 'list-item',
        content: node.getText(),
      });
      annotationHelpers.transferAnnotations(tx, node.getTextPath(), 0, newItem.getTextPath(), 0);
      var newList = tx.create(Object.assign({
        type: 'list',
        items: [newItem.id]
      }, params));
      tx.delete(node.id);
      tx.update([container.id, 'nodes'], { type: 'insert', pos: nodePos, value: newList.id });
      tx.setSelection({
        type: 'property',
        path: newItem.getTextPath(),
        startOffset: sel.start.offset,
        containerId: sel.containerId
      });
    } else if (node.isList()) {
      var itemId = sel.start.path[0];
      var itemPos = node.getItemPosition(itemId);
      var item = node.getItemAt(itemPos);
      var newTextNode = tx.createDefaultTextNode(item.getText());
      annotationHelpers.transferAnnotations(tx, item.getTextPath(), 0, newTextNode.getTextPath(), 0);
      // take the item out of the list
      node.removeItemAt(itemPos);
      if (node.getLength() === 0) {
        tx.update([container.id, 'nodes'], { type: 'delete', pos: nodePos });
        tx.delete(node.id);
        tx.update([container.id, 'nodes'], { type: 'insert', pos: nodePos, value: newTextNode.id });
      } else if (itemPos === 0) {
        tx.update([container.id, 'nodes'], { type: 'insert', pos: nodePos, value: newTextNode.id });
      } else if (node.getLength() <= itemPos){
        tx.update([container.id, 'nodes'], { type: 'insert', pos: nodePos+1, value: newTextNode.id });
      } else {
        //split the
        var tail = [];
        var items = node.items.slice();
        var L = items.length;
        for (var i = L-1; i >= itemPos; i--) {
          tail.unshift(items[i]);
          node.removeItemAt(i);
        }
        var newList$1 = tx.create({
          type: 'list',
          items: tail,
          ordered: node.ordered
        });
        tx.update([container.id, 'nodes'], { type: 'insert', pos: nodePos+1, value: newTextNode.id });
        tx.update([container.id, 'nodes'], { type: 'insert', pos: nodePos+2, value: newList$1.id });
      }
      tx.setSelection({
        type: 'property',
        path: newTextNode.getTextPath(),
        startOffset: sel.start.offset,
        containerId: sel.containerId
      });
    }
  } else if (sel.isContainerSelection()) {
    console.error('TODO: support toggleList with ContainerSelection');
  }
};

Editing.prototype.indent = function indent (tx) {
  var sel = tx.selection;
  if (sel.isPropertySelection()) {
    var nodeId = sel.start.getNodeId();
    // ATTENTION: we need the root node here, e.g. the list, not the list items
    var node = tx.get(nodeId).getRoot();
    if (node.isList()) {
      var itemId = sel.start.path[0];
      var item = tx.get(itemId);
      // Note: allowing only 3 levels
      if (item && item.level<3) {
        tx.set([itemId, 'level'], item.level+1);
      }
    }
  } else if (sel.isContainerSelection()) {
    // TODO support ContainerSelection
  }
};

Editing.prototype.dedent = function dedent (tx) {
  var sel = tx.selection;
  if (sel.isPropertySelection()) {
    var nodeId = sel.start.getNodeId();
    // ATTENTION: we need the root node here, e.g. the list, not the list items
    var node = tx.get(nodeId).getRoot();
    if (node.isList()) {
      var itemId = sel.start.path[0];
      var item = tx.get(itemId);
      if (item && item.level>1) {
        tx.set([itemId, 'level'], item.level-1);
      }
    }
  } else if (sel.isContainerSelection()) {
    // TODO support ContainerSelection
  }
};

/*
  <-->: anno
  |--|: area of change
  I: <--> |--|   : nothing
  II: |--| <-->  : move both by total span+L
  III: |-<-->-|  : delete anno
  IV: |-<-|->    : move start by diff to start+L, and end by total span+L
  V: <-|->-|     : move end by diff to start+L
  VI: <-|--|->   : move end by total span+L
*/
Editing.prototype._insertText = function _insertText (tx, sel, text) {
  var start = sel.start;
  var end = sel.end;
  if (!isArrayEqual(start.path, end.path)) {
    throw new Error('Unsupported state: range should be on one property')
  }
  var path = start.path;
  var startOffset = start.offset;
  var endOffset = end.offset;
  var typeover = !sel.isCollapsed();
  var L = text.length;
  // delete selected text
  if (typeover) {
    tx.update(path, { type: 'delete', start: startOffset, end: endOffset });
  }
  // insert new text
  tx.update(path, { type: 'insert', start: startOffset, text: text });
  // update annotations
  var annos = tx.getAnnotations(path);
  annos.forEach(function(anno) {
    var annoStart = anno.start.offset;
    var annoEnd = anno.end.offset;
    // I anno is before
    if (annoEnd<startOffset) {
      return
    }
    // II anno is after
    else if (annoStart>=endOffset) {
      tx.update([anno.id, 'start'], { type: 'shift', value: startOffset-endOffset+L });
      tx.update([anno.id, 'end'], { type: 'shift', value: startOffset-endOffset+L });
    }
    // III anno is deleted
    // NOTE: InlineNodes only have a length of one character
    // so they are always 'covered', and as they can not expand
    // they are deleted
    else if (
      (annoStart>=startOffset && annoEnd<endOffset) ||
      (anno._isInlineNode && annoStart>=startOffset && annoEnd<=endOffset)
    ) {
      tx.delete(anno.id);
    }
    // IV anno.start between and anno.end after
    else if (annoStart>=startOffset && annoEnd>=endOffset) {
      // do not move start if typing over
      if (annoStart>startOffset || !typeover) {
        tx.update([anno.id, 'start'], { type: 'shift', value: startOffset-annoStart+L });
      }
      tx.update([anno.id, 'end'], { type: 'shift', value: startOffset-endOffset+L });
    }
    // V anno.start before and anno.end between
    else if (annoStart<startOffset && annoEnd<endOffset) {
      // NOTE: here the anno gets expanded (that's the common way)
      tx.update([anno.id, 'end'], { type: 'shift', value: startOffset-annoEnd+L });
    }
    // VI anno.start before and anno.end after
    else if (annoStart<startOffset && annoEnd>=endOffset) {
      if (anno._isInlineNode) {
        // skip
      } else {
        tx.update([anno.id, 'end'], { type: 'shift', value: startOffset-endOffset+L });
      }
    }
    else {
      console.warn('TODO: handle annotation update case.');
    }
  });
  var offset = startOffset + text.length;
  tx.setSelection({
    type: 'property',
    path: start.path,
    startOffset: offset,
    containerId: sel.containerId,
    surfaceId: sel.surfaceId
  });
};

Editing.prototype._breakNode = function _breakNode (tx, node, coor, container) {
  // ATTENTION: we need the root here, e.g. a list, not the list-item
  node = node.getRoot();
  if (node.isText()) {
    this._breakTextNode(tx, node, coor, container);
  } else if (node.isList()) {
    this._breakListNode(tx, node, coor, container);
  } else {
    throw new Error('Not supported')
  }
};

Editing.prototype._breakTextNode = function _breakTextNode (tx, node, coor, container) {
  var path = coor.path;
  var offset = coor.offset;
  var nodePos = container.getPosition(node.id, 'strict');
  var text = node.getText();

  // when breaking at the first position, a new node of the same
  // type will be inserted.
  if (offset === 0) {
    var newNode = tx.create({
      type: node.type,
      content: ""
    });
    // show the new node
    container.show(newNode.id, nodePos);
    tx.setSelection({
      type: 'property',
      path: path,
      startOffset: 0,
      containerId: container.id
    });
  }
  // otherwise split the text property and create a new paragraph node with trailing text and annotations transferred
  else {
    var newNode$1 = node.toJSON();
    delete newNode$1.id;
    newNode$1.content = text.substring(offset);
    // if at the end insert a default text node no matter in which text node we are
    if (offset === text.length) {
      newNode$1.type = tx.getSchema().getDefaultTextType();
    }
    newNode$1 = tx.create(newNode$1);
    // Now we need to transfer annotations
    if (offset < text.length) {
      // transfer annotations which are after offset to the new node
      annotationHelpers.transferAnnotations(tx, path, offset, newNode$1.getTextPath(), 0);
      // truncate the original property
      tx.update(path, { type: 'delete', start: offset, end: text.length });
    }
    // show the new node
    container.show(newNode$1.id, nodePos+1);
    // update the selection
    tx.setSelection({
      type: 'property',
      path: newNode$1.getTextPath(),
      startOffset: 0,
      containerId: container.id
    });
  }
};

Editing.prototype._breakListNode = function _breakListNode (tx, node, coor, container) {
  var path = coor.path;
  var offset = coor.offset;
  var listItem = tx.get(path[0]);

  var L = node.length;
  var itemPos = node.getItemPosition(listItem.id);
  var text = listItem.getText();
  var newItem = listItem.toJSON();
  delete newItem.id;
  if (offset === 0) {
    // if breaking at an empty list item, then the list is split into two
    if (!text) {
      // if it is the first or last item, a default text node is inserted before or after, and the item is removed
      // if the list has only one element, it is removed
      var nodePos = container.getPosition(node.id, 'strict');
      var newTextNode = tx.createDefaultTextNode();
      // if the list is empty, replace it with a paragraph
      if (L < 2) {
        container.hide(node.id);
        tx.delete(node.id);
        container.show(newTextNode.id, nodePos);
      }
      // if at the first list item, remove the item
      else if (itemPos === 0) {
        node.remove(listItem.id);
        tx.delete(listItem.id);
        container.show(newTextNode.id, nodePos);
      }
      // if at the last list item, remove the item and append the paragraph
      else if (itemPos >= L-1) {
        node.remove(listItem.id);
        tx.delete(listItem.id);
        container.show(newTextNode.id, nodePos+1);
      }
      // otherwise create a new list
      else {
        var tail = [];
        var items = node.items.slice();
        for (var i = L-1; i > itemPos; i--) {
          tail.unshift(items[i]);
          node.remove(items[i]);
        }
        node.remove(items[itemPos]);
        var newList = tx.create({
          type: 'list',
          items: tail,
          ordered: node.ordered
        });
        container.show(newTextNode.id, nodePos+1);
        container.show(newList.id, nodePos+2);
      }
      tx.setSelection({
        type: 'property',
        path: newTextNode.getTextPath(),
        startOffset: 0
      });
    }
    // insert a new paragraph above the current one
    else {
      newItem.content = "";
      newItem = tx.create(newItem);
      node.insertItemAt(itemPos, newItem.id);
      tx.setSelection({
        type: 'property',
        path: listItem.getTextPath(),
        startOffset: 0
      });
    }
  }
  // otherwise split the text property and create a new paragraph node with trailing text and annotations transferred
  else {
    newItem.content = text.substring(offset);
    newItem = tx.create(newItem);
    // Now we need to transfer annotations
    if (offset < text.length) {
      // transfer annotations which are after offset to the new node
      annotationHelpers.transferAnnotations(tx, path, offset, [newItem.id,'content'], 0);
      // truncate the original property
      tx.update(path, { type: 'delete', start: offset, end: text.length });
    }
    node.insertItemAt(itemPos+1, newItem.id);
    tx.setSelection({
      type: 'property',
      path: newItem.getTextPath(),
      startOffset: 0
    });
  }
};

Editing.prototype._merge = function _merge (tx, node, coor, direction, container) {
  // detect cases where list items get merged
  // within a single list node
  if (node.isList()) {
    var list = node;
    var itemId = coor.path[0];
    var itemPos = list.getItemPosition(itemId);
    var withinListNode = (
      (direction === 'left' && itemPos > 0) ||
      (direction === 'right' && itemPos<list.items.length-1)
    );
    if (withinListNode) {
      itemPos = (direction === 'left') ? itemPos-1 : itemPos;
      var target = list.getItemAt(itemPos);
      var targetLength = target.getLength();
      documentHelpers.mergeListItems(tx, list.id, itemPos);
      tx.setSelection({
        type: 'property',
        path: target.getTextPath(),
        startOffset: targetLength,
        containerId: container.id
      });
      return
    }
  }
  // in all other cases merge is done across node boundaries
  var nodePos = container.getPosition(node, 'strict');
  if (direction === 'left' && nodePos > 0) {
    this._mergeNodes(tx, container, nodePos-1, direction);
  } else if (direction === 'right' && nodePos<container.getLength()-1) {
    this._mergeNodes(tx, container, nodePos, direction);
  }
};

Editing.prototype._mergeNodes = function _mergeNodes (tx, container, pos, direction) {
  var first = container.getChildAt(pos);
  var second = container.getChildAt(pos+1);
  if (first.isText()) {
    // Simplification for empty nodes
    if (first.isEmpty()) {
      container.hide(first.id);
      tx.delete(first.id);
      // TODO: need to clear where to handle
      // selections ... probably better not to do it here
      setCursor(tx, second, container.id, 'before');
      return
    }
    var target = first;
    var targetPath = target.getTextPath();
    var targetLength = target.getLength();
    if (second.isText()) {
      var source = second;
      var sourcePath = source.getTextPath();
      container.hide(source.id);
      // append the text
      tx.update(targetPath, { type: 'insert', start: targetLength, text: source.getText() });
      // transfer annotations
      annotationHelpers.transferAnnotations(tx, sourcePath, 0, targetPath, targetLength);
      tx.delete(source.id);
      tx.setSelection({
        type: 'property',
        path: targetPath,
        startOffset: targetLength,
        containerId: container.id
      });
    } else if (second.isList()) {
      var list = second;
      var source$1 = list.getFirstItem();
      var sourcePath$1 = source$1.getTextPath();
      // remove merged item from list
      list.removeItemAt(0);
      // append the text
      tx.update(targetPath, { type: 'insert', start: targetLength, text: source$1.getText() });
      // transfer annotations
      annotationHelpers.transferAnnotations(tx, sourcePath$1, 0, targetPath, targetLength);
      // delete item and prune empty list
      tx.delete(source$1.id);
      if (list.getLength() === 0) {
        container.hide(list.id);
        tx.delete(list.id);
      }
      tx.setSelection({
        type: 'property',
        path: targetPath,
        startOffset: targetLength,
        containerId: container.id
      });
    } else {
      selectNode(tx, direction === 'left' ? first.id : second.id, container.id);
    }
  } else if (first.isList()) {
    if (second.isText()) {
      var source$2 = second;
      var sourcePath$2 = source$2.getTextPath();
      var target$1 = first.getLastItem();
      var targetPath$1 = target$1.getTextPath();
      var targetLength$1 = target$1.getLength();
      // hide source
      container.hide(source$2.id);
      // append the text
      tx.update(targetPath$1, { type: 'insert', start: targetLength$1, text: source$2.getText() });
      // transfer annotations
      annotationHelpers.transferAnnotations(tx, sourcePath$2, 0, targetPath$1, targetLength$1);
      tx.delete(source$2.id);
      tx.setSelection({
        type: 'property',
        path: target$1.getTextPath(),
        startOffset: targetLength$1,
        containerId: container.id
      });
    } else if (second.isList()) {
      container.hide(second.id);
      var firstItems = first.items.slice();
      var secondItems = second.items.slice();
      for (var i=0; i<secondItems.length;i++) {
        second.removeItemAt(0);
        first.appendItem(secondItems[i]);
      }
      tx.delete(second.id);
      if (direction === 'left') {
        tx.setSelection({
          type: 'property',
          path: tx.get(secondItems[0]).getTextPath(),
          startOffset: 0,
          containerId: container.id
        });
      } else {
        var item = tx.get(last$2(firstItems));
        tx.setSelection({
          type: 'property',
          path: item.getTextPath(),
          startOffset: item.getLength(),
          containerId: container.id
        });
      }
    } else {
      selectNode(tx, direction === 'left' ? first.id : second.id, container.id);
    }
  } else {
    if (second.isText() && second.isEmpty()) {
      container.hide(second.id);
      tx.delete(second.id);
      setCursor(tx, first, container.id, 'after');
    } else {
      selectNode(tx, direction === 'left' ? first.id : second.id, container.id);
    }
  }
};

/*
  Abstract base class for document editor APIs such as Transaction.

  It implements a turtle-graphics way of editing by maintaining a selection state
  and providing an interface for low- and high-level manipulation.

  Low-level manipulations are dispatched to the edited document instance.
  Higher-level manipulations involve complex manipulations keeping the selection in a correct state.
 */
var EditingInterface = function EditingInterface(doc) {
  this._document = doc;
  this._selection = null;
  // TODO: allow for custom editing implementation
  this._impl = new Editing();
  this._direction = null;
};

var prototypeAccessors$2 = { selection: {},textDirection: {} };

EditingInterface.prototype.getDocument = function getDocument () {
  return this._document
};

/* low-level API */

EditingInterface.prototype.get = function get () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

  return (ref = this._document).get.apply(ref, args)
    var ref;
};

EditingInterface.prototype.contains = function contains (id) {
  return this._document.contains(id)
};

EditingInterface.prototype.create = function create (nodeData) {
  return this._document.create(nodeData)
};

EditingInterface.prototype.createDefaultTextNode = function createDefaultTextNode (content) {
  return this._document.createDefaultTextNode(content, this._direction)
};

EditingInterface.prototype.delete = function delete$1 (nodeId) {
  return this._document.delete(nodeId)
};

EditingInterface.prototype.set = function set (path, value) {
  return this._document.set(path, value)
};

EditingInterface.prototype.update = function update (path, diffOp) {
  return this._document.update(path, diffOp)
};

/* Selection API */

EditingInterface.prototype.createSelection = function createSelection () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

  return (ref = this._document).createSelection.apply(ref, args)
    var ref;
};

EditingInterface.prototype.setSelection = function setSelection (sel) {
  if (!sel) { sel = Selection.nullSelection; }
  else if (isPlainObject(sel)) {
    sel = this.createSelection(sel);
  }
  var oldSel = this._selection;
  if (oldSel && sel && !sel.isNull()) {
    if (!sel.containerId) {
      sel.containerId = oldSel.containerId;
    }
  }
  this._selection = sel;
};

EditingInterface.prototype.getSelection = function getSelection () {
  return this._selection
};

prototypeAccessors$2.selection.get = function () {
  return this._selection
};

prototypeAccessors$2.selection.set = function (sel) {
  this.setSelection(sel);
};

/*
  ATTENTION/TODO: text direction could be different on different paragraphs
  I.e. it should probably be a TextNode property
*/
prototypeAccessors$2.textDirection.get = function () {
  return this._direction
};

prototypeAccessors$2.textDirection.set = function (dir) {
  this._direction = dir;
};

/* High-level editing */

EditingInterface.prototype.annotate = function annotate (annotationData) {
  if (this._selection && !this._selection.isNull()) {
    return this._impl.annotate(this, annotationData)
  }
};

EditingInterface.prototype.break = function break$1 () {
  if (this._selection && !this._selection.isNull()) {
    this._impl.break(this);
  }
};

EditingInterface.prototype.copySelection = function copySelection$1 () {
  if (this._selection && !this._selection.isNull()) {
    return copySelection(this.getDocument(), this._selection)
  }
};

EditingInterface.prototype.deleteSelection = function deleteSelection (options) {
  if (this._selection && !this._selection.isNull()) {
    this._impl.delete(this, 'right', options);
  }
};

EditingInterface.prototype.deleteCharacter = function deleteCharacter (direction) {
  if (!this._selection || this._selection.isNull()) {
    // nothing
  } else if (!this._selection.isCollapsed()) {
    this.deleteSelection();
  } else {
    this._impl.delete(this, direction);
  }
};

EditingInterface.prototype.insertText = function insertText (text) {
  this._impl.insertText(this, text);
};

// insert an inline node with given data at the current selection
EditingInterface.prototype.insertInlineNode = function insertInlineNode (inlineNode) {
  this._impl.insertInlineNode(this, inlineNode);
};

EditingInterface.prototype.insertBlockNode = function insertBlockNode (blockNode) {
  this._impl.insertBlockNode(this, blockNode);
};

EditingInterface.prototype.paste = function paste (content) {
  this._impl.paste(this, content);
};

EditingInterface.prototype.switchTextType = function switchTextType (nodeData) {
  if (this._selection && !this._selection.isNull()) {
    return this._impl.switchTextType(this, nodeData)
  }
};

EditingInterface.prototype.toggleList = function toggleList (params) {
  if (this._selection && !this._selection.isNull()) {
    return this._impl.toggleList(this, params)
  }
};

EditingInterface.prototype.indent = function indent () {
  if (this._selection && !this._selection.isNull()) {
    this._impl.indent(this);
  }
};

EditingInterface.prototype.dedent = function dedent () {
  if (this._selection && !this._selection.isNull()) {
    this._impl.dedent(this);
  }
};

/* Legacy low-level API */

EditingInterface.prototype.getIndex = function getIndex () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

  return (ref = this._document).getIndex.apply(ref, args)
    var ref;
};

EditingInterface.prototype.getAnnotations = function getAnnotations () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

  return (ref = this._document).getAnnotations.apply(ref, args)
    var ref;
};

EditingInterface.prototype.getSchema = function getSchema () {
  return this._document.getSchema()
};

EditingInterface.prototype.createSnippet = function createSnippet () {
  return this._document.createSnippet()
};

Object.defineProperties( EditingInterface.prototype, prototypeAccessors$2 );

/*
  A transaction for editing a document in an EditorSession.

  Wherever you see `tx`, it is an instance of this class.

  The transaction is used to manipulate the document in a 'turtle-graphics' style.
  For that it maintains an internal state consisting of an array of operations, a selection, and
  the current surface.

  Usually, at the beginning of a transaction, one Surface is focused. This is used to initialize
  the transaction state. Depending on the type of Surface or the type of the current selection,
  some manipulations are allowed or others are not: it is not possible to create a ContainerAnnotation without
  a ContainerSelection, or pasting a list of nodes into a TextPropertyEditor will strip the structure and just
  the text content.

*/
var Transaction = (function (EditingInterface$$1) {
  function Transaction(doc, editorSession) {
    EditingInterface$$1.call(this);

    // TransactionDocument is essentially a clone of the document used to apply a sequence of document operations
    // without touching the original document
    this._stageDoc = this._document = new TransactionDocument(doc, this);
    this._editorSession = editorSession;

    // internal state
    this._isTransacting = false;
    this._state = 'idle';
    this._surface = null;
  }

  if ( EditingInterface$$1 ) Transaction.__proto__ = EditingInterface$$1;
  Transaction.prototype = Object.create( EditingInterface$$1 && EditingInterface$$1.prototype );
  Transaction.prototype.constructor = Transaction;

  var prototypeAccessors = { ops: {} };

  Transaction.prototype.dispose = function dispose () {
    this._stageDoc.dispose();
  };

  Transaction.prototype.setSelection = function setSelection (sel) {
    EditingInterface$$1.prototype.setSelection.call(this, sel);

    // NOTE: we might want to remove 'surfaceId' from selection, and instead
    // map surfaces to model paths. For the time being we keep it the old
    // way, but take it from the currently focused surface
    sel = this._selection;
    if (!sel.isNull()) {
      if (!sel.surfaceId) {
        // TODO: We could check if the selection is valid within the given surface
        var surface = this._editorSession.getFocusedSurface();
        if (surface) {
          sel.surfaceId = surface.id;
        } else {
          // TODO: instead of warning we could try to 'find' a suitable surface. However, this would also be a bit 'magical'
          console.warn('No focused surface. Selection will not be rendered.');
        }
      }
    }
  };

  // internal API

  // NOTE: ops are actually owned by TransactionDocument
  // we use the transaction document internally and not this instance
  prototypeAccessors.ops.get = function () {
    return this._stageDoc.ops
  };
  prototypeAccessors.ops.set = function (ops) {
    this._stageDoc.ops = ops;
  };

  Transaction.prototype.rollback = function rollback () {
    this._stageDoc._rollback();
  };

  Transaction.prototype._apply = function _apply () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    (ref = this._stageDoc)._apply.apply(ref, args);
    var ref;
  };

  // _ensureStarted() {
  //   if (this._state !== 'started') throw new Error('Transaction has not been started, or cancelled or saved already.')
  // }

  /**
    Start a transaction to manipulate the document

    @param {function} transformation a function(tx) that performs actions on the transaction document tx

    @example

    ```js
    doc.transaction(function(tx, args) {
      tx.update(...)
      ...
      return {
        selection: newSelection
      }
    })
    ```
  */
  Transaction.prototype._recordChange = function _recordChange (transformation, selection) {
    // TODO: we could get rid of isTransacting and use this._state instead
    if (this._isTransacting) { throw new Error('Nested transactions are not supported.') }
    if (!isFunction$2(transformation)) { throw new Error('Document.transaction() requires a transformation function.') }
    this._isTransacting = true;
    this._reset();
    this._state = 'started';
    var change;
    try {
      this.setSelection(selection);
      var selBefore = this.getSelection();
      transformation(this, {
        selection: selBefore
      });
      var ops = this.ops;
      if (ops.length > 0) {
        change = new DocumentChange(ops, this._before, this._after);
        change.before = { selection: selBefore };
        change.after = { selection: this.getSelection() };
      }
      this._state = 'finished';
    } finally {
      if (this._state !== 'finished') {
        this.rollback();
      }
      this._state = 'idle';
      this._isTransacting = false;
    }
    return change
  };

  Transaction.prototype._reset = function _reset () {
    this._before = {};
    this._after = {};
    this._stageDoc._reset();
    this._info = {};
    this.setSelection(null);
  };

  Object.defineProperties( Transaction.prototype, prototypeAccessors );

  return Transaction;
}(EditingInterface));

// just as a reference to detect name collisions
// with native Object properties
var PLAINOBJ = {};

/*
 * Simple registry implementation.
 *
 * @class Registry
 * @private
 */
var Registry = function Registry(entries, validator) {
  this.entries = {};
  this.names = [];
  this.validator = validator;

  if (entries) {
    forEach(entries, function(entry, name) {
      this.add(name, entry);
    }.bind(this));
  }
};

var prototypeAccessors$3 = { _isRegistry: {} };

prototypeAccessors$3._isRegistry.get = function () { return true };

/**
 * Check if an entry is registered for a given name.
 *
 * @param {String} name
 * @method contains
 * @memberof module:Basics.Registry.prototype
 */
Registry.prototype.contains = function contains (name) {
  return this.entries.hasOwnProperty(name)
};

/**
 * Add an entry to the registry.
 *
 * @param {String} name
 * @param {Object} entry
 * @method add
 * @memberof module:Basics.Registry.prototype
 */
Registry.prototype.add = function add (name, entry) {
  if (this.validator) {
    this.validator(entry);
  }
  if (PLAINOBJ[name]) {
    throw new Error('Illegal key: "'+name+'" is a property of Object which is thus not allowed as a key.')
  }
  if (this.contains(name)) {
    this.remove(name);
  }
  this.entries[name] = entry;
  this.names.push(name);
};

/**
 * Remove an entry from the registry.
 *
 * @param {String} name
 * @method remove
 * @memberof module:Basics.Registry.prototype
 */
Registry.prototype.remove = function remove (name) {
  var pos = this.names.indexOf(name);
  if (pos >= 0) {
    this.names.splice(pos, 1);
  }
  delete this.entries[name];
};

/**
 * @method clear
 * @memberof module:Basics.Registry.prototype
 */
Registry.prototype.clear = function clear () {
  this.names = [];
  this.entries = {};
};

/**
 * Get the entry registered for a given name.
 *
 * @param {String} name
 * @return The registered entry
 * @method get
 * @memberof module:Basics.Registry.prototype
 */
Registry.prototype.get = function get (name) {
  return this.entries[name]
};

/*
 * Iterate all registered entries in the order they were registered.
 *
 * @param {Function} callback with signature function(entry, name)
 * @param {Object} execution context
 */
Registry.prototype.each = function each (callback, ctx) {
  console.warn('DEPRECATED: use Registry.forEach(cb) instead');
  return this.forEach(callback.bind(ctx))
};

Registry.prototype.forEach = function forEach$$1 (callback) {
    var this$1 = this;

  for (var i = 0; i < this.names.length; i++) {
    var name = this$1.names[i];
    var _continue = callback(this$1.entries[name], name);
    if (_continue === false) {
      break
    }
  }
};

Registry.prototype.map = function map (callback) {
  var result = [];
  this.forEach(function(entry, name) {
    result.push(callback(entry, name));
  });
  return result
};

Registry.prototype.filter = function filter (callback) {
  var result = [];
  this.forEach(function(entry, name) {
    if (callback(entry, name)) {
      result.push(entry);
    }
  });
  return result
};

Object.defineProperties( Registry.prototype, prototypeAccessors$3 );

/*
  Listens to changes on the document and selection and updates the commandStates
  accordingly.

  @class CommandManager
*/
var CommandManager = function CommandManager(context, commands) {
  if (!context.editorSession) {
    throw new Error('EditorSession required.')
  }

  this.editorSession = context.editorSession;
  this.doc = this.editorSession.getDocument();
  this.context = extend({}, context, {
    // for convenienve we provide access to the doc directly
    doc: this.doc
  });
  // Set up command registry
  this.commandRegistry = new Registry();
  forEach(commands, function(command) {
    if(!command._isCommand) {
      throw new Error("Expecting instances of ui/Command.")
    }
    this.commandRegistry.add(command.name, command);
  }.bind(this));

  this.editorSession.onUpdate(this.onSessionUpdate, this);
  this.updateCommandStates(this.editorSession);
};

CommandManager.prototype.dispose = function dispose () {
  this.editorSession.off(this);
};

CommandManager.prototype.onSessionUpdate = function onSessionUpdate (editorSession) {
  if (editorSession.hasChanged('change') || editorSession.hasChanged('selection')) {
    this.updateCommandStates(editorSession);
  }
};

/*
  Compute new command states object
*/
CommandManager.prototype.updateCommandStates = function updateCommandStates (editorSession) {
  var commandStates = {};
  var commandContext = this.getCommandContext();
  var params = this._getCommandParams();
  this.commandRegistry.forEach(function(cmd) {
    commandStates[cmd.getName()] = cmd.getCommandState(params, commandContext);
  });
  // poor-man's immutable style
  if (!isEqual(this.commandStates, commandStates)) {
    this.commandStates = commandStates;
    editorSession.setCommandStates(commandStates);
  }
};

/*
  Execute a command, given a context and arguments.

  Commands are run async if cmd.isAsync() returns true.
*/
CommandManager.prototype.executeCommand = function executeCommand (commandName, userParams, cb) {
    var this$1 = this;

  var cmd = this.commandRegistry.get(commandName);
  if (!cmd) {
    console.warn('command', commandName, 'not registered');
    return
  }
  var commandState = this.commandStates[commandName];
  var params = extend(this._getCommandParams(), userParams, {
    commandState: commandState
  });

  if (cmd.isAsync) {
    // TODO: Request UI lock here
    this.editorSession.lock();
    cmd.execute(params, this.getCommandContext(), function (err, info) {
      if (err) {
        if (cb) {
          cb(err);
        } else {
          console.error(err);
        }
      } else {
        if (cb) { cb(null, info); }
      }
      this$1.editorSession.unlock();
    });
  } else {
    var info = cmd.execute(params, this.getCommandContext());
    return info
  }
};

/*
  Exposes the current commandStates object
*/
CommandManager.prototype.getCommandStates = function getCommandStates () {
  return this.commandStates
};

CommandManager.prototype.getCommandContext = function getCommandContext () {
  return this.context
};

// TODO: while we need it here this should go into the flow thingie later
CommandManager.prototype._getCommandParams = function _getCommandParams () {
  var editorSession = this.context.editorSession;
  var selectionState = editorSession.getSelectionState();
  var sel = selectionState.getSelection();
  var surface = this.context.surfaceManager.getFocusedSurface();
  return {
    editorSession: editorSession,
    selectionState: selectionState,
    surface: surface,
    selection: sel,
  }
};

/**
  A place to store global variables.
*/
var _global = (typeof global !== 'undefined') ? global : window;
var substanceGlobals = _global.hasOwnProperty('Substance') ? _global.Substance : _global.Substance = {
  DEBUG_RENDERING: true
};

function flattenOften(arr, max) {
  if (!(max > 0)) { throw new Error("'max' must be a positive number") }
  var l = arr.length;
  arr = flatten(arr);
  var round = 1;
  while (round < max && l < arr.length) {
    l = arr.length;
    arr = flatten(arr);
    round++;
  }
  return arr
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var this$1 = this;

  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this$1.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Gets the index at which the first occurrence of `NaN` is found in `array`.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
 */
function indexOfNaN(array, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    var other = array[index];
    if (other !== other) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return indexOfNaN(array, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to search.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to search.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing wrapper metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a
 * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
 * Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length,
 *  else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value)) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  var length = args.length;
  switch (length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$1(value)) {
    var other = isFunction(value.valueOf) ? value.valueOf() : value;
    value = isObject$1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0;
var MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$2 || value === -INFINITY$2) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as
 * an array.
 *
 * **Note:** This method is based on the
 * [rest parameter](https://mdn.io/rest_parameters).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.rest(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function rest(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, array);
      case 1: return func.call(this, args[0], array);
      case 2: return func.call(this, args[0], args[1], array);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates an array excluding all given values using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...*} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.xor
 * @example
 *
 * _.without([2, 1, 2, 3], 1, 2);
 * // => [3]
 */
var without = rest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, values)
    : [];
});

/*
  An iterator for arrays.

  @class
  @param {Array} arr
 */
var ArrayIterator = function ArrayIterator(arr) {
  this.arr = arr;
  this.pos = -1;
};

var prototypeAccessors$5 = { _isArrayIterator: {} };

prototypeAccessors$5._isArrayIterator.get = function () {
  return true
};

/**
  @returns {Boolean} true if there is another child node left.
 */
ArrayIterator.prototype.hasNext = function hasNext () {
  return this.pos < this.arr.length - 1
};

/**
  Increments the iterator providing the next child node.

  @returns {HTMLElement} The next child node.
 */
ArrayIterator.prototype.next = function next () {
  this.pos += 1;
  var next = this.arr[this.pos];
  return next
};

/**
  Decrements the iterator.
 */
ArrayIterator.prototype.back = function back () {
  if (this.pos >= 0) {
    this.pos -= 1;
  }
  return this
};

Object.defineProperties( ArrayIterator.prototype, prototypeAccessors$5 );

var NOT_IMPLEMENTED = 'This method is not implemented.';

/**
  A unified interface for DOM elements used by Substance.

  @abstract
*/
var DOMElement = function DOMElement () {};

var prototypeAccessors$4 = { id: {},tagName: {},nodeName: {},nodeType: {},className: {},textContent: {},innerHTML: {},outerHTML: {},firstChild: {},lastChild: {},nextSibling: {},previousSibling: {},parentNode: {},height: {},width: {} };

DOMElement.prototype.getNativeElement = function getNativeElement () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Checks if a CSS class is set.

  @abstract
  @param {String} className
  @returns {Boolean} true if the CSS class is set
*/
DOMElement.prototype.hasClass = function hasClass (className) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Adds a CSS class.

  @abstract
  @param {String} classString A space-separated string with CSS classes
  @returns {this}
*/
DOMElement.prototype.addClass = function addClass (classString) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Removes a CSS class.

  @abstract
  @param {String} classString A space-separated string with CSS classes
  @returns {this}
*/
DOMElement.prototype.removeClass = function removeClass (classString) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  jQuery style getter and setter for attributes.

  @abstract
  @param {String} name
  @param {String} [value] if present the attribute will be set
  @returns {String|this} if used as getter the attribute value, otherwise this element for chaining
 */
DOMElement.prototype.attr = function attr () {
  if (arguments.length === 1) {
    if (isString(arguments[0])) {
      return this.getAttribute(arguments[0])
    } else if (isObject(arguments[0])) {
      forEach(arguments[0], function(value, name) {
        this.setAttribute(name, value);
      }.bind(this));
    }
  } else if (arguments.length === 2) {
    this.setAttribute(arguments[0], arguments[1]);
  }
  return this
};

/**
  Removes an attribute.

  @abstract
  @param {String} name
  @returns {this}
*/
DOMElement.prototype.removeAttr = function removeAttr (name) {
  var names = name.split(/\s+/);
  if (names.length === 1) {
    this.removeAttribute(name);
  } else {
    names.forEach(function(name) {
      this.removeAttribute(name);
    }.bind(this));
  }
  return this
};

/**
  Get the attribute with a given name.

  @abstract
  @returns {String} the attribute's value.
*/
DOMElement.prototype.getAttribute = function getAttribute (name) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Set the attribute with a given name.

  @abstract
  @param {String} the attribute's value.
  @returns {this}
*/
DOMElement.prototype.setAttribute = function setAttribute (name, value) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.removeAttribute = function removeAttribute (name) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getAttributes = function getAttributes () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  jQuery style getter and setter for HTML element properties.

  @abstract
  @param {String} name
  @param {String} [value] if present the property will be set
  @returns {String|this} if used as getter the property value, otherwise this element for chaining
 */
DOMElement.prototype.htmlProp = function htmlProp () {
  if (arguments.length === 1) {
    if (isString(arguments[0])) {
      return this.getProperty(arguments[0])
    } else if (isObject(arguments[0])) {
      forEach(arguments[0], function(value, name) {
        this.setProperty(name, value);
      }.bind(this));
    }
  } else if (arguments.length === 2) {
    this.setProperty(arguments[0], arguments[1]);
  }
  return this
};

DOMElement.prototype.getProperty = function getProperty (name) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.setProperty = function setProperty (name, value) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.removeProperty = function removeProperty (name) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Get the tagName of this element.

  @abstract
  @private
  @note Considered as private API, in favor of the property {ui/DOMElement.prototype.tagName}
  @returns {String} the tag name in lower-case.
 */
DOMElement.prototype.getTagName = function getTagName () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Set the tagName of this element.

  @abstract
  @private
  @note Considered as private API, in favor of the property {ui/DOMElement.prototype.tagName}
  @param {String} tagName the new tag name
  @returns {this}
*/
DOMElement.prototype.setTagName = function setTagName (tagName) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Get the id of this element.

  @abstract
  @private
  @note Considered as private API, in favor of the property {ui/DOMElement.prototype.id}
  @returns {String} the id.
 */
DOMElement.prototype.getId = function getId () {
  return this.getAttribute('id')
};

/**
  Set the id of this element.

  @abstract
  @private
  @note Considered as private API, in favor of the property {ui/DOMElement.prototype.id}
  @param {String} id the new id
  @returns {this}
*/
DOMElement.prototype.setId = function setId (id) {
  this.setAttribute('id', id);
};

/**
  jQuery style getter and setter for the *value* of an element.

  @abstract
  @param {String} [value] The value to set.
  @returns {String|this} the value if used as a getter, `this` otherwise
*/
DOMElement.prototype.val = function val (value) {
  if (arguments.length === 0) {
    return this.getValue()
  } else {
    this.setValue(value);
    return this
  }
};

DOMElement.prototype.getValue = function getValue () {
  return this.getProperty('value')
};

DOMElement.prototype.setValue = function setValue (value) {
  this.setProperty('value', value);
  return this
};

/**
  jQuery style method to set or get inline CSS styles.

  @param {String} name the style name
  @param {String} [value] the style value
  @returns {String|this} the style value or this if used as a setter
*/
DOMElement.prototype.css = function css () {
  if (arguments.length === 1) {
    if (isString(arguments[0])) {
      return this.getStyle(arguments[0])
    } else if (isObject(arguments[0])) {
      forEach(arguments[0], function(value, name) {
        this.setStyle(name, value);
      }.bind(this));
    } else {
      throw new Error('Illegal arguments.')
    }
  } else if (arguments.length === 2) {
    this.setStyle(arguments[0], arguments[1]);
  } else {
    throw new Error('Illegal arguments.')
  }
  return this
};

DOMElement.prototype.getStyle = function getStyle (name) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.setStyle = function setStyle (name, value) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Gets or sets the text content of an element.

  @abstract
  @param {String} [text] The text content to set.
  @returns {String|this} The text content if used as a getter, `this` otherwise
*/
DOMElement.prototype.text = function text (text$1) {
  if (arguments.length === 0) {
    return this.getTextContent()
  } else {
    this.setTextContent(text$1);
  }
  return this
};

/**
  Get the textContent of this element.

  @abstract
  @private
  @note Considered as private API, in favor of the property {ui/DOMElement.prototype.innerHTML}
  @returns {String}
*/
DOMElement.prototype.getTextContent = function getTextContent () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Set the textContent of this element.

  @abstract
  @private
  @note Considered as private API, in favor of the property {ui/DOMElement.prototype.innerHTML}
  @param {String} text the new text content
  @returns {this}
*/
DOMElement.prototype.setTextContent = function setTextContent (text) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  jQuery style getter and setter for the innerHTML of an element.

  @abstract
  @param {String} [html] The html to set.
  @returns {String|this} the inner html if used as a getter, `this` otherwise
 */
DOMElement.prototype.html = function html (html$1) {
  if (arguments.length === 0) {
    return this.getInnerHTML()
  } else {
    this.setInnerHTML(html$1);
  }
  return this
};

/**
  Get the innerHTML of this element.

  @abstract
  @private
  @note Considered as private API, in favor of the property {@link ui/DOMElement.prototype.innerHTML}
  @returns {String}
*/
DOMElement.prototype.getInnerHTML = function getInnerHTML () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Set the innerHTML of this element.

  @abstract
  @private
  @note Considered as private API, in favor of the property {@link ui/DOMElement.prototype.innerHTML}
  @param {String} text the new text content
  @returns {this}
*/
DOMElement.prototype.setInnerHTML = function setInnerHTML (html) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Get the outerHTML of this element.

  @abstract
  @private
  @note Considered as private API, in favor of the property {@link ui/DOMElement.prototype.outerHTML}
  @returns {String}
*/
DOMElement.prototype.getOuterHTML = function getOuterHTML () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Registers an Element event handler.

  @param {String} event The event name.
  @param {Function} handler The handler function.
  @param {Object} [context] context where the function should be bound to
  @param {Object} [options]
  @param {Object} [options.selector] for event delegation
  @param {Object} [options.capture] to register the event in the event's capture phase (bubbling top-down)
  @returns {this}
*/
DOMElement.prototype.on = function on (eventName, handler, context, options) {
  if (!isString(eventName)) {
    throw new Error('Illegal argument: "event" must be a String.')
  }
  options = options || {};
  if (context) {
    options.context = context;
  }
  if (options.selector && !isString(options.selector)) {
    throw new Error('Illegal argument: selector must be a string.')
  }
  if (!handler || !isFunction$2(handler)) {
    throw new Error('Illegal argument: invalid handler function for event ' + eventName)
  }
  this.addEventListener(eventName, handler, options);
  return this
};

/**
  Unregisters the handler of a given event.

  @param {String} event The event name.
  @returns {this}
*/
DOMElement.prototype.off = function off (eventName, handler) {
  // el.off(this): disconnect all listeners bound to the given context
  if (arguments.length === 1 && !isString(eventName)) {
    var context = arguments[0];
    this.getEventListeners().filter(function(l) {
      return l.context === context
    }).forEach(function(l) {
      this.removeEventListener(l);
    }.bind(this));
  } else {
    this.removeEventListener(eventName, handler);
  }
  return this
};

DOMElement.prototype.addEventListener = function addEventListener (eventName, handler, options) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.removeEventListener = function removeEventListener (eventName, handler) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getEventListeners = function getEventListeners () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Gets the type of this element in lower-case.

  @private
  @note Considered as private API, in favor of the property {@link ui/DOMElement.prototype.nodeType}
  @returns {String}
*/
DOMElement.prototype.getNodeType = function getNodeType () {
  if (this.isTextNode()) {
    return "text"
  } else if (this.isCommentNode()) {
    return "comment"
  } else if (this.isElementNode()) {
    return "element"
  } else if (this.isDocumentNode()) {
    return "document"
  } else {
    throw new Error("Unsupported node type")
  }
};

DOMElement.prototype.getChildCount = function getChildCount () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Get child nodes of this element.

  This method provides a new array with wrapped native elements.
  Better use getChildAt().

  @abstract
  @private Considered as private API, in favor of the property {ui/DOMElement.prototype.childNodes}
  @returns {Array<ui/DOMElement>}
 */
DOMElement.prototype.getChildNodes = function getChildNodes () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Get child elements of this element.

  This method provides a new array with wrapped native elements.
  Better use getChildAt().

  @abstract
  @private Considered as private API, in favor of the property {ui/DOMElement.prototype.children}
  @returns {Array<ui/DOMElement>}
 */
DOMElement.prototype.getChildren = function getChildren () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getChildAt = function getChildAt (pos) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getChildIndex = function getChildIndex (child) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getChildNodeIterator = function getChildNodeIterator () {
  return new ArrayIterator(this.getChildNodes())
};

DOMElement.prototype.getLastChild = function getLastChild () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getFirstChild = function getFirstChild () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getNextSibling = function getNextSibling () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.getPreviousSibling = function getPreviousSibling () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Checks if the element is a TextNode.

  @abstract
  @returns {Boolean} true if the element is of type `Node.TEXT_NODE`
 */
DOMElement.prototype.isTextNode = function isTextNode () {
  return false
};

/**
  Checks if the element is actually an element as opposed to a node.

  @abstract
  @returns {Boolean} true if the element is of type `Node.ELEMENT_NODE`
 */
DOMElement.prototype.isElementNode = function isElementNode () {
  return false
};

/**
  Checks if the element is a CommentNode.

  @abstract
  @returns {Boolean} true if the element is of type `Node.COMMENT_NODE`
 */
DOMElement.prototype.isCommentNode = function isCommentNode () {
  return false
};

/**
  Checks if the element is a DocumentNode.

  @abstract
  @returns {Boolean} true if the element is of type `Node.DOCUMENT_NODE`
 */
DOMElement.prototype.isDocumentNode = function isDocumentNode () {
  return false
};

/**
  Creates a clone of the current element.

  @abstract
  @returns {ui/DOMElement} A clone of this element.
*/
DOMElement.prototype.clone = function clone () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Creates a DOMElement.

  @param {String} str a tag name or an HTML element as string.
  @returns {ui/DOMElement}
*/
DOMElement.prototype.createElement = function createElement (str) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.createTextNode = function createTextNode (text) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Checks if a given CSS selector matches for this element.

  **Attention**
  This method is currently not implemented for {ui/VirtualElement}.
  This means you should use it only in importer implementations.

  @abstract
  @param {String} cssSelector
  @returns {Boolean}
 */
DOMElement.prototype.is = function is (cssSelector) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Get the parent element of this element.

  @abstract
  @returns {ui/DOMElement} the parent element
 */
DOMElement.prototype.getParent = function getParent () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Get the root ancestor element of this element.

  In the browser this is the `window.document`.

  @abstract
  @returns {ui/DOMElement} the root element
 */
DOMElement.prototype.getRoot = function getRoot () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Get the ownerDocument of this element.

  @abstract
  @returns {ui/DOMElement} the document element
*/
DOMElement.prototype.getOwnerDocument = function getOwnerDocument () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Find the first descendant element matching the given CSS selector.
  Note this differs from jQuery.find() that it returns only one element.

  **Attention**
  This method is currently not implemented for {ui/VirtualElement}.
  This means you can use it only in importer implementations, but not in render or exporter implementations.

  @abstract
  @param {String} cssSelector
  @returns {ui/DOMElement} found element
 */
DOMElement.prototype.find = function find (cssSelector) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Find all descendant elements matching the given CSS selector.

  **Attention**
  This method is currently not implemented for {ui/VirtualElement}.
  This means you can use it only in importer implementations, but not in render or exporter implementations.

  @abstract
  @param {String} cssSelector
  @returns {Array<ui/DOMElement>} found elements
 */
DOMElement.prototype.findAll = function findAll (cssSelector) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Append a child element.

  @param {DOMElement|String} child An element or text to append
  @returns {this}
 */
DOMElement.prototype.append = function append (child) {
  var children;
  if (arguments.length === 1) {
    if (isArray(child)) {
      children = child;
    } else {
      this.appendChild(child);
      return this
    }
  } else {
    children = arguments;
  }
  if (children) {
    Array.prototype.forEach.call(children, this.appendChild.bind(this));
  }
  return this
};

DOMElement.prototype.appendChild = function appendChild (child) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Insert a child element at a given position.

  @abstract
  @param {Number} pos insert position
  @param {ui/DOMElement|String} child The child element or text to insert.
  @returns {this}
*/
DOMElement.prototype.insertAt = function insertAt (pos, child) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.insertBefore = function insertBefore (newChild, before) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Remove the child at a given position.

  @abstract
  @param {Number} pos
  @returns {this}
*/
DOMElement.prototype.removeAt = function removeAt (pos) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.removeChild = function removeChild (child) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.replaceChild = function replaceChild (oldChild, newChild) { // eslint-disable-line no-unused-vars
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

/**
  Removes this element from its parent.
  @returns {this}
*/
DOMElement.prototype.remove = function remove () {
  var parent = this.getParent();
  if (parent) {
    parent.removeChild(this);
  }
};

/**
  Removes all child nodes from this element.

  @abstract
  @returns {this}
*/
DOMElement.prototype.empty = function empty () {
  /* istanbul ignore next */
  throw new Error(NOT_IMPLEMENTED)
};

DOMElement.prototype.serialize = function serialize () {
  return this.getOuterHTML()
};

DOMElement.prototype.isInDocument = function isInDocument () {
  var el = this;
  while(el) {
    if (el.isDocumentNode()) {
      return true
    }
    el = el.getParent();
  }
};

/**
  Focusses this element.

  **Attention: this makes only sense for elements which are rendered in the browser**

*/
DOMElement.prototype.focus = function focus () {
  return this
};

/**
  Blur this element.
*/
DOMElement.prototype.blur = function blur () {
  return this
};

/**
  Trigger a click event on this element.
*/
DOMElement.prototype.click = function click () {
  return this
};

/* API to retrieve layout information */

DOMElement.prototype.getWidth = function getWidth () {
  return 0
};

DOMElement.prototype.getHeight = function getHeight () {
  return 0
};

/**
  Outer height as provided by $.outerHeight(withMargin)
*/
DOMElement.prototype.getOuterHeight = function getOuterHeight (withMargin) { // eslint-disable-line no-unused-vars
  return 0
};

/**
  Offset values as provided by $.offset()
*/
DOMElement.prototype.getOffset = function getOffset () {
  return { top: 0, left: 0 }
};

/**
  Position values as provided by $.position()
*/
DOMElement.prototype.getPosition = function getPosition () {
  return { top: 0, left: 0 }
};

/**
  Get element factory conveniently

  @example

  var $$ = el.getElementFactory()
  $$('div').append('bla')
*/
DOMElement.prototype.getElementFactory = function getElementFactory () {
  return this.createElement.bind(this)
};

// properties

prototypeAccessors$4.id.get = function () {
  return this.getId()
};

prototypeAccessors$4.id.set = function (id) {
  this.setId(id);
};

prototypeAccessors$4.tagName.get = function () {
  return this.getTagName()
};

prototypeAccessors$4.tagName.set = function (tagName) {
  this.setTagName(tagName);
};

prototypeAccessors$4.nodeName.get = function () {
  return this.getTagName()
};

prototypeAccessors$4.nodeType.get = function () {
  return this.getNodeType()
};

prototypeAccessors$4.className.get = function () {
  return this.getAttribute('class')
};

prototypeAccessors$4.className.set = function (className) {
  this.setAttribute('class', className);
};

prototypeAccessors$4.textContent.get = function () {
  return this.getTextContent()
};

prototypeAccessors$4.textContent.set = function (text) {
  this.setTextContent(text);
};

prototypeAccessors$4.innerHTML.get = function () {
  return this.getInnerHTML()
};

prototypeAccessors$4.innerHTML.set = function (html) {
  this.setInnerHTML(html);
};

prototypeAccessors$4.outerHTML.get = function () {
  return this.getOuterHTML()
};

prototypeAccessors$4.firstChild.get = function () {
  return this.getFirstChild()
};

prototypeAccessors$4.lastChild.get = function () {
  return this.getLastChild()
};

prototypeAccessors$4.nextSibling.get = function () {
  return this.getNextSibling()
};

prototypeAccessors$4.previousSibling.get = function () {
  return this.getPreviousSibling()
};

prototypeAccessors$4.parentNode.get = function () {
  return this.getParent()
};

prototypeAccessors$4.height.get = function () {
  return this.getHeight()
};

prototypeAccessors$4.width.get = function () {
  return this.getWidth()
};

Object.defineProperties( DOMElement.prototype, prototypeAccessors$4 );

DOMElement.prototype._isDOMElement = true;

DOMElement.pxStyles = {
  top: true,
  bottom: true,
  left: true,
  right: true,
  height: true,
  width: true
};

DOMElement.EMPTY_HTML = '<html><head></head><body></body></html>';

function findIndex(arr, predicate) {
  if (!isFunction$2(predicate)) { return arr.indexOf(predicate) }
  for (var i = 0; i < arr.length; i++) {
    if (predicate(arr[i])) { return i }
  }
  return -1
}

/*
  Internal implementation used to store event bindings.
*/
var DOMEventListener = function DOMEventListener(eventName, handler, options) {
  if (!isString(eventName) || !isFunction$2(handler)) {
    throw new Error("Illegal arguments: 'eventName' must be a String, and 'handler' must be a Function.")
  }
  options = options || {};
  var origHandler = handler;
  var context = options.context;
  var capture = Boolean(options.capture);

  if (context) {
    handler = handler.bind(context);
  }
  if (options.once === true) {
    handler = _once(this, handler);
  }

  this.eventName = eventName;
  this.originalHandler = origHandler;
  this.handler = handler;
  this.capture = capture;
  this.context = context;
  this.options = options;
  // set when this gets attached to a DOM element
  this._el = null;
};

DOMEventListener.prototype._isDOMEventListener = true;

DOMEventListener.findIndex = function(eventListeners, eventName, handler) {
  var idx = -1;
  if (arguments[1]._isDOMEventListener) {
    idx = eventListeners.indexOf(arguments[1]);
  } else {
    idx = findIndex(eventListeners,
      _matches.bind(null, {
        eventName: eventName,
        originalHandler: handler
      })
    );
  }
  return idx
};

function _matches(l1, l2) {
  return l1.eventName === l2.eventName && l1.originalHandler === l2.originalHandler
}

function _once(listener, handler) {
  return function(event) {
    handler(event);
    listener._el.removeEventListener(listener);
  }
}

/**
  A virtual {@link DOMElement} which is used by the {@link Component} API.

  A VirtualElement is just a description of a DOM structure. It represents a virtual
  DOM mixed with Components. This virtual structure needs to be compiled to a {@link Component}
  to actually create a real DOM element, which is done by {@link RenderingEngine}
*/
var VirtualElement = (function (DOMElement$$1) {
  function VirtualElement(owner) {
    DOMElement$$1.call(this);

    // set when this gets inserted into another virtual element
    this.parent = null;
    // set when created by RenderingContext
    this._owner = owner;
    // set when ref'd
    this._ref = null;
  }

  if ( DOMElement$$1 ) VirtualElement.__proto__ = DOMElement$$1;
  VirtualElement.prototype = Object.create( DOMElement$$1 && DOMElement$$1.prototype );
  VirtualElement.prototype.constructor = VirtualElement;

  var prototypeAccessors = { childNodes: {} };

  VirtualElement.prototype.getParent = function getParent () {
    return this.parent
  };

  prototypeAccessors.childNodes.get = function () {
    return this.getChildNodes()
  };

  /*
    Provides the component after this VirtualElement has been rendered.
  */
  VirtualElement.prototype.getComponent = function getComponent () {
    return this._comp
  };

  /**
    Associates a reference identifier with this element.

    When rendered the corresponding component is stored in the owner using the given key.
    In addition to that, components with a reference are preserved when its parent is rerendered.

    > Attention: only the owner should use this method, as it only
      affects the owner's references

    @param {String} ref id for the compiled Component
  */
  VirtualElement.prototype.ref = function ref (ref$1) {
    if (!ref$1) { throw new Error('Illegal argument') }
    /*
      Attention: only the owner can create a ref()
      If you run into this situation, e.g. when you pass down a virtual element
      to a component which wants to have a ref itself,
      then you have other options:

      1. via props:
      ```js
        this.props.content.getComponent()
      ```

      2. via Component.getChildAt or Component.find()
      ```
        this.getChildAt(0)
        this.find('.child')
      ```
    */
    if (this._ref) { throw new Error('A VirtualElement can only be referenced once.') }
    this._ref = ref$1;
    if (this._context) {
      var refs = this._context.refs;
      if(refs[ref$1]) {
        throw new Error('An item with reference "'+ref$1+'" already exists.')
      }
      refs[ref$1] = this;
    }
    return this
  };

  VirtualElement.prototype.isInDocument = function isInDocument () {
    return false
  };

  Object.defineProperties( VirtualElement.prototype, prototypeAccessors );

  return VirtualElement;
}(DOMElement));

VirtualElement.prototype._isVirtualElement = true;

/*
  A virtual HTML element.

  @private
  @class VirtualElement.VirtualHTMLElement
  @extends ui/VirtualElement
*/
var VirtualHTMLElement = (function (VirtualElement) {
  function VirtualHTMLElement(tagName) {
    VirtualElement.call(this);

    this._tagName = tagName;
    this.classNames = null;
    this.attributes = null;
    this.htmlProps = null;
    this.style = null;
    this.eventListeners = null;

    // TODO: this is semantically incorrect. It should be named childNodes
    this.children = [];
  }

  if ( VirtualElement ) VirtualHTMLElement.__proto__ = VirtualElement;
  VirtualHTMLElement.prototype = Object.create( VirtualElement && VirtualElement.prototype );
  VirtualHTMLElement.prototype.constructor = VirtualHTMLElement;

  VirtualHTMLElement.prototype.getTagName = function getTagName () {
    return this._tagName
  };

  VirtualHTMLElement.prototype.setTagName = function setTagName (tagName) {
    this._tagName = tagName;
    return this
  };

  VirtualHTMLElement.prototype.hasClass = function hasClass (className) {
    if (this.classNames) {
      return this.classNames.indexOf(className) > -1
    }
    return false
  };

  VirtualHTMLElement.prototype.addClass = function addClass (className) {
    if (!this.classNames) {
      this.classNames = [];
    }
    this.classNames.push(className);
    return this
  };

  VirtualHTMLElement.prototype.removeClass = function removeClass (className) {
    if (this.classNames) {
      this.classNames = without(this.classNames, className);
    }
    return this
  };

  VirtualHTMLElement.prototype.removeAttribute = function removeAttribute (name) {
    if (this.attributes) {
      delete this.attributes[name];
    }
    return this
  };

  VirtualHTMLElement.prototype.getAttribute = function getAttribute (name) {
    if (this.attributes) {
      return this.attributes[name]
    }
  };

  VirtualHTMLElement.prototype.setAttribute = function setAttribute (name, value) {
    if (!this.attributes) {
      this.attributes = {};
    }
    this.attributes[name] = value;
    return this
  };

  VirtualHTMLElement.prototype.getAttributes = function getAttributes () {
    // we are having separated storages for differet
    // kind of attributes which we now pull together
    // in the same way as a native DOM element has it
    var attributes = {};
    if (this.attributes) {
      extend(attributes, this.attributes);
    }
    if (this.classNames) {
      attributes.class = this.classNames.join(' ');
    }
    if (this.style) {
      attributes.style = map(this.style, function(val, key) {
        return key + ":" + val
      }).join(';');
    }
    return attributes
  };

  VirtualHTMLElement.prototype.getId = function getId () {
    return this.getAttribute('id')
  };

  VirtualHTMLElement.prototype.setId = function setId (id) {
    this.setAttribute('id', id);
    return this
  };

  VirtualHTMLElement.prototype.setTextContent = function setTextContent (text) {
    if (!isString(text)) { throw new Error('Illegal argument: expecting a string.') }
    text = text || '';
    this.empty();
    this.appendChild(text);
    return this
  };

  VirtualHTMLElement.prototype.setInnerHTML = function setInnerHTML (html) {
    html = html || '';
    this.empty();
    this._innerHTMLString = html;
    return this
  };

  VirtualHTMLElement.prototype.getInnerHTML = function getInnerHTML () {
    if (!this.hasOwnProperty('_innerHTMLString')) {
      throw new Error('Not supported.')
    } else {
      return this._innerHTMLString
    }
  };

  VirtualHTMLElement.prototype.getValue = function getValue () {
    return this.htmlProp('value')
  };

  VirtualHTMLElement.prototype.setValue = function setValue (value) {
    this.htmlProp('value', value);
    return this
  };

  VirtualHTMLElement.prototype.getChildNodes = function getChildNodes () {
    return this.children
  };

  VirtualHTMLElement.prototype.getChildren = function getChildren () {
    return this.children.filter(function(child) {
      return child.getNodeType() !== "text"
    })
  };

  VirtualHTMLElement.prototype.isTextNode = function isTextNode () {
    return false
  };

  VirtualHTMLElement.prototype.isElementNode = function isElementNode () {
    return true
  };

  VirtualHTMLElement.prototype.isCommentNode = function isCommentNode () {
    return false
  };

  VirtualHTMLElement.prototype.isDocumentNode = function isDocumentNode () {
    return false
  };

  VirtualHTMLElement.prototype.append = function append () {
    if (this._innerHTMLString) {
      throw Error('It is not possible to mix $$.html() with $$.append(). You can call $$.empty() to reset this virtual element.')
    }
    this._append(this.children, arguments);
    return this
  };

  VirtualHTMLElement.prototype.appendChild = function appendChild (child) {
    if (this._innerHTMLString) {
      throw Error('It is not possible to mix $$.html() with $$.append(). You can call $$.empty() to reset this virtual element.')
    }
    this._appendChild(this.children, child);
    return this
  };

  VirtualHTMLElement.prototype.insertAt = function insertAt (pos, child) {
    child = this._normalizeChild(child);
    if (!child) {
      throw new Error('Illegal child: ' + child)
    }
    if (!child._isVirtualElement) {
      throw new Error('Illegal argument for $$.insertAt():' + child)
    }
    if (pos < 0 || pos > this.children.length) {
      throw new Error('insertAt(): index out of bounds.')
    }
    this._insertAt(this.children, pos, child);
    return this
  };

  VirtualHTMLElement.prototype.insertBefore = function insertBefore (child, before) {
    var pos = this.children.indexOf(before);
    if (pos > -1) {
      this.insertAt(pos, child);
    } else {
      throw new Error('insertBefore(): reference node is not a child of this element.')
    }
    return this
  };

  VirtualHTMLElement.prototype.removeAt = function removeAt (pos) {
    if (pos < 0 || pos >= this.children.length) {
      throw new Error('removeAt(): Index out of bounds.')
    }
    this._removeAt(pos);
    return this
  };

  VirtualHTMLElement.prototype.removeChild = function removeChild (child) {
    if (!child || !child._isVirtualElement) {
      throw new Error('removeChild(): Illegal arguments. Expecting a CheerioDOMElement instance.')
    }
    var idx = this.children.indexOf(child);
    if (idx < 0) {
      throw new Error('removeChild(): element is not a child.')
    }
    this.removeAt(idx);
    return this
  };

  VirtualHTMLElement.prototype.replaceChild = function replaceChild (oldChild, newChild) {
    if (!newChild || !oldChild ||
        !newChild._isVirtualElement || !oldChild._isVirtualElement) {
      throw new Error('replaceChild(): Illegal arguments. Expecting BrowserDOMElement instances.')
    }
    var idx = this.children.indexOf(oldChild);
    if (idx < 0) {
      throw new Error('replaceChild(): element is not a child.')
    }
    this.removeAt(idx);
    this.insertAt(idx, newChild);
    return this
  };

  VirtualHTMLElement.prototype.empty = function empty () {
    var children = this.children;
    while (children.length) {
      var child = children.pop();
      child.parent = null;
    }
    delete this._innerHTMLString;
    return this
  };

  VirtualHTMLElement.prototype.getProperty = function getProperty (name) {
    if (this.htmlProps) {
      return this.htmlProps[name]
    }
  };

  VirtualHTMLElement.prototype.setProperty = function setProperty (name, value) {
    if (!this.htmlProps) {
      this.htmlProps = {};
    }
    this.htmlProps[name] = value;
    return this
  };

  VirtualHTMLElement.prototype.removeProperty = function removeProperty (name) {
    if (this.htmlProps) {
      delete this.htmlProps[name];
    }
    return this
  };

  VirtualHTMLElement.prototype.getStyle = function getStyle (name) {
    if (this.style) {
      return this.style[name]
    }
  };

  VirtualHTMLElement.prototype.setStyle = function setStyle (name, value) {
    if (!this.style) {
      this.style = {};
    }
    if (DOMElement.pxStyles[name] && isNumber(value)) { value = value + 'px'; }
    this.style[name] = value;
    return this
  };

  VirtualHTMLElement.prototype.addEventListener = function addEventListener (eventName, handler, options) {
    var listener;
    if (arguments.length === 1 && arguments[0]._isDOMEventListener) {
      listener = arguments[0];
    } else {
      options = options || {};
      options.context = options.context || this._owner._comp;
      listener = new DOMEventListener(eventName, handler, options);
    }
    if (!this.eventListeners) {
      this.eventListeners = [];
    }
    this.eventListeners.push(listener);
    return this
  };

  VirtualHTMLElement.prototype.removeEventListener = function removeEventListener (eventName, handler) {
    if (this.eventListeners) {
      DOMElement._findEventListenerIndex(this.eventListeners, eventName, handler);
    }
    return this
  };

  VirtualHTMLElement.prototype.getEventListeners = function getEventListeners () {
    return this.eventListeners
  };

  VirtualHTMLElement.prototype.getNodeType = function getNodeType () {
    return "element"
  };

  VirtualHTMLElement.prototype.hasInnerHTML = function hasInnerHTML () {
    return Boolean(this._innerHTMLString)
  };

  VirtualHTMLElement.prototype._normalizeChild = function _normalizeChild (child) {
    if (isString(child)) {
      child = new VirtualTextNode(child);
    }
    return child
  };

  VirtualHTMLElement.prototype._append = function _append (outlet, args) {
    if (args.length === 1 && !isArray(args[0])) {
      this._appendChild(outlet, args[0]);
      return
    }
    var children;
    if (isArray(args[0])) {
      children = args[0];
    } else if (arguments.length > 1) {
      children = Array.prototype.slice.call(args,0);
    } else {
      return
    }
    children.forEach(this._appendChild.bind(this, outlet));
  };

  VirtualHTMLElement.prototype._appendChild = function _appendChild (outlet, child) {
    child = this._normalizeChild(child);
    // TODO: discuss. Having a bad feeling about this,
    // because it could obscure an implementation error
    if (!child) { return }
    outlet.push(child);
    this._attach(child);
    return child
  };

  VirtualHTMLElement.prototype._insertAt = function _insertAt (outlet, pos, child) {
    if (!child) { return }
    outlet.splice(pos, 0, child);
    this._attach(child);
  };

  VirtualHTMLElement.prototype._removeAt = function _removeAt (outlet, pos) {
    var child = outlet[pos];
    outlet.splice(pos, 1);
    this._detach(child);
  };

  VirtualHTMLElement.prototype._attach = function _attach (child) {
    child.parent = this;
    if (this._context && child._owner !== this._owner && child._ref) {
      this._context.foreignRefs[child._ref] = child;
    }
  };

  VirtualHTMLElement.prototype._detach = function _detach (child) {
    child.parent = null;
    if (this._context && child._owner !== this._owner && child._ref) {
      delete this.context.foreignRefs[child._ref];
    }
  };

  VirtualHTMLElement.prototype._mergeHTMLConfig = function _mergeHTMLConfig (other) {
    if (other.classNames) {
      if (!this.classNames) {
        this.classNames = [];
      }
      this.classNames = this.classNames.concat(other.classNames);
    }
    if (other.attributes) {
      if (!this.attributes) {
        this.attributes = {};
      }
      extend(this.attributes, other.attributes);
    }
    if (other.htmlProps) {
      if (!this.htmlProps) {
        this.htmlProps = {};
      }
      extend(this.htmlProps, other.htmlProps);
    }
    if (other.style) {
      if (!this.style) {
        this.style = {};
      }
      extend(this.style, other.style);
    }
    if (other.eventListeners) {
      if (!this.eventListeners) {
        this.eventListeners = [];
      }
      this.eventListeners = this.eventListeners.concat(other.eventListeners);
    }
  };

  return VirtualHTMLElement;
}(VirtualElement));

VirtualHTMLElement.prototype._isVirtualHTMLElement = true;


/*
  A virtual element which gets rendered by a custom component.

  @private
  @class VirtualElement.VirtualComponent
  @extends ui/VirtualElement
*/
var VirtualComponent = (function (VirtualHTMLElement) {
  function VirtualComponent(ComponentClass, props) {
    VirtualHTMLElement.call(this);

    props = props || {};

    this.ComponentClass = ComponentClass;
    this.props = props;
    if (!props.children) {
      props.children = [];
    }
    this.children = props.children;
  }

  if ( VirtualHTMLElement ) VirtualComponent.__proto__ = VirtualHTMLElement;
  VirtualComponent.prototype = Object.create( VirtualHTMLElement && VirtualHTMLElement.prototype );
  VirtualComponent.prototype.constructor = VirtualComponent;

  var prototypeAccessors$1 = { _isVirtualComponent: {} };

  prototypeAccessors$1._isVirtualComponent.get = function () { return true; };

  VirtualComponent.prototype.getComponent = function getComponent () {
    return this._comp
  };

  // Note: for VirtualComponentElement we put children into props
  // so that the render method of ComponentClass can place it.
  VirtualComponent.prototype.getChildren = function getChildren () {
    return this.props.children
  };

  VirtualComponent.prototype.getNodeType = function getNodeType () {
    return 'component'
  };

  VirtualComponent.prototype.outlet = function outlet (name) {
    return new Outlet(this, name)
  };

  VirtualComponent.prototype._attach = function _attach (child) {
    child._preliminaryParent = this;
  };

  VirtualComponent.prototype._detach = function _detach (child) {
    child._preliminaryParent = null;
  };

  VirtualComponent.prototype._copyHTMLConfig = function _copyHTMLConfig () {
    return {
      classNames: clone(this.classNames),
      attributes: clone(this.attributes),
      htmlProps: clone(this.htmlProps),
      style: clone(this.style),
      eventListeners: clone(this.eventListeners)
    }
  };

  Object.defineProperties( VirtualComponent.prototype, prototypeAccessors$1 );

  return VirtualComponent;
}(VirtualHTMLElement));

var Outlet = function Outlet(virtualEl, name) {
  this.virtualEl = virtualEl;
  this.name = name;
  Object.freeze(this);
};

Outlet.prototype._getOutlet = function _getOutlet () {
  var outlet = this.virtualEl.props[this.name];
  if (!outlet) {
    outlet = [];
    this.virtualEl.props[this.name] = outlet;
  }
  return outlet
};

Outlet.prototype.append = function append () {
  var outlet = this._getOutlet();
  this.virtualEl._append(outlet, arguments);
  return this
};

Outlet.prototype.empty = function empty () {
  var arr = this.virtualEl.props[this.name];
  arr.forEach(function(el) {
    this._detach(el);
  }.bind(this));
  arr.splice(0, arr.length);
  return this
};


var VirtualTextNode = (function (VirtualElement) {
  function VirtualTextNode(text) {
    VirtualElement.call(this);
    this.text = text;
  }

  if ( VirtualElement ) VirtualTextNode.__proto__ = VirtualElement;
  VirtualTextNode.prototype = Object.create( VirtualElement && VirtualElement.prototype );
  VirtualTextNode.prototype.constructor = VirtualTextNode;

  var prototypeAccessors$2 = { _isVirtualTextNode: {} };

  prototypeAccessors$2._isVirtualTextNode.get = function () { return true; };

  Object.defineProperties( VirtualTextNode.prototype, prototypeAccessors$2 );

  return VirtualTextNode;
}(VirtualElement));

VirtualElement.Component = VirtualComponent;
VirtualElement.TextNode = VirtualTextNode;

/**
  Create a virtual DOM representation which is used by Component
  for differential/reactive rendering.

  @param elementType HTML tag name or Component class
  @param [props] a properties object for Component classes
  @return {VirtualElement} a virtual DOM node

  @example

  Create a virtual DOM Element

  ```
  $$('a').attr({href: './foo'}).addClass('se-nav-item')
  ```

  Create a virtual Component

  ```
  $$(HelloMessage, {name: 'John'})
  ```
*/
VirtualElement.createElement = function() {
  var content;
  var _first = arguments[0];
  var _second = arguments[1];
  var type;
  if (isString(_first)) {
    type = "element";
  } else if (isFunction$2(_first) && _first.prototype._isComponent) {
    type = "component";
  } else if (isNil(_first)) {
    throw new Error('$$(null): provided argument was null or undefined.')
  } else {
    throw new Error('Illegal usage of $$()')
  }
  // some props are mapped to built-ins
  var props = {};
  var classNames, ref;
  var eventHandlers = [];
  for(var key in _second) {
    if (!_second.hasOwnProperty(key)) { continue }
    var val = _second[key];
    switch(key) {
      case 'class':
        classNames = val;
        break
      case 'ref':
        ref = val;
        break
      default:
        props[key] = val;
    }
  }
  if (type === 'element') {
    content = new VirtualHTMLElement(_first);
    // remaining props are attributes
    // TODO: should we make sure that these are only string values?
    content.attr(props);
  } else {
    content = new VirtualComponent(_first, props);
  }
  // HACK: this is set to the current context by RenderingEngine
  // otherwise this will provide rubbish
  content._owner = this.owner;
  if (classNames) {
    content.addClass(classNames);
  }
  if (ref) {
    content.ref(ref);
  }
  eventHandlers.forEach(function(h) {
    if (isFunction$2(h.handler)) {
      content.on(h.name, h.handler);
    } else if (isPlainObject(h.handler)) {
      var params = h.handler;
      content.on(h.name, params.handler, params.context, params);
    } else {
      throw new Error('Illegal arguments for $$(_,{ on'+h.name+'})')
    }
  });
  // allow a notation similar to React.createElement
  // $$(MyComponent, {}, ...children)
  if (arguments.length > 2) {
    content.append(flattenOften(Array.prototype.slice.call(arguments, 2), 3));
  }
  return content
};

/*
  A wrapper for native DOM events when using event delegation via
  `DOMElement.on(eventName, selector, handler)`.

  @param [Component] owner
  @param [Element] selectedTarget native DOM element
  @param [Event] originalEvent native DOM event
*/
var DelegatedEvent = function DelegatedEvent(owner, selectedTarget, originalEvent) {
  this.owner = owner;
  this.target = selectedTarget;
  this.originalEvent = originalEvent;
};

DelegatedEvent.delegatedHandler = function(listener, top) {
  var handler = listener.handler;
  var context = listener.context;
  var selector = listener.options.selector;
  return function(event) {
    var el = DOMElement.wrap(event.target);
    while(el) {
      if (el.is(selector)) {
        handler(new DelegatedEvent(context, event.target, event));
        break
      }
      if (el === top) {
        break
      }
      el = el.parentNode;
    }
  }
};

var BrowserDOMElement = (function (DOMElement$$1) {
  function BrowserDOMElement(el) {
    DOMElement$$1.call(this);
    // wrapping the native element
    console.assert(el instanceof window.Node, "Expecting native DOM node.");
    this.el = el;
    el._wrapper = this;
    // a store for event listeners: necessary so that we can 'reuse' the listener and do reasoning for incremental rendering
    this.eventListeners = [];
    // store for changed properties: unfortunately this is necessary for incremental
    // rerendering, as there seems no way to get a set of changed properties in a general way
    this._changedProperties = new Set();
  }

  if ( DOMElement$$1 ) BrowserDOMElement.__proto__ = DOMElement$$1;
  BrowserDOMElement.prototype = Object.create( DOMElement$$1 && DOMElement$$1.prototype );
  BrowserDOMElement.prototype.constructor = BrowserDOMElement;

  var prototypeAccessors = { childNodes: {},children: {},ownerDocument: {} };

  BrowserDOMElement.prototype.getNativeElement = function getNativeElement () {
    return this.el
  };

  BrowserDOMElement.prototype.hasClass = function hasClass (className) {
    return this.el.classList.contains(className)
  };

  BrowserDOMElement.prototype.addClass = function addClass (className) {
    this.el.classList.add(className);
    return this
  };

  BrowserDOMElement.prototype.removeClass = function removeClass (className) {
    this.el.classList.remove(className);
    return this
  };

  BrowserDOMElement.prototype.getAttribute = function getAttribute (name) {
    return this.el.getAttribute(name)
  };

  BrowserDOMElement.prototype.setAttribute = function setAttribute (name, value) {
    this.el.setAttribute(name, value);
    return this
  };

  BrowserDOMElement.prototype.removeAttribute = function removeAttribute (name) {
    this.el.removeAttribute(name);
    return this
  };

  BrowserDOMElement.prototype.getAttributes = function getAttributes () {
    var result = {};
    var attributes = this.el.attributes;
    var l = attributes.length;
    for(var i=0; i < l; i++) {
      var attr = attributes.item(i);
      result[attr.name] = attr.value;
    }
    return result
  };

  BrowserDOMElement.prototype.getProperties = function getProperties () {
    var this$1 = this;

    var properties = {};
    this._changedProperties.forEach(function (name) {
      properties[name] = this$1.el[name];
    });
    return properties
  };

  BrowserDOMElement.prototype.getProperty = function getProperty (name) {
    return this.el[name]
  };

  BrowserDOMElement.prototype.setProperty = function setProperty (name, value) {
    this._changedProperties.add(name);
    this.el[name] = value;
    return this
  };

  BrowserDOMElement.prototype.removeProperty = function removeProperty (name) {
    this._changedProperties.delete(name);
    delete this.el[name];
    return this
  };

  BrowserDOMElement.prototype.getTagName = function getTagName () {
    if (this.el.tagName) {
      return this.el.tagName.toLowerCase()
    }
  };

  BrowserDOMElement.prototype.setTagName = function setTagName (tagName) {
    var this$1 = this;

    var newEl = this.createElement(tagName);
    var attributes = this.el.attributes;
    var l = attributes.length;
    var i;
    for(i = 0; i < l; i++) {
      var attr = attributes.item(i);
      newEl.setAttribute(attr.name, attr.value);
    }
    this._changedProperties.forEach(function (name){
      newEl[name] = this$1.el[name];
    });
    this.eventListeners.forEach(function(listener) {
      newEl.addEventListener(listener.eventName, listener.handler, listener.capture);
    });

    newEl.append(this.getChildNodes());

    this._replaceNativeEl(newEl.getNativeElement());
    return this
  };

  BrowserDOMElement.prototype.getId = function getId () {
    return this.el.id
  };

  BrowserDOMElement.prototype.setId = function setId (id) {
    this.el.id = id;
    return this
  };

  BrowserDOMElement.prototype.getStyle = function getStyle (name) {
    // NOTE: important to provide computed style, otherwise we don't get inherited styles
    var style = this.getComputedStyle();
    return style[name] || this.el.style[name]
  };

  BrowserDOMElement.prototype.getComputedStyle = function getComputedStyle () {
    return window.getComputedStyle(this.el)
  };

  BrowserDOMElement.prototype.setStyle = function setStyle (name, value) {
    if (DOMElement$$1.pxStyles[name] && isNumber(value)) { value = value + 'px'; }
    this.el.style[name] = value;
    return this
  };

  BrowserDOMElement.prototype.getTextContent = function getTextContent () {
    return this.el.textContent
  };

  BrowserDOMElement.prototype.setTextContent = function setTextContent (text) {
    this.el.textContent = text;
    return this
  };

  BrowserDOMElement.prototype.getInnerHTML = function getInnerHTML () {
    var innerHTML = this.el.innerHTML;
    if (!isString(innerHTML)) {
      var frag = this.el.ownerDocument.createDocumentFragment();
      for (var c = this.el.firstChild; c; c = c.nextSibling) {
        frag.appendChild(c.cloneNode(true));
      }
      var xs = new window.XMLSerializer();
      innerHTML = xs.serializeToString(frag);
    }
    return innerHTML
  };

  BrowserDOMElement.prototype.setInnerHTML = function setInnerHTML (html) {
    this.el.innerHTML = html;
    return this
  };

  BrowserDOMElement.prototype.getOuterHTML = function getOuterHTML () {
    var outerHTML = this.el.outerHTML;
    if (!isString(outerHTML)) {
      var xs = new window.XMLSerializer();
      outerHTML = xs.serializeToString(this.el);
    }
    return outerHTML
  };

  BrowserDOMElement.prototype.addEventListener = function addEventListener (eventName, handler, options) {
    var listener;
    if (arguments.length === 1 && arguments[0]) {
      listener = arguments[0];
    } else {
      listener = new DOMEventListener(eventName, handler, options);
    }
    if (listener.options.selector && !listener.__hasEventDelegation__) {
      listener.handler = DelegatedEvent.delegatedHandler(listener, this.getNativeElement());
      listener.__hasEventDelegation__ = true;
    }
    this.el.addEventListener(listener.eventName, listener.handler, listener.capture);
    this.eventListeners.push(listener);
    listener._el = this;
    return this
  };

  BrowserDOMElement.prototype.removeEventListener = function removeEventListener (eventName, handler) {
    // console.log('removing event listener', eventName, handler);
    var listener = null, idx = -1;
    idx = DOMEventListener.findIndex(this.eventListeners, eventName, handler);
    listener = this.eventListeners[idx];
    if (idx > -1) {
      this.eventListeners.splice(idx, 1);
      // console.log('BrowserDOMElement.removeEventListener:', eventName, this.eventListeners.length);
      listener._el = null;
      this.el.removeEventListener(listener.eventName, listener.handler);
    }
    return this
  };

  BrowserDOMElement.prototype.removeAllEventListeners = function removeAllEventListeners () {
    var this$1 = this;

    for (var i = 0; i < this.eventListeners.length; i++) {
      var listener = this$1.eventListeners[i];
      // console.log('BrowserDOMElement.removeEventListener:', eventName, this.eventListeners.length);
      listener._el = null;
      this$1.el.removeEventListener(listener.eventName, listener.handler);
    }
    this.eventListeners = [];
  };

  BrowserDOMElement.prototype.getEventListeners = function getEventListeners () {
    return this.eventListeners
  };

  BrowserDOMElement.prototype.getChildCount = function getChildCount () {
    return this.el.childNodes.length
  };

  BrowserDOMElement.prototype.getChildNodes = function getChildNodes () {
    var childNodes = [];
    for (var node = this.el.firstChild; node; node = node.nextSibling) {
      childNodes.push(BrowserDOMElement.wrapNativeElement(node));
    }
    return childNodes
  };

  prototypeAccessors.childNodes.get = function () {
    return this.getChildNodes()
  };

  BrowserDOMElement.prototype.getChildren = function getChildren () {
    // Some browsers don't filter elements here and also include text nodes,
    // that why we can't use el.children
    var children = [];
    for (var node = this.el.firstChild; node; node = node.nextSibling) {
      if (node.nodeType === window.Node.ELEMENT_NODE) {
        children.push(BrowserDOMElement.wrapNativeElement(node));
      }
    }
    return children
  };

  prototypeAccessors.children.get = function () {
    return this.getChildren()
  };

  BrowserDOMElement.prototype.getChildAt = function getChildAt (pos) {
    return BrowserDOMElement.wrapNativeElement(this.el.childNodes[pos])
  };

  BrowserDOMElement.prototype.getChildIndex = function getChildIndex (child) {
    if (!child._isBrowserDOMElement) {
      throw new Error('Expecting a BrowserDOMElement instance.')
    }
    return Array.prototype.indexOf.call(this.el.childNodes, child.el)
  };

  BrowserDOMElement.prototype.getFirstChild = function getFirstChild () {
    var firstChild = this.el.firstChild;
    if (firstChild) {
      return BrowserDOMElement.wrapNativeElement(firstChild)
    } else {
      return null
    }
  };

  BrowserDOMElement.prototype.getLastChild = function getLastChild () {
    var lastChild = this.el.lastChild;
    if (lastChild) {
      return BrowserDOMElement.wrapNativeElement(lastChild)
    } else {
      return null
    }
  };

  BrowserDOMElement.prototype.getNextSibling = function getNextSibling () {
    var next = this.el.nextSibling;
    if (next) {
      return BrowserDOMElement.wrapNativeElement(next)
    } else {
      return null
    }
  };

  BrowserDOMElement.prototype.getPreviousSibling = function getPreviousSibling () {
    var previous = this.el.previousSibling;
    if (previous) {
      return BrowserDOMElement.wrapNativeElement(previous)
    } else {
      return null
    }
  };

  BrowserDOMElement.prototype.isTextNode = function isTextNode () {
    return (this.el.nodeType === window.Node.TEXT_NODE)
  };

  BrowserDOMElement.prototype.isElementNode = function isElementNode () {
    return (this.el.nodeType === window.Node.ELEMENT_NODE)
  };

  BrowserDOMElement.prototype.isCommentNode = function isCommentNode () {
    return (this.el.nodeType === window.Node.COMMENT_NODE)
  };

  BrowserDOMElement.prototype.isDocumentNode = function isDocumentNode () {
    return (this.el.nodeType === window.Node.DOCUMENT_NODE)
  };

  BrowserDOMElement.prototype.clone = function clone () {
    var clone = this.el.cloneNode(true);
    return BrowserDOMElement.wrapNativeElement(clone)
  };

  BrowserDOMElement.prototype.createDocument = function createDocument (format) {
    return BrowserDOMElement.createDocument(format)
  };

  BrowserDOMElement.prototype.createElement = function createElement (tagName) {
    var doc = this._getNativeOwnerDocument();
    var el = doc.createElement(tagName);
    return BrowserDOMElement.wrapNativeElement(el)
  };

  BrowserDOMElement.prototype.createTextNode = function createTextNode (text) {
    var doc = this._getNativeOwnerDocument();
    var el = doc.createTextNode(text);
    return BrowserDOMElement.wrapNativeElement(el)
  };

  BrowserDOMElement.prototype.createComment = function createComment (data) {
    var doc = this._getNativeOwnerDocument();
    var el = doc.createComment(data);
    return BrowserDOMElement.wrapNativeElement(el)
  };

  BrowserDOMElement.prototype.createProcessingInstruction = function createProcessingInstruction (name, data) {
    var doc = this._getNativeOwnerDocument();
    var el = doc.createProcessingInstruction(name, data);
    return BrowserDOMElement.wrapNativeElement(el)
  };

  BrowserDOMElement.prototype.createCDATASection = function createCDATASection (data) {
    var doc = this._getNativeOwnerDocument();
    var el = doc.createCDATASection(data);
    return BrowserDOMElement.wrapNativeElement(el)
  };

  BrowserDOMElement.prototype.is = function is (cssSelector) {
    // ATTENTION: looking at https://developer.mozilla.org/en/docs/Web/API/Element/matches
    // Element.matches might not be supported by some mobile browsers
    var el = this.el;
    if (this.isElementNode()) {
      return matches(el, cssSelector)
    } else {
      return false
    }
  };

  BrowserDOMElement.prototype.getParent = function getParent () {
    var parent = this.el.parentNode;
    if (parent) {
      return BrowserDOMElement.wrapNativeElement(parent)
    } else {
      return null
    }
  };

  BrowserDOMElement.prototype.getRoot = function getRoot () {
    var el = this.el;
    var parent = el;
    while (parent) {
      el = parent;
      parent = el.parentNode;
    }
    return BrowserDOMElement.wrapNativeElement(el)
  };

  BrowserDOMElement.prototype.getOwnerDocument = function getOwnerDocument () {
    return BrowserDOMElement.wrapNativeElement(this._getNativeOwnerDocument())
  };

  prototypeAccessors.ownerDocument.get = function () {
    return this.getOwnerDocument()
  };

  BrowserDOMElement.prototype._getNativeOwnerDocument = function _getNativeOwnerDocument () {
    return (this.isDocumentNode() ? this.el : this.el.ownerDocument)
  };

  BrowserDOMElement.prototype.find = function find (cssSelector) {
    var result = null;
    if (this.el.querySelector) {
      result = this.el.querySelector(cssSelector);
    }
    if (result) {
      return BrowserDOMElement.wrapNativeElement(result)
    } else {
      return null
    }
  };

  BrowserDOMElement.prototype.findAll = function findAll (cssSelector) {
    var result = [];
    if (this.el.querySelectorAll) {
      result = this.el.querySelectorAll(cssSelector);
    }
    return Array.prototype.map.call(result, function(el) {
      return BrowserDOMElement.wrapNativeElement(el)
    })
  };

  BrowserDOMElement.prototype._normalizeChild = function _normalizeChild (child) {
    if (child instanceof window.Node) {
      if (!child._wrapper) {
        child = BrowserDOMElement.wrapNativeElement(child);
      } else {
        return child
      }
    }
    if (isString(child) || isNumber(child)) {
      child = this.createTextNode(child);
    }
    if (!child || !child._isBrowserDOMElement) {
      throw new Error('Illegal child type.')
    }
    // HACK: I thought it isn't possible to create
    // a BrowserDOMElement instance without having this
    // done already
    if (!child.el._wrapper) {
      child.el._wrapper = child;
    }
    console.assert(child.el._wrapper === child, "The backlink to the wrapper should be consistent");
    return child.getNativeElement()
  };

  BrowserDOMElement.prototype.appendChild = function appendChild (child) {
    var nativeChild = this._normalizeChild(child);
    this.el.appendChild(nativeChild);
    return this
  };

  BrowserDOMElement.prototype.insertAt = function insertAt (pos, child) {
    var nativeChild = this._normalizeChild(child);
    var childNodes = this.el.childNodes;
    if (pos >= childNodes.length) {
      this.el.appendChild(nativeChild);
    } else {
      this.el.insertBefore(nativeChild, childNodes[pos]);
    }
    return this
  };

  BrowserDOMElement.prototype.insertBefore = function insertBefore (child, before) {
    if (!before || !before._isBrowserDOMElement) {
      throw new Error('insertBefore(): Illegal arguments. "before" must be a BrowserDOMElement instance.')
    }
    var nativeChild = this._normalizeChild(child);
    this.el.insertBefore(nativeChild, before.el);
    return this
  };

  BrowserDOMElement.prototype.removeAt = function removeAt (pos) {
    this.el.removeChild(this.el.childNodes[pos]);
    return this;
  };

  BrowserDOMElement.prototype.removeChild = function removeChild (child) {
    if (!child || !child._isBrowserDOMElement) {
      throw new Error('removeChild(): Illegal arguments. Expecting a BrowserDOMElement instance.')
    }
    this.el.removeChild(child.el);
    return this
  };

  BrowserDOMElement.prototype.replaceChild = function replaceChild (oldChild, newChild) {
    if (!newChild || !oldChild ||
        !newChild._isBrowserDOMElement || !oldChild._isBrowserDOMElement) {
      throw new Error('replaceChild(): Illegal arguments. Expecting BrowserDOMElement instances.')
    }
    // Attention: Node.replaceChild has weird semantics
    this.el.replaceChild(newChild.el, oldChild.el);
    return this
  };

  BrowserDOMElement.prototype.empty = function empty () {
    // http://jsperf.com/empty-an-element/4 suggests that this is the fastest way to
    // clear an element
    var el = this.el;
    while (el.lastChild) {
      el.removeChild(el.lastChild);
    }
    return this
  };

  BrowserDOMElement.prototype.remove = function remove () {
    if (this.el.parentNode) {
      this.el.parentNode.removeChild(this.el);
    }
    return this
  };

  BrowserDOMElement.prototype.serialize = function serialize () {
    var outerHTML = this.el.outerHTML;
    if (isString(outerHTML)) {
      return outerHTML
    } else {
      var xs = new window.XMLSerializer();
      return xs.serializeToString(this.el)
    }
  };

  BrowserDOMElement.prototype.isInDocument = function isInDocument () {
    var el = this.el;
    while(el) {
      if (el.nodeType === window.Node.DOCUMENT_NODE) {
        return true
      }
      el = el.parentNode;
    }
  };

  BrowserDOMElement.prototype._replaceNativeEl = function _replaceNativeEl (newEl) {
    console.assert(newEl instanceof window.Node, "Expecting a native element.");
    var oldEl = this.el;
    var parentNode = oldEl.parentNode;
    if (parentNode) {
      parentNode.replaceChild(newEl, oldEl);
    }
    this.el = newEl;
    // HACK: we need the correct backlink
    this.el._wrapper = this;
  };

  BrowserDOMElement.prototype._getChildNodeCount = function _getChildNodeCount () {
    return this.el.childNodes.length
  };

  BrowserDOMElement.prototype.focus = function focus () {
    this.el.focus();
    return this
  };

  BrowserDOMElement.prototype.blur = function blur () {
    this.el.focus();
    return this
  };

  BrowserDOMElement.prototype.click = function click () {
    this.el.click();
    return this
  };

  BrowserDOMElement.prototype.getWidth = function getWidth () {
    var rect = this.el.getClientRects()[0];
    if (rect) {
      return rect.width
    } else {
      return 0
    }
  };

  BrowserDOMElement.prototype.getHeight = function getHeight () {
    var rect = this.el.getClientRects()[0];
    if (rect) {
      return rect.height
    } else {
      return 0
    }
  };

  BrowserDOMElement.prototype.getOffset = function getOffset () {
    var rect = this.el.getBoundingClientRect();
    return {
      top: rect.top + document.body.scrollTop,
      left: rect.left + document.body.scrollLeft
    }
  };

  BrowserDOMElement.prototype.getPosition = function getPosition () {
    return {left: this.el.offsetLeft, top: this.el.offsetTop}
  };

  BrowserDOMElement.prototype.getOuterHeight = function getOuterHeight (withMargin) {
    var outerHeight = this.el.offsetHeight;
    if (withMargin) {
      var style = this.getComputedStyle();
      outerHeight += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
    }
    return outerHeight
  };

  Object.defineProperties( BrowserDOMElement.prototype, prototypeAccessors );

  return BrowserDOMElement;
}(DOMElement));

BrowserDOMElement.prototype._isBrowserDOMElement = true;

// TODO: flesh out how options should look like (e.g. XML namespaceURI etc.)
BrowserDOMElement.createDocument = function(format) {
  var doc;
  if (format === 'xml') {
    // HACK: didn't find a way to create an empty XML doc without a root element
    doc = window.document.implementation.createDocument(null, 'dummy');
    // remove the
    doc.removeChild(doc.firstChild);
  } else {
    doc = (new window.DOMParser()).parseFromString(DOMElement.EMPTY_HTML, 'text/html');
  }
  return BrowserDOMElement.wrapNativeElement(doc)
};

BrowserDOMElement.createElement = function(tagName) {
  return BrowserDOMElement.wrapNativeElement(
    window.document.createElement(tagName)
  )
};

BrowserDOMElement.createTextNode = function(text) {
  return BrowserDOMElement.wrapNativeElement(
    window.document.createTextNode(text)
  )
};

BrowserDOMElement.parseMarkup = function(str, format, isFullDoc) {
  var nativeEls = [];
  var doc;
  if (!str) {
    return BrowserDOMElement.createDocument(format)
  } else {
    var parser = new window.DOMParser();
    if (format === 'html') {
      isFullDoc = (str.search(/<\s*html/i)>=0);
      doc = parser.parseFromString(str, 'text/html');
    } else if (format === 'xml') {
      doc = parser.parseFromString(str, 'text/xml');
    }
    if (doc) {
      var parserError = doc.querySelector('parsererror');
      if (parserError) {
        throw new Error("ParserError: could not parse " + str)
      }
      if (format === 'html') {
        if (isFullDoc) {
          nativeEls = [doc.querySelector('html')];
        } else {
          // if the provided html is just a partial
          // then DOMParser still creates a full document
          // thus we pick the body and provide its content
          var body = doc.querySelector('body');
          nativeEls = body.childNodes;
        }
      } else if (format === 'xml') {
        if (isFullDoc) {
          nativeEls = [doc];
        } else {
          nativeEls = doc.childNodes;
        }
      }
    } else {
      throw new Error('Could not parse DOM string.')
    }
  }
  var elements = Array.prototype.map.call(nativeEls, function(el) {
    return new BrowserDOMElement(el)
  });
  if (elements.length === 1) {
    return elements[0]
  } else {
    return elements
  }
};

BrowserDOMElement.parseHTML = function(html, isFullDoc) {
  return BrowserDOMElement.parseMarkup(html, 'html', isFullDoc)
};

BrowserDOMElement.parseXML = function(html, isFullDoc) {
  return BrowserDOMElement.parseMarkup(html, 'xml', isFullDoc)
};

var BrowserTextNode = (function (BrowserDOMElement) {
  function BrowserTextNode(nativeEl) {
    BrowserDOMElement.call(this, nativeEl);
    if (!(nativeEl instanceof window.Node) || nativeEl.nodeType !== 3) {
      throw new Error("Expecting native TextNode.")
    }
  }

  if ( BrowserDOMElement ) BrowserTextNode.__proto__ = BrowserDOMElement;
  BrowserTextNode.prototype = Object.create( BrowserDOMElement && BrowserDOMElement.prototype );
  BrowserTextNode.prototype.constructor = BrowserTextNode;
  BrowserTextNode.prototype.getNodeType = function getNodeType () { return 'text' };

  return BrowserTextNode;
}(BrowserDOMElement));

BrowserDOMElement.wrapNativeElement = function(el) {
  if (el) {
    if (el._wrapper) {
      return el._wrapper
    } else if (el instanceof window.Node) {
      if (el.nodeType === 3) {
        return new BrowserTextNode(el)
      } else {
        return new BrowserDOMElement(el)
      }
    } else if (el === window) {
      return BrowserDOMElement.getBrowserWindow()
    }
  } else {
    return null
  }
};

/*
  Wrapper for the window element exposing DOMElement's EventListener API.
*/
var BrowserWindow = function BrowserWindow() {
  // Note: not
  this.el = window;
  window.__BrowserDOMElementWrapper__ = this;
  this.eventListeners = [];
};

BrowserWindow.prototype.on = BrowserDOMElement.prototype.on;

BrowserWindow.prototype.off = BrowserDOMElement.prototype.off;

BrowserWindow.prototype.addEventListener = BrowserDOMElement.prototype.addEventListener;

BrowserWindow.prototype.removeEventListener = BrowserDOMElement.prototype.removeEventListener;

BrowserWindow.prototype.getEventListeners = BrowserDOMElement.prototype.getEventListeners;

BrowserDOMElement.getBrowserWindow = function() {
  if (window.__BrowserDOMElementWrapper__) { return window.__BrowserDOMElementWrapper__ }
  return new BrowserWindow(window)
};

BrowserDOMElement.isReverse = function(anchorNode, anchorOffset, focusNode, focusOffset) {
  // the selection is reversed when the focus propertyEl is before
  // the anchor el or the computed charPos is in reverse order
  if (focusNode && anchorNode) {
    if (!BrowserDOMElement.isReverse._r1) {
      BrowserDOMElement.isReverse._r1 = window.document.createRange();
      BrowserDOMElement.isReverse._r2 = window.document.createRange();
    }
    var _r1 = BrowserDOMElement.isReverse._r1;
    var _r2 = BrowserDOMElement.isReverse._r2;
    _r1.setStart(anchorNode.getNativeElement(), anchorOffset);
    _r2.setStart(focusNode.getNativeElement(), focusOffset);
    var cmp = _r1.compareBoundaryPoints(window.Range.START_TO_START, _r2);
    if (cmp === 1) {
      return true
    }
  }
  return false
};

BrowserDOMElement.getWindowSelection = function() {
  var nativeSel = window.getSelection();
  var result = {
    anchorNode: BrowserDOMElement.wrapNativeElement(nativeSel.anchorNode),
    anchorOffset: nativeSel.anchorOffset,
    focusNode: BrowserDOMElement.wrapNativeElement(nativeSel.focusNode),
    focusOffset: nativeSel.focusOffset
  };
  return result
};

function matches(el, selector) {
  var elProto = window.Element.prototype;
  var _matches = (
    elProto.matches || elProto.matchesSelector ||
    elProto.msMatchesSelector || elProto.webkitMatchesSelector
  );
  return _matches.call(el, selector)
}

//Types of elements found in the DOM
var index = {
	Text: "text", //Text
	Directive: "directive", //<? ... ?>
	Comment: "comment", //<!-- ... -->
	Script: "script", //<script> tags
	Style: "style", //<style> tags
	Tag: "tag", //Any tag
	CDATA: "cdata", //<![CDATA[ ... ]]>
	Doctype: "doctype",

	isTag: function(elem){
		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
	}
};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var entities = {};

var _resolve_empty = Object.freeze({
	default: entities
});

/*
  Implementation essentially stolen from domhandler and adapted to work with XNode.

  Attention: as this is used as a global replacement of the 'dom-serializer' package
  this file can not be used directly.
*/

var booleanAttributes = {
  __proto__: null,
  allowfullscreen: true,
  async: true,
  autofocus: true,
  autoplay: true,
  checked: true,
  controls: true,
  default: true,
  defer: true,
  disabled: true,
  hidden: true,
  ismap: true,
  loop: true,
  multiple: true,
  muted: true,
  open: true,
  readonly: true,
  required: true,
  reversed: true,
  scoped: true,
  seamless: true,
  selected: true,
  typemustmatch: true
};

var unencodedElements = {
  __proto__: null,
  style: true,
  script: true,
  xmp: true,
  iframe: true,
  noembed: true,
  noframes: true,
  plaintext: true,
  noscript: true
};

var singleTag = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
};

function formatAttribs(el, opts) {
  var output = [];
  var attributes = el.attributes;
  // Loop through the attributes
  attributes.forEach(function (value, key) {
    // as 'class' and 'style' are computed dynamically we need to check if there are any values set
    // otherwise this will generate empty attributes
    if (key === 'class' && el.classes.size === 0) { return }
    if (key === 'style' && el.styles.size === 0) { return }
    if (!value && booleanAttributes[key]) {
      output.push(key);
    } else {
      output.push(key + '="' + (opts.decodeEntities ? entities.encodeXML(value) : value) + '"');
    }
  });
  if (el.classes.size > 0) {
    output.push('class="'+el.getAttribute('class')+'"');
  }
  if (el.styles.size >0) {
    output.push('style="'+el.getAttribute('style')+'"');
  }
  return output.join(' ')
}

function render(dom, opts) {
  if (!Array.isArray(dom)) { dom = [dom]; }
  opts = opts || {};

  var output = [];

  for(var i = 0; i < dom.length; i++){
    var elem = dom[i];

    if (elem.type === 'root') {
      output.push(render(elem.childNodes, opts));
    } else if (index.isTag(elem)) {
      output.push(renderTag(elem, opts));
    } else if (elem.type === index.Directive) {
      output.push(renderDirective(elem));
    } else if (elem.type === index.Comment) {
      output.push(renderComment(elem));
    } else if (elem.type === index.CDATA) {
      output.push(renderCdata(elem));
    } else {
      output.push(renderText(elem, opts));
    }
  }

  return output.join('')
}

function renderTag(elem, opts) {
  // Handle SVG
  if (elem.name === "svg") { opts = {decodeEntities: opts.decodeEntities, xmlMode: true}; }

  var tag = '<' + elem.name;
  var attribs = formatAttribs(elem, opts);

  if (attribs) {
    tag += ' ' + attribs;
  }

  if (
    opts.xmlMode
    && (!elem.childNodes || elem.childNodes.length === 0)
  ) {
    tag += '/>';
  } else {
    tag += '>';
    if (elem.childNodes) {
      tag += render(elem.childNodes, opts);
    }

    if (!singleTag[elem.name] || opts.xmlMode) {
      tag += '</' + elem.name + '>';
    }
  }

  return tag
}

function renderDirective(elem) {
  return '<' + elem.data + '>'
}

function renderText(elem, opts) {
  var data = elem.data || '';
  // if entities weren't decoded, no need to encode them back
  if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
    data = entities.encodeXML(data);
  }
  return data
}

function renderCdata(elem) {
  return '<![CDATA[' + elem.childNodes[0].data + ']]>'
}

function renderComment(elem) {
  return '<!--' + elem.data + '-->'
}




var _domSerializer = Object.freeze({
	default: render
});

var require$$1 = ( _domSerializer && _domSerializer['default'] ) || _domSerializer;

var ElementType$1 = index;
var getOuterHTML = require$$1;
var isTag$1 = ElementType$1.isTag;

var stringify = {
  getInnerHTML: getInnerHTML,
  getOuterHTML: getOuterHTML,
  getText: getText$1
};

function getInnerHTML(elem, opts){
  return elem.childNodes ? elem.childNodes.map(function(elem){
    return getOuterHTML(elem, opts);
  }).join("") : "";
}

function getText$1(elem){
  if(Array.isArray(elem)) { return elem.map(getText$1).join(""); }
  if(isTag$1(elem) || elem.type === ElementType$1.CDATA) { return getText$1(elem.childNodes); }
  if(elem.type === ElementType$1.Text) { return elem.data; }
  return "";
}

var traversal = createCommonjsModule(function (module, exports) {
var getChildren = exports.getChildren = function(elem){
  return elem.childNodes;
};

var getParent = exports.getParent = function(elem){
  return elem.parent;
};

exports.getSiblings = function(elem){
  var parent = getParent(elem);
  return parent ? getChildren(parent) : [elem];
};

exports.getAttributeValue = function(elem, name){
  return elem.getAttribute(name);
};

exports.hasAttrib = function(elem, name){
  return elem.hasAttribute(name);
};

exports.getName = function(elem){
  return elem.name
};
});

var manipulation = createCommonjsModule(function (module, exports) {
function removeElement(elem){
  if(elem.prev) { elem.prev.next = elem.next; }
  if(elem.next) { elem.next.prev = elem.prev; }
  if(elem.parent){
    var childs = elem.parent.childNodes;
    var pos = childs.lastIndexOf(elem);
    if (pos < 0) { throw new Error('Invalid state') }
    childs.splice(pos, 1);
    elem.parent = null;
  }
}

function replaceElement(elem, replacement){
  if (replacement.parent) { exports.removeElement(replacement); }
  var prev = replacement.prev = elem.prev;
  if(prev){
    prev.next = replacement;
  }

  var next = replacement.next = elem.next;
  if(next){
    next.prev = replacement;
  }

  var parent = replacement.parent = elem.parent;
  if(parent){
    var childs = parent.childNodes;
    var pos = childs.lastIndexOf(elem);
    if (pos < 0) { throw new Error('Invalid state') }
    childs[pos] = replacement;
  }
}

function appendChild(elem, child){
  if (child.parent) { removeElement(child); }
  child.parent = elem;

  if(elem.childNodes.push(child) !== 1){
    var sibling = elem.childNodes[elem.childNodes.length - 2];
    sibling.next = child;
    child.prev = sibling;
    child.next = null;
  }
}

function append(elem, next){
  if (next.parent) { removeElement(next); }
  var parent = elem.parent,
    currNext = elem.next;

  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;

  if(currNext){
    currNext.prev = next;
    if(parent){
      var childs = parent.childNodes;
      var pos = childs.lastIndexOf(currNext);
      if (pos < 0) { throw new Error('Invalid state') }
      childs.splice(pos, 0, next);
    }
  } else if(parent){
    parent.childNodes.push(next);
  }
}

function prepend(elem, prev){
  if (prev.parent) { removeElement(prev); }
  var parent = elem.parent;
  if(parent){
    var childs = parent.childNodes;
    var pos = childs.lastIndexOf(elem);
    if (pos < 0) { throw new Error('Invalid state') }
    childs.splice(pos, 0, prev);
  }

  if(elem.prev){
    elem.prev.next = prev;
  }

  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}

exports.removeElement = removeElement;
exports.replaceElement = replaceElement;
exports.appendChild = appendChild;
exports.append = append;
exports.prepend = prepend;
});

var isTag$2 = index.isTag;

var querying = {
  filter: filter$1,
  find: find,
  findOneChild: findOneChild,
  findOne: findOne$1,
  existsOne: existsOne,
  findAll: findAll$1
};

function filter$1(test, element, recurse, limit){
  if(!Array.isArray(element)) { element = [element]; }

  if(typeof limit !== "number" || !isFinite(limit)){
    limit = Infinity;
  }
  return find(test, element, recurse !== false, limit);
}

function find(test, elems, recurse, limit){
  var result = [], childs;

  for(var i = 0, j = elems.length; i < j; i++){
    if(test(elems[i])){
      result.push(elems[i]);
      if(--limit <= 0) { break; }
    }

    childs = elems[i].childNodes;
    if(recurse && childs && childs.length > 0){
      childs = find(test, childs, recurse, limit);
      result = result.concat(childs);
      limit -= childs.length;
      if(limit <= 0) { break; }
    }
  }

  return result;
}

function findOneChild(test, elems){
  for(var i = 0, l = elems.length; i < l; i++){
    if(test(elems[i])) { return elems[i]; }
  }

  return null;
}

function findOne$1(test, elems){
  var elem = null;

  for(var i = 0, l = elems.length; i < l && !elem; i++){
    var child = elems[i];
    if(!isTag$2(child)){
      continue;
    } else if(test(child)){
      elem = child;
    } else if(child.childNodes.length > 0){
      elem = findOne$1(test, child.childNodes);
    }
  }

  return elem;
}

function existsOne(test, elems){
  for(var i = 0, l = elems.length; i < l; i++){
    if(
      isTag$2(elems[i]) && (
        test(elems[i]) || (
          elems[i].childNodes.length > 0 &&
          existsOne(test, elems[i].childNodes)
        )
      )
    ){
      return true;
    }
  }

  return false;
}

function findAll$1(test, elems){
  var result = [];
  for(var i = 0, j = elems.length; i < j; i++){
    if(!isTag$2(elems[i])) { continue; }
    if(test(elems[i])) { result.push(elems[i]); }

    if(elems[i].childNodes.length > 0){
      result = result.concat(findAll$1(test, elems[i].childNodes));
    }
  }
  return result;
}

var legacy = createCommonjsModule(function (module, exports) {
var ElementType = index;
var isTag = exports.isTag = ElementType.isTag;

exports.testElement = function(options, element){
  for(var key in options){
    if(!options.hasOwnProperty(key)){  }
    else if(key === "tag_name"){
      if(!isTag(element) || !options.tag_name(element.name)){
        return false;
      }
    } else if(key === "tag_type"){
      if(!options.tag_type(element.type)) { return false; }
    } else if(key === "tag_contains"){
      if(isTag(element) || !options.tag_contains(element.data)){
        return false;
      }
    } else if(!element.attributes || !options[key](element.getAttribute(key))) {
      return false;
    }
  }
  return true;
};

var Checks = {
  tag_name: function(name){
    if(typeof name === "function"){
      return function(elem){ return isTag(elem) && name(elem.name); };
    } else if(name === "*"){
      return isTag;
    } else {
      return function(elem){ return isTag(elem) && elem.name === name; };
    }
  },
  tag_type: function(type){
    if(typeof type === "function"){
      return function(elem){ return type(elem.type); };
    } else {
      return function(elem){ return elem.type === type; };
    }
  },
  tag_contains: function(data){
    if(typeof data === "function"){
      return function(elem){ return !isTag(elem) && data(elem.data); };
    } else {
      return function(elem){ return !isTag(elem) && elem.data === data; };
    }
  }
};

function getAttribCheck(attrib, value){
  if(typeof value === "function"){
    return function(elem){ return value(elem.getAttribute(attrib)); };
  } else {
    return function(elem){ return elem.getAttribute(attrib) === value; };
  }
}

function combineFuncs(a, b){
  return function(elem){
    return a(elem) || b(elem);
  };
}

exports.getElements = function(options, element, recurse, limit){
  var funcs = Object.keys(options).map(function(key){
    var value = options[key];
    return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
  });

  return funcs.length === 0 ? [] : this.filter(
    funcs.reduce(combineFuncs),
    element, recurse, limit
  );
};

exports.getElementById = function(id, element, recurse){
  if(!Array.isArray(element)) { element = [element]; }
  return this.findOne(getAttribCheck("id", id), element, recurse !== false);
};

exports.getElementsByTagName = function(name, element, recurse, limit){
  return this.filter(Checks.tag_name(name), element, recurse, limit);
};

exports.getElementsByTagType = function(type, element, recurse, limit){
  return this.filter(Checks.tag_type(type), element, recurse, limit);
};
});

var helpers = createCommonjsModule(function (module, exports) {
// removeSubsets
// Given an array of nodes, remove any member that is contained by another.
exports.removeSubsets = function(nodes) {
  var idx = nodes.length, node, ancestor, replace;

  // Check if each node (or one of its ancestors) is already contained in the
  // array.
  while (--idx > -1) {
    node = ancestor = nodes[idx];

    // Temporarily remove the node under consideration
    nodes[idx] = null;
    replace = true;

    while (ancestor) {
      if (nodes.indexOf(ancestor) > -1) {
        replace = false;
        nodes.splice(idx, 1);
        break;
      }
      ancestor = ancestor.parent;
    }

    // If the node has been found to be unique, re-insert it.
    if (replace) {
      nodes[idx] = node;
    }
  }

  return nodes;
};

// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
var POSITION = {
  DISCONNECTED: 1,
  PRECEDING: 2,
  FOLLOWING: 4,
  CONTAINS: 8,
  CONTAINED_BY: 16
};

// Compare the position of one node against another node in any other document.
// The return value is a bitmask with the following values:
//
// document order:
// > There is an ordering, document order, defined on all the nodes in the
// > document corresponding to the order in which the first character of the
// > XML representation of each node occurs in the XML representation of the
// > document after expansion of general entities. Thus, the document element
// > node will be the first node. Element nodes occur before their children.
// > Thus, document order orders element nodes in order of the occurrence of
// > their start-tag in the XML (after expansion of entities). The attribute
// > nodes of an element occur after the element and before its children. The
// > relative order of attribute nodes is implementation-dependent./
// Source:
// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
//
// @argument {Node} nodaA The first node to use in the comparison
// @argument {Node} nodeB The second node to use in the comparison
//
// @return {Number} A bitmask describing the input nodes' relative position.
//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
//         a description of these values.
var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
  var aParents = [];
  var bParents = [];
  var current, sharedParent, siblings, aSibling, bSibling, idx;

  if (nodeA === nodeB) {
    return 0;
  }

  current = nodeA;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = nodeB;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }

  idx = 0;
  while (aParents[idx] === bParents[idx]) {
    idx++;
  }

  if (idx === 0) {
    return POSITION.DISCONNECTED;
  }

  sharedParent = aParents[idx - 1];
  siblings = sharedParent.childNodes;
  aSibling = aParents[idx];
  bSibling = bParents[idx];

  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
    }
    return POSITION.FOLLOWING;
  } else {
    if (sharedParent === nodeA) {
      return POSITION.PRECEDING | POSITION.CONTAINS;
    }
    return POSITION.PRECEDING;
  }
};

// Sort an array of nodes based on their relative position in the document and
// remove any duplicate nodes. If the array contains nodes that do not belong
// to the same document, sort order is unspecified.
//
// @argument {Array} nodes Array of DOM nodes
//
// @returns {Array} collection of unique nodes, sorted in document order
exports.uniqueSort = function(nodes) {
  var idx = nodes.length, node, position;

  nodes = nodes.slice();

  while (--idx > -1) {
    node = nodes[idx];
    position = nodes.indexOf(node);
    if (position > -1 && position < idx) {
      nodes.splice(idx, 1);
    }
  }
  nodes.sort(function(a, b) {
    var relative = comparePos(a, b);
    if (relative & POSITION.PRECEDING) {
      return -1;
    } else if (relative & POSITION.FOLLOWING) {
      return 1;
    }
    return 0;
  });

  return nodes;
};
});

var index$3 = createCommonjsModule(function (module) {
var DomUtils = module.exports;
[
  stringify,
  traversal,
  manipulation,
  querying,
  legacy,
  helpers
].forEach(function(ext){
  Object.keys(ext).forEach(function(key){
    DomUtils[key] = ext[key].bind(DomUtils);
  });
});
});

var parse_1$1 = parse$1;

//following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo

//[ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
var re_nthElement = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;

/*
	parses a nth-check formula, returns an array of two numbers
*/
function parse$1(formula){
	formula = formula.trim().toLowerCase();

	if(formula === "even"){
		return [2, 0];
	} else if(formula === "odd"){
		return [2, 1];
	} else {
		var parsed = formula.match(re_nthElement);

		if(!parsed){
			throw new SyntaxError("n-th rule couldn't be parsed ('" + formula + "')");
		}

		var a;

		if(parsed[1]){
			a = parseInt(parsed[1], 10);
			if(isNaN(a)){
				if(parsed[1].charAt(0) === "-") { a = -1; }
				else { a = 1; }
			}
		} else { a = 0; }

		return [
			a,
			parsed[3] ? parseInt((parsed[2] || "") + parsed[3], 10) : 0
		];
	}
}

var index$7 = {
	trueFunc: function trueFunc(){
		return true;
	},
	falseFunc: function falseFunc(){
		return false;
	}
};

var compile_1$1 = compile$2;

var BaseFuncs$1 = index$7;
var trueFunc$1  = BaseFuncs$1.trueFunc;
var falseFunc$2 = BaseFuncs$1.falseFunc;

/*
	returns a function that checks if an elements index matches the given rule
	highly optimized to return the fastest solution
*/
function compile$2(parsed){
	var a = parsed[0],
	    b = parsed[1] - 1;

	//when b <= 0, a*n won't be possible for any matches when a < 0
	//besides, the specification says that no element is matched when a and b are 0
	if(b < 0 && a <= 0) { return falseFunc$2; }

	//when a is in the range -1..1, it matches any element (so only b is checked)
	if(a ===-1) { return function(pos){ return pos <= b; }; }
	if(a === 0) { return function(pos){ return pos === b; }; }
	//when b <= 0 and a === 1, they match any element
	if(a === 1) { return b < 0 ? trueFunc$1 : function(pos){ return pos >= b; }; }

	//when a > 0, modulo can be used to check if there is a match
	var bMod = b % a;
	if(bMod < 0) { bMod += a; }

	if(a > 1){
		return function(pos){
			return pos >= b && pos % a === bMod;
		};
	}

	a *= -1; //make `a` positive

	return function(pos){
		return pos <= b && pos % a === bMod;
	};
}

var parse = parse_1$1;
var compile$1 = compile_1$1;

var index$5 = function nthCheck(formula){
	return compile$1(parse(formula));
};

var parse_1 = parse;
var compile_1 = compile$1;

index$5.parse = parse_1;
index$5.compile = compile_1;

var DomUtils$2  = index$3;
var hasAttrib$1 = DomUtils$2.hasAttrib;
var getAttributeValue = DomUtils$2.getAttributeValue;
var falseFunc$3 = index$7.falseFunc;

//https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js#L469
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;

/*
	attribute selectors
*/

var attributeRules = {
	__proto__: null,
	equals: function(next, data){
		var name  = data.name,
		    value = data.value;

		if(data.ignoreCase){
			value = value.toLowerCase();

			return function equalsIC(elem){
				var attr = getAttributeValue(elem, name);
				return attr != null && attr.toLowerCase() === value && next(elem);
			};
		}

		return function equals(elem){
			return getAttributeValue(elem, name) === value && next(elem);
		};
	},
	hyphen: function(next, data){
		var name  = data.name,
		    value = data.value,
		    len = value.length;

		if(data.ignoreCase){
			value = value.toLowerCase();

			return function hyphenIC(elem){
				var attr = getAttributeValue(elem, name);
				return attr != null &&
						(attr.length === len || attr.charAt(len) === "-") &&
						attr.substr(0, len).toLowerCase() === value &&
						next(elem);
			};
		}

		return function hyphen(elem){
			var attr = getAttributeValue(elem, name);
			return attr != null &&
					attr.substr(0, len) === value &&
					(attr.length === len || attr.charAt(len) === "-") &&
					next(elem);
		};
	},
	element: function(next, data){
		var name = data.name,
		    value = data.value;

		if(/\s/.test(value)){
			return falseFunc$3;
		}

		value = value.replace(reChars, "\\$&");

		var pattern = "(?:^|\\s)" + value + "(?:$|\\s)",
		    flags = data.ignoreCase ? "i" : "",
		    regex = new RegExp(pattern, flags);

		return function element(elem){
			var attr = getAttributeValue(elem, name);
			return attr != null && regex.test(attr) && next(elem);
		};
	},
	exists: function(next, data){
		var name = data.name;
		return function exists(elem){
			return hasAttrib$1(elem, name) && next(elem);
		};
	},
	start: function(next, data){
		var name  = data.name,
		    value = data.value,
		    len = value.length;

		if(len === 0){
			return falseFunc$3;
		}
		
		if(data.ignoreCase){
			value = value.toLowerCase();

			return function startIC(elem){
				var attr = getAttributeValue(elem, name);
				return attr != null && attr.substr(0, len).toLowerCase() === value && next(elem);
			};
		}

		return function start(elem){
			var attr = getAttributeValue(elem, name);
			return attr != null && attr.substr(0, len) === value && next(elem);
		};
	},
	end: function(next, data){
		var name  = data.name,
		    value = data.value,
		    len   = -value.length;

		if(len === 0){
			return falseFunc$3;
		}

		if(data.ignoreCase){
			value = value.toLowerCase();

			return function endIC(elem){
				var attr = getAttributeValue(elem, name);
				return attr != null && attr.substr(len).toLowerCase() === value && next(elem);
			};
		}

		return function end(elem){
			var attr = getAttributeValue(elem, name);
			return attr != null && attr.substr(len) === value && next(elem);
		};
	},
	any: function(next, data){
		var name  = data.name,
		    value = data.value;

		if(value === ""){
			return falseFunc$3;
		}

		if(data.ignoreCase){
			var regex = new RegExp(value.replace(reChars, "\\$&"), "i");

			return function anyIC(elem){
				var attr = getAttributeValue(elem, name);
				return attr != null && regex.test(attr) && next(elem);
			};
		}

		return function any(elem){
			var attr = getAttributeValue(elem, name);
			return attr != null && attr.indexOf(value) >= 0 && next(elem);
		};
	},
	not: function(next, data){
		var name  = data.name,
		    value = data.value;

		if(value === ""){
			return function notEmpty(elem){
				return !!getAttributeValue(elem, name) && next(elem);
			};
		} else if(data.ignoreCase){
			value = value.toLowerCase();

			return function notIC(elem){
				var attr = getAttributeValue(elem, name);
				return attr != null && attr.toLowerCase() !== value && next(elem);
			};
		}

		return function not(elem){
			return getAttributeValue(elem, name) !== value && next(elem);
		};
	}
};

var attributes = {
	compile: function(next, data, options){
		if(options && options.strict && (
			data.ignoreCase || data.action === "not"
		)) { throw SyntaxError("Unsupported attribute selector"); }
		return attributeRules[data.action](next, data);
	},
	rules: attributeRules
};

/*
	pseudo selectors

	---

	they are available in two forms:
	* filters called when the selector
	  is compiled and return a function
	  that needs to return next()
	* pseudos get called on execution
	  they need to return a boolean
*/

var DomUtils$1    = index$3;
var isTag       = DomUtils$1.isTag;
var getText     = DomUtils$1.getText;
var getParent   = DomUtils$1.getParent;
var getChildren$1 = DomUtils$1.getChildren;
var getSiblings = DomUtils$1.getSiblings;
var hasAttrib   = DomUtils$1.hasAttrib;
var getName     = DomUtils$1.getName;
var getAttribute= DomUtils$1.getAttributeValue;
var getNCheck   = index$5;
var checkAttrib = attributes.rules.equals;
var BaseFuncs   = index$7;
var trueFunc    = BaseFuncs.trueFunc;
var falseFunc$1   = BaseFuncs.falseFunc;

//helper methods
function getFirstElement(elems){
	for(var i = 0; elems && i < elems.length; i++){
		if(isTag(elems[i])) { return elems[i]; }
	}
}

function getAttribFunc(name, value){
	var data = {name: name, value: value};
	return function attribFunc(next){
		return checkAttrib(next, data);
	};
}

function getChildFunc(next){
	return function(elem){
		return !!getParent(elem) && next(elem);
	};
}

var filters = {
	contains: function(next, text){
		return function contains(elem){
			return next(elem) && getText(elem).indexOf(text) >= 0;
		};
	},
	icontains: function(next, text){
		var itext = text.toLowerCase();
		return function icontains(elem){
			return next(elem) &&
				getText(elem).toLowerCase().indexOf(itext) >= 0;
		};
	},

	//location specific methods
	"nth-child": function(next, rule){
		var func = getNCheck(rule);

		if(func === falseFunc$1) { return func; }
		if(func === trueFunc)  { return getChildFunc(next); }

		return function nthChild(elem){
			var siblings = getSiblings(elem);

			for(var i = 0, pos = 0; i < siblings.length; i++){
				if(isTag(siblings[i])){
					if(siblings[i] === elem) { break; }
					else { pos++; }
				}
			}

			return func(pos) && next(elem);
		};
	},
	"nth-last-child": function(next, rule){
		var func = getNCheck(rule);

		if(func === falseFunc$1) { return func; }
		if(func === trueFunc)  { return getChildFunc(next); }

		return function nthLastChild(elem){
			var siblings = getSiblings(elem);

			for(var pos = 0, i = siblings.length - 1; i >= 0; i--){
				if(isTag(siblings[i])){
					if(siblings[i] === elem) { break; }
					else { pos++; }
				}
			}

			return func(pos) && next(elem);
		};
	},
	"nth-of-type": function(next, rule){
		var func = getNCheck(rule);

		if(func === falseFunc$1) { return func; }
		if(func === trueFunc)  { return getChildFunc(next); }

		return function nthOfType(elem){
			var siblings = getSiblings(elem);

			for(var pos = 0, i = 0; i < siblings.length; i++){
				if(isTag(siblings[i])){
					if(siblings[i] === elem) { break; }
					if(getName(siblings[i]) === getName(elem)) { pos++; }
				}
			}

			return func(pos) && next(elem);
		};
	},
	"nth-last-of-type": function(next, rule){
		var func = getNCheck(rule);

		if(func === falseFunc$1) { return func; }
		if(func === trueFunc)  { return getChildFunc(next); }

		return function nthLastOfType(elem){
			var siblings = getSiblings(elem);

			for(var pos = 0, i = siblings.length - 1; i >= 0; i--){
				if(isTag(siblings[i])){
					if(siblings[i] === elem) { break; }
					if(getName(siblings[i]) === getName(elem)) { pos++; }
				}
			}

			return func(pos) && next(elem);
		};
	},

    //TODO determine the actual root element
    root: function(next){
        return function(elem){
            return !getParent(elem) && next(elem);
        };
    },

    scope: function(next, rule, options, context){
        if(!context || context.length === 0){
            //equivalent to :root
            return filters.root(next);
        }

        if(context.length === 1){
            //NOTE: can't be unpacked, as :has uses this for side-effects
            return function(elem){
                return context[0] === elem && next(elem);
            };
        }

        return function(elem){
            return context.indexOf(elem) >= 0 && next(elem);
        };
    },

	//jQuery extensions (others follow as pseudos)
	checkbox: getAttribFunc("type", "checkbox"),
	file: getAttribFunc("type", "file"),
	password: getAttribFunc("type", "password"),
	radio: getAttribFunc("type", "radio"),
	reset: getAttribFunc("type", "reset"),
	image: getAttribFunc("type", "image"),
	submit: getAttribFunc("type", "submit")
};

//while filters are precompiled, pseudos get called when they are needed
var pseudos = {
	empty: function(elem){
		return !getChildren$1(elem).some(function(elem){
			return isTag(elem) || elem.type === "text";
		});
	},

	"first-child": function(elem){
		return getFirstElement(getSiblings(elem)) === elem;
	},
	"last-child": function(elem){
		var siblings = getSiblings(elem);

		for(var i = siblings.length - 1; i >= 0; i--){
			if(siblings[i] === elem) { return true; }
			if(isTag(siblings[i])) { break; }
		}

		return false;
	},
	"first-of-type": function(elem){
		var siblings = getSiblings(elem);

		for(var i = 0; i < siblings.length; i++){
			if(isTag(siblings[i])){
				if(siblings[i] === elem) { return true; }
				if(getName(siblings[i]) === getName(elem)) { break; }
			}
		}

		return false;
	},
	"last-of-type": function(elem){
		var siblings = getSiblings(elem);

		for(var i = siblings.length-1; i >= 0; i--){
			if(isTag(siblings[i])){
				if(siblings[i] === elem) { return true; }
				if(getName(siblings[i]) === getName(elem)) { break; }
			}
		}

		return false;
	},
	"only-of-type": function(elem){
		var siblings = getSiblings(elem);

		for(var i = 0, j = siblings.length; i < j; i++){
			if(isTag(siblings[i])){
				if(siblings[i] === elem) { continue; }
				if(getName(siblings[i]) === getName(elem)) { return false; }
			}
		}

		return true;
	},
	"only-child": function(elem){
		var siblings = getSiblings(elem);

		for(var i = 0; i < siblings.length; i++){
			if(isTag(siblings[i]) && siblings[i] !== elem) { return false; }
		}

		return true;
	},

	//:matches(a, area, link)[href]
	link: function(elem){
		return hasAttrib(elem, "href");
	},
	visited: falseFunc$1, //seems to be a valid implementation
	//TODO: :any-link once the name is finalized (as an alias of :link)

	//forms
	//to consider: :target

	//:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
	selected: function(elem){
		if(hasAttrib(elem, "selected")) { return true; }
		else if(getName(elem) !== "option") { return false; }

		//the first <option> in a <select> is also selected
		var parent = getParent(elem);

		if(
			!parent ||
			getName(parent) !== "select" ||
			hasAttrib(parent, "multiple")
		) { return false; }

		var siblings = getChildren$1(parent),
			sawElem  = false;

		for(var i = 0; i < siblings.length; i++){
			if(isTag(siblings[i])){
				if(siblings[i] === elem){
					sawElem = true;
				} else if(!sawElem){
					return false;
				} else if(hasAttrib(siblings[i], "selected")){
					return false;
				}
			}
		}

		return sawElem;
	},
	//https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
	//:matches(
	//  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
	//  optgroup[disabled] > option),
	// fieldset[disabled] * //TODO not child of first <legend>
	//)
	disabled: function(elem){
		return hasAttrib(elem, "disabled");
	},
	enabled: function(elem){
		return !hasAttrib(elem, "disabled");
	},
	//:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
	checked: function(elem){
		return hasAttrib(elem, "checked") || pseudos.selected(elem);
	},
	//:matches(input, select, textarea)[required]
	required: function(elem){
		return hasAttrib(elem, "required");
	},
	//:matches(input, select, textarea):not([required])
	optional: function(elem){
		return !hasAttrib(elem, "required");
	},

	//jQuery extensions

	//:not(:empty)
	parent: function(elem){
		return !pseudos.empty(elem);
	},
	//:matches(h1, h2, h3, h4, h5, h6)
	header: function(elem){
		var name = getName(elem);
		return name === "h1" ||
		       name === "h2" ||
		       name === "h3" ||
		       name === "h4" ||
		       name === "h5" ||
		       name === "h6";
	},

	//:matches(button, input[type=button])
	button: function(elem){
		var name = getName(elem);
		return name === "button" ||
		       name === "input" &&
		       getAttribute(elem, "type") === "button";
	},
	//:matches(input, textarea, select, button)
	input: function(elem){
		var name = getName(elem);
		return name === "input" ||
		       name === "textarea" ||
		       name === "select" ||
		       name === "button";
	},
	//input:matches(:not([type!='']), [type='text' i])
	text: function(elem){
		var attr;
		return getName(elem) === "input" && (
			!(attr = getAttribute(elem, "type")) ||
			attr.toLowerCase() === "text"
		);
	}
};

function verifyArgs(func, name, subselect){
	if(subselect === null){
		if(func.length > 1 && name !== "scope"){
			throw new SyntaxError("pseudo-selector :" + name + " requires an argument");
		}
	} else {
		if(func.length === 1){
			throw new SyntaxError("pseudo-selector :" + name + " doesn't have any arguments");
		}
	}
}

//FIXME this feels hacky
var re_CSS3 = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;

var pseudos_1 = {
	compile: function(next, data, options, context){
		var name = data.name,
			subselect = data.data;

		if(options && options.strict && !re_CSS3.test(name)){
			throw SyntaxError(":" + name + " isn't part of CSS3");
		}

		if(typeof filters[name] === "function"){
			verifyArgs(filters[name], name,  subselect);
			return filters[name](next, subselect, options, context);
		} else if(typeof pseudos[name] === "function"){
			var func = pseudos[name];
			verifyArgs(func, name, subselect);

			if(next === trueFunc) { return func; }

			return function pseudoArgs(elem){
				return func(elem, subselect) && next(elem);
			};
		} else {
			throw new SyntaxError("unmatched pseudo-class :" + name);
		}
	},
	filters: filters,
	pseudos: pseudos
};

var index$9 = parse$3;

var re_name = /^(?:\\.|[\w\-\u00c0-\uFFFF])+/;
var re_escape = /\\([\da-f]{1,6}\s?|(\s)|.)/ig;
var re_attr = /^\s*((?:\\.|[\w\u00c0-\uFFFF\-])+)\s*(?:(\S?)=\s*(?:(['"])(.*?)\3|(#?(?:\\.|[\w\u00c0-\uFFFF\-])*)|)|)\s*(i)?\]/;

var actionTypes = {
	__proto__: null,
	"undefined": "exists",
	"":  "equals",
	"~": "element",
	"^": "start",
	"$": "end",
	"*": "any",
	"!": "not",
	"|": "hyphen"
};

var simpleSelectors = {
	__proto__: null,
	">": "child",
	"<": "parent",
	"~": "sibling",
	"+": "adjacent"
};

var attribSelectors = {
	__proto__: null,
	"#": ["id", "equals"],
	".": ["class", "element"]
};

//pseudos, whose data-property is parsed as well
var unpackPseudos = {
	__proto__: null,
	"has": true,
	"not": true,
	"matches": true
};

var stripQuotesFromPseudos = {
	__proto__: null,
	"contains": true,
	"icontains": true
};

var quotes = {
	__proto__: null,
	"\"": true,
	"'": true
};

//unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L139
function funescape( _, escaped, escapedWhitespace ) {
	var high = "0x" + escaped - 0x10000;
	// NaN means non-codepoint
	// Support: Firefox
	// Workaround erroneous numeric interpretation of +"0x"
	return high !== high || escapedWhitespace ?
		escaped :
		// BMP codepoint
		high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			// Supplemental Plane codepoint (surrogate pair)
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
}

function unescapeCSS(str){
	return str.replace(re_escape, funescape);
}

function isWhitespace(c){
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function parse$3(selector, options){
	var subselects = [];

	selector = parseSelector(subselects, selector + "", options);

	if(selector !== ""){
		throw new SyntaxError("Unmatched selector: " + selector);
	}

	return subselects;
}

function parseSelector(subselects, selector, options){
	var tokens = [],
		sawWS = false,
		data, firstChar, name, quot;

	function getName(){
		var sub = selector.match(re_name)[0];
		selector = selector.substr(sub.length);
		return unescapeCSS(sub);
	}

	function stripWhitespace(start){
		while(isWhitespace(selector.charAt(start))) { start++; }
		selector = selector.substr(start);
	}

	stripWhitespace(0);

	while(selector !== ""){
		firstChar = selector.charAt(0);

		if(isWhitespace(firstChar)){
			sawWS = true;
			stripWhitespace(1);
		} else if(firstChar in simpleSelectors){
			tokens.push({type: simpleSelectors[firstChar]});
			sawWS = false;

			stripWhitespace(1);
		} else if(firstChar === ","){
			if(tokens.length === 0){
				throw new SyntaxError("empty sub-selector");
			}
			subselects.push(tokens);
			tokens = [];
			sawWS = false;
			stripWhitespace(1);
		} else {
			if(sawWS){
				if(tokens.length > 0){
					tokens.push({type: "descendant"});
				}
				sawWS = false;
			}

			if(firstChar === "*"){
				selector = selector.substr(1);
				tokens.push({type: "universal"});
			} else if(firstChar in attribSelectors){
				selector = selector.substr(1);
				tokens.push({
					type: "attribute",
					name: attribSelectors[firstChar][0],
					action: attribSelectors[firstChar][1],
					value: getName(),
					ignoreCase: false
				});
			} else if(firstChar === "["){
				selector = selector.substr(1);
				data = selector.match(re_attr);
				if(!data){
					throw new SyntaxError("Malformed attribute selector: " + selector);
				}
				selector = selector.substr(data[0].length);
				name = unescapeCSS(data[1]);

				if(
					!options || (
						"lowerCaseAttributeNames" in options ?
							options.lowerCaseAttributeNames :
							!options.xmlMode
					)
				){
					name = name.toLowerCase();
				}

				tokens.push({
					type: "attribute",
					name: name,
					action: actionTypes[data[2]],
					value: unescapeCSS(data[4] || data[5] || ""),
					ignoreCase: !!data[6]
				});

			} else if(firstChar === ":"){
				if(selector.charAt(1) === ":"){
					selector = selector.substr(2);
					tokens.push({type: "pseudo-element", name: getName().toLowerCase()});
					continue;
				}

				selector = selector.substr(1);

				name = getName().toLowerCase();
				data = null;

				if(selector.charAt(0) === "("){
					if(name in unpackPseudos){
						quot = selector.charAt(1);
						var quoted = quot in quotes;

						selector = selector.substr(quoted + 1);

						data = [];
						selector = parseSelector(data, selector, options);

						if(quoted){
							if(selector.charAt(0) !== quot){
								throw new SyntaxError("unmatched quotes in :" + name);
							} else {
								selector = selector.substr(1);
							}
						}

						if(selector.charAt(0) !== ")"){
							throw new SyntaxError("missing closing parenthesis in :" + name + " " + selector);
						}

						selector = selector.substr(1);
					} else {
						var pos = 1, counter = 1;

						for(; counter > 0 && pos < selector.length; pos++){
							if(selector.charAt(pos) === "(") { counter++; }
							else if(selector.charAt(pos) === ")") { counter--; }
						}

						if(counter){
							throw new SyntaxError("parenthesis not matched");
						}

						data = selector.substr(1, pos - 2);
						selector = selector.substr(pos);

						if(name in stripQuotesFromPseudos){
							quot = data.charAt(0);

							if(quot === data.slice(-1) && quot in quotes){
								data = data.slice(1, -1);
							}

							data = unescapeCSS(data);
						}
					}
				}

				tokens.push({type: "pseudo", name: name, data: data});
			} else if(re_name.test(selector)){
				name = getName();

				if(!options || ("lowerCaseTags" in options ? options.lowerCaseTags : !options.xmlMode)){
					name = name.toLowerCase();
				}

				tokens.push({type: "tag", name: name});
			} else {
				if(tokens.length && tokens[tokens.length - 1].type === "descendant"){
					tokens.pop();
				}
				addToken(subselects, tokens);
				return selector;
			}
		}
	}

	addToken(subselects, tokens);

	return selector;
}

function addToken(subselects, tokens){
	if(subselects.length > 0 && tokens.length === 0){
		throw new SyntaxError("empty sub-selector");
	}

	subselects.push(tokens);
}

var DomUtils$4    = index$3;
var isTag$4       = DomUtils$4.isTag;
var getParent$2   = DomUtils$4.getParent;
var getChildren$3 = DomUtils$4.getChildren;
var getSiblings$1 = DomUtils$4.getSiblings;
var getName$1     = DomUtils$4.getName;

/*
	all available rules
*/
var general = {
	__proto__: null,

	attribute: attributes.compile,
	pseudo: pseudos_1.compile,

	//tags
	tag: function(next, data){
		var name = data.name;
		return function tag(elem){
			return getName$1(elem) === name && next(elem);
		};
	},

	//traversal
	descendant: function(next, rule, options, context, acceptSelf){
		return function descendant(elem){

			if (acceptSelf && next(elem)) { return true; }

			var found = false;

			while(!found && (elem = getParent$2(elem))){
				found = next(elem);
			}

			return found;
		};
	},
	parent: function(next, data, options){
		if(options && options.strict) { throw SyntaxError("Parent selector isn't part of CSS3"); }

		return function parent(elem){
			return getChildren$3(elem).some(test);
		};

		function test(elem){
			return isTag$4(elem) && next(elem);
		}
	},
	child: function(next){
		return function child(elem){
			var parent = getParent$2(elem);
			return !!parent && next(parent);
		};
	},
	sibling: function(next){
		return function sibling(elem){
			var siblings = getSiblings$1(elem);

			for(var i = 0; i < siblings.length; i++){
				if(isTag$4(siblings[i])){
					if(siblings[i] === elem) { break; }
					if(next(siblings[i])) { return true; }
				}
			}

			return false;
		};
	},
	adjacent: function(next){
		return function adjacent(elem){
			var siblings = getSiblings$1(elem),
			    lastElement;

			for(var i = 0; i < siblings.length; i++){
				if(isTag$4(siblings[i])){
					if(siblings[i] === elem) { break; }
					lastElement = siblings[i];
				}
			}

			return !!lastElement && next(lastElement);
		};
	},
	universal: function(next){
		return next;
	}
};

var universal = 50;
var tag = 30;
var attribute = 1;
var pseudo = 0;
var descendant = -1;
var child = -1;
var parent$2 = -1;
var sibling = -1;
var adjacent = -1;
var procedure$2 = {
	universal: universal,
	tag: tag,
	attribute: attribute,
	pseudo: pseudo,
	descendant: descendant,
	child: child,
	parent: parent$2,
	sibling: sibling,
	adjacent: adjacent
};

var procedure$3 = Object.freeze({
	universal: universal,
	tag: tag,
	attribute: attribute,
	pseudo: pseudo,
	descendant: descendant,
	child: child,
	parent: parent$2,
	sibling: sibling,
	adjacent: adjacent,
	default: procedure$2
});

var require$$0$4 = ( procedure$3 && procedure$3['default'] ) || procedure$3;

var sort = sortByProcedure;

/*
	sort the parts of the passed selector,
	as there is potential for optimization
	(some types of selectors are faster than others)
*/

var procedure$1 = require$$0$4;

var attributes$2 = {
	__proto__: null,
	exists: 10,
	equals: 8,
	not: 7,
	start: 6,
	end: 6,
	any: 5,
	hyphen: 4,
	element: 4
};

function sortByProcedure(arr){
	var procs = arr.map(getProcedure);
	for(var i = 1; i < arr.length; i++){
		var procNew = procs[i];

		if(procNew < 0) { continue; }

		for(var j = i - 1; j >= 0 && procNew < procs[j]; j--){
			var token = arr[j + 1];
			arr[j + 1] = arr[j];
			arr[j] = token;
			procs[j + 1] = procs[j];
			procs[j] = procNew;
		}
	}
}

function getProcedure(token){
	var proc = procedure$1[token.type];

	if(proc === procedure$1.attribute){
		proc = attributes$2[token.action];

		if(proc === attributes$2.equals && token.name === "id"){
			//prefer ID selectors (eg. #ID)
			proc = 9;
		}

		if(token.ignoreCase){
			//ignoreCase adds some overhead, prefer "normal" token
			//this is a binary operation, to ensure it's still an int
			proc >>= 1;
		}
	} else if(proc === procedure$1.pseudo){
		if(!token.data){
			proc = 3;
		} else if(token.name === "has" || token.name === "contains"){
			proc = 0; //expensive in any case
		} else if(token.name === "matches" || token.name === "not"){
			proc = 0;
			for(var i = 0; i < token.data.length; i++){
				//TODO better handling of complex selectors
				if(token.data[i].length !== 1) { continue; }
				var cur = getProcedure(token.data[i][0]);
				//avoid executing :has or :contains
				if(cur === 0){
					proc = 0;
					break;
				}
				if(cur > proc) { proc = cur; }
			}
			if(token.data.length > 1 && proc > 0) { proc -= 1; }
		} else {
			proc = 1;
		}
	}
	return proc;
}

/*
	compiles a selector to an executable function
*/

var compile_1$3 = compile$3;
var compileUnsafe_1 = compileUnsafe$1;
var compileToken_1 = compileToken$1;

var parse$2       = index$9;
var DomUtils$3    = index$3;
var isTag$3       = DomUtils$3.isTag;
var Rules       = general;
var sortRules   = sort;
var BaseFuncs$2   = index$7;
var trueFunc$2    = BaseFuncs$2.trueFunc;
var falseFunc$4   = BaseFuncs$2.falseFunc;
var procedure   = require$$0$4;

function compile$3(selector, options, context){
	var next = compileUnsafe$1(selector, options, context);
	return wrap(next);
}

function wrap(next){
	return function base(elem){
		return isTag$3(elem) && next(elem);
	};
}

function compileUnsafe$1(selector, options, context){
	var token = parse$2(selector, options);
	return compileToken$1(token, options, context);
}

function includesScopePseudo(t){
    return t.type === "pseudo" && (
        t.name === "scope" || (
            Array.isArray(t.data) &&
            t.data.some(function(data){
                return data.some(includesScopePseudo);
            })
        )
    );
}

var DESCENDANT_TOKEN = {type: "descendant"};
var SCOPE_TOKEN = {type: "pseudo", name: "scope"};
var PLACEHOLDER_ELEMENT = {};
var getParent$1 = DomUtils$3.getParent;

//CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
//http://www.w3.org/TR/selectors4/#absolutizing
function absolutize(token, context){
    //TODO better check if context is document
    var hasContext = !!context && !!context.length && context.every(function(e){
        return e === PLACEHOLDER_ELEMENT || !!getParent$1(e);
    });


    token.forEach(function(t){
        if(t.length > 0 && isTraversal(t[0]) && t[0].type !== "descendant"){
            //don't return in else branch
        } else if(hasContext && !includesScopePseudo(t)){
            t.unshift(DESCENDANT_TOKEN);
        } else {
            return;
        }

        t.unshift(SCOPE_TOKEN);
    });
}

function compileToken$1(token, options, context){
    token = token.filter(function(t){ return t.length > 0; });

	token.forEach(sortRules);

	var isArrayContext = Array.isArray(context);

    context = (options && options.context) || context;

    if(context && !isArrayContext) { context = [context]; }

    absolutize(token, context);

	return token
		.map(function(rules){ return compileRules(rules, options, context, isArrayContext); })
		.reduce(reduceRules, falseFunc$4);
}

function isTraversal(t){
	return procedure[t.type] < 0;
}

function compileRules(rules, options, context, isArrayContext){
	var acceptSelf = (isArrayContext && rules[0].name === "scope" && rules[1].type === "descendant");
	return rules.reduce(function(func, rule, index){
		if(func === falseFunc$4) { return func; }
		return Rules[rule.type](func, rule, options, context, acceptSelf && index === 1);
	}, options && options.rootFunc || trueFunc$2);
}

function reduceRules(a, b){
	if(b === falseFunc$4 || a === trueFunc$2){
		return a;
	}
	if(a === falseFunc$4 || b === trueFunc$2){
		return b;
	}

	return function combine(elem){
		return a(elem) || b(elem);
	};
}

//:not, :has and :matches have to compile selectors
//doing this in lib/pseudos.js would lead to circular dependencies,
//so we add them here

var Pseudos$1     = pseudos_1;
var filters$1     = Pseudos$1.filters;
var existsOne$1   = DomUtils$3.existsOne;
var isTag$3       = DomUtils$3.isTag;
var getChildren$2 = DomUtils$3.getChildren;


function containsTraversal(t){
	return t.some(isTraversal);
}

filters$1.not = function(next, token, options, context){
	var opts = {
	    	xmlMode: !!(options && options.xmlMode),
	    	strict: !!(options && options.strict)
	    };

	if(opts.strict){
		if(token.length > 1 || token.some(containsTraversal)){
			throw new SyntaxError("complex selectors in :not aren't allowed in strict mode");
		}
	}

    var func = compileToken$1(token, opts, context);

	if(func === falseFunc$4) { return next; }
	if(func === trueFunc$2)  { return falseFunc$4; }

	return function(elem){
		return !func(elem) && next(elem);
	};
};

filters$1.has = function(next, token, options){
	var opts = {
		xmlMode: !!(options && options.xmlMode),
		strict: !!(options && options.strict)
	};

    //FIXME: Uses an array as a pointer to the current element (side effects)
    var context = token.some(containsTraversal) ? [PLACEHOLDER_ELEMENT] : null;

	var func = compileToken$1(token, opts, context);

	if(func === falseFunc$4) { return falseFunc$4; }
	if(func === trueFunc$2)  { return function(elem){
			return getChildren$2(elem).some(isTag$3) && next(elem);
		}; }

	func = wrap(func);

    if(context){
        return function has(elem){
		return next(elem) && (
                (context[0] = elem), existsOne$1(func, getChildren$2(elem))
            );
	};
    }

    return function has(elem){
		return next(elem) && existsOne$1(func, getChildren$2(elem));
	};
};

filters$1.matches = function(next, token, options, context){
	var opts = {
		xmlMode: !!(options && options.xmlMode),
		strict: !!(options && options.strict),
		rootFunc: next
	};

	return compileToken$1(token, opts, context);
};

compile_1$3.compileUnsafe = compileUnsafe_1;
compile_1$3.compileToken = compileToken_1;

var index$1 = CSSselect;

var Pseudos       = pseudos_1;
var DomUtils      = index$3;
var findOne       = DomUtils.findOne;
var findAll       = DomUtils.findAll;
var getChildren   = DomUtils.getChildren;
var removeSubsets = DomUtils.removeSubsets;
var falseFunc     = index$7.falseFunc;
var compile       = compile_1$3;
var compileUnsafe = compile.compileUnsafe;
var compileToken  = compile.compileToken;

function getSelectorFunc(searchFunc){
	return function select(query, elems, options){
        if(typeof query !== "function") { query = compileUnsafe(query, options, elems); }
        if(!Array.isArray(elems)) { elems = getChildren(elems); }
		else { elems = removeSubsets(elems); }
		return searchFunc(query, elems);
	};
}

var selectAll = getSelectorFunc(function selectAll(query, elems){
	return (query === falseFunc || !elems || elems.length === 0) ? [] : findAll(query, elems);
});

var selectOne = getSelectorFunc(function selectOne(query, elems){
	return (query === falseFunc || !elems || elems.length === 0) ? null : findOne(query, elems);
});

function is(elem, query, options){
	return (typeof query === "function" ? query : compile(query, options))(elem);
}

/*
	the exported interface
*/
function CSSselect(query, elems, options){
	return selectAll(query, elems, options);
}

CSSselect.compile = compile;
CSSselect.filters = Pseudos.filters;
CSSselect.pseudos = Pseudos.pseudos;

CSSselect.selectAll = selectAll;
CSSselect.selectOne = selectOne;

CSSselect.is = is;

//legacy methods (might be removed)
CSSselect.parse = compile;
CSSselect.iterate = selectAll;

//hooks
CSSselect._compileUnsafe = compileUnsafe;
CSSselect._compileToken = compileToken;

var decode = {
	"0": 65533,
	"128": 8364,
	"130": 8218,
	"131": 402,
	"132": 8222,
	"133": 8230,
	"134": 8224,
	"135": 8225,
	"136": 710,
	"137": 8240,
	"138": 352,
	"139": 8249,
	"140": 338,
	"142": 381,
	"145": 8216,
	"146": 8217,
	"147": 8220,
	"148": 8221,
	"149": 8226,
	"150": 8211,
	"151": 8212,
	"152": 732,
	"153": 8482,
	"154": 353,
	"155": 8250,
	"156": 339,
	"158": 382,
	"159": 376
};

var decode$1 = Object.freeze({
	default: decode
});

var require$$0$6 = ( decode$1 && decode$1['default'] ) || decode$1;

var decodeMap = require$$0$6;

var decode_codepoint = decodeCodePoint$1;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint$1(codePoint){

	if((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF){
		return "\uFFFD";
	}

	if(codePoint in decodeMap){
		codePoint = decodeMap[codePoint];
	}

	var output = "";

	if(codePoint > 0xFFFF){
		codePoint -= 0x10000;
		output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
		codePoint = 0xDC00 | codePoint & 0x3FF;
	}

	output += String.fromCharCode(codePoint);
	return output;
}

var Aacute = "Á";
var aacute = "á";
var Abreve = "Ă";
var abreve = "ă";
var ac = "∾";
var acd = "∿";
var acE = "∾̳";
var Acirc = "Â";
var acirc = "â";
var acute = "´";
var Acy = "А";
var acy = "а";
var AElig = "Æ";
var aelig = "æ";
var af = "⁡";
var Afr = "𝔄";
var afr = "𝔞";
var Agrave = "À";
var agrave = "à";
var alefsym = "ℵ";
var aleph = "ℵ";
var Alpha = "Α";
var alpha = "α";
var Amacr = "Ā";
var amacr = "ā";
var amalg = "⨿";
var amp = "&";
var AMP = "&";
var andand = "⩕";
var And = "⩓";
var and = "∧";
var andd = "⩜";
var andslope = "⩘";
var andv = "⩚";
var ang = "∠";
var ange = "⦤";
var angle = "∠";
var angmsdaa = "⦨";
var angmsdab = "⦩";
var angmsdac = "⦪";
var angmsdad = "⦫";
var angmsdae = "⦬";
var angmsdaf = "⦭";
var angmsdag = "⦮";
var angmsdah = "⦯";
var angmsd = "∡";
var angrt = "∟";
var angrtvb = "⊾";
var angrtvbd = "⦝";
var angsph = "∢";
var angst = "Å";
var angzarr = "⍼";
var Aogon = "Ą";
var aogon = "ą";
var Aopf = "𝔸";
var aopf = "𝕒";
var apacir = "⩯";
var ap = "≈";
var apE = "⩰";
var ape = "≊";
var apid = "≋";
var apos = "'";
var ApplyFunction = "⁡";
var approx = "≈";
var approxeq = "≊";
var Aring = "Å";
var aring = "å";
var Ascr = "𝒜";
var ascr = "𝒶";
var Assign = "≔";
var ast = "*";
var asymp = "≈";
var asympeq = "≍";
var Atilde = "Ã";
var atilde = "ã";
var Auml = "Ä";
var auml = "ä";
var awconint = "∳";
var awint = "⨑";
var backcong = "≌";
var backepsilon = "϶";
var backprime = "‵";
var backsim = "∽";
var backsimeq = "⋍";
var Backslash = "∖";
var Barv = "⫧";
var barvee = "⊽";
var barwed = "⌅";
var Barwed = "⌆";
var barwedge = "⌅";
var bbrk = "⎵";
var bbrktbrk = "⎶";
var bcong = "≌";
var Bcy = "Б";
var bcy = "б";
var bdquo = "„";
var becaus = "∵";
var because = "∵";
var Because = "∵";
var bemptyv = "⦰";
var bepsi = "϶";
var bernou = "ℬ";
var Bernoullis = "ℬ";
var Beta = "Β";
var beta = "β";
var beth = "ℶ";
var between = "≬";
var Bfr = "𝔅";
var bfr = "𝔟";
var bigcap = "⋂";
var bigcirc = "◯";
var bigcup = "⋃";
var bigodot = "⨀";
var bigoplus = "⨁";
var bigotimes = "⨂";
var bigsqcup = "⨆";
var bigstar = "★";
var bigtriangledown = "▽";
var bigtriangleup = "△";
var biguplus = "⨄";
var bigvee = "⋁";
var bigwedge = "⋀";
var bkarow = "⤍";
var blacklozenge = "⧫";
var blacksquare = "▪";
var blacktriangle = "▴";
var blacktriangledown = "▾";
var blacktriangleleft = "◂";
var blacktriangleright = "▸";
var blank = "␣";
var blk12 = "▒";
var blk14 = "░";
var blk34 = "▓";
var block = "█";
var bne = "=⃥";
var bnequiv = "≡⃥";
var bNot = "⫭";
var bnot = "⌐";
var Bopf = "𝔹";
var bopf = "𝕓";
var bot = "⊥";
var bottom = "⊥";
var bowtie = "⋈";
var boxbox = "⧉";
var boxdl = "┐";
var boxdL = "╕";
var boxDl = "╖";
var boxDL = "╗";
var boxdr = "┌";
var boxdR = "╒";
var boxDr = "╓";
var boxDR = "╔";
var boxh = "─";
var boxH = "═";
var boxhd = "┬";
var boxHd = "╤";
var boxhD = "╥";
var boxHD = "╦";
var boxhu = "┴";
var boxHu = "╧";
var boxhU = "╨";
var boxHU = "╩";
var boxminus = "⊟";
var boxplus = "⊞";
var boxtimes = "⊠";
var boxul = "┘";
var boxuL = "╛";
var boxUl = "╜";
var boxUL = "╝";
var boxur = "└";
var boxuR = "╘";
var boxUr = "╙";
var boxUR = "╚";
var boxv = "│";
var boxV = "║";
var boxvh = "┼";
var boxvH = "╪";
var boxVh = "╫";
var boxVH = "╬";
var boxvl = "┤";
var boxvL = "╡";
var boxVl = "╢";
var boxVL = "╣";
var boxvr = "├";
var boxvR = "╞";
var boxVr = "╟";
var boxVR = "╠";
var bprime = "‵";
var breve = "˘";
var Breve = "˘";
var brvbar = "¦";
var bscr = "𝒷";
var Bscr = "ℬ";
var bsemi = "⁏";
var bsim = "∽";
var bsime = "⋍";
var bsolb = "⧅";
var bsol = "\\";
var bsolhsub = "⟈";
var bull = "•";
var bullet = "•";
var bump = "≎";
var bumpE = "⪮";
var bumpe = "≏";
var Bumpeq = "≎";
var bumpeq = "≏";
var Cacute = "Ć";
var cacute = "ć";
var capand = "⩄";
var capbrcup = "⩉";
var capcap = "⩋";
var cap = "∩";
var Cap = "⋒";
var capcup = "⩇";
var capdot = "⩀";
var CapitalDifferentialD = "ⅅ";
var caps = "∩︀";
var caret = "⁁";
var caron = "ˇ";
var Cayleys = "ℭ";
var ccaps = "⩍";
var Ccaron = "Č";
var ccaron = "č";
var Ccedil = "Ç";
var ccedil = "ç";
var Ccirc = "Ĉ";
var ccirc = "ĉ";
var Cconint = "∰";
var ccups = "⩌";
var ccupssm = "⩐";
var Cdot = "Ċ";
var cdot = "ċ";
var cedil = "¸";
var Cedilla = "¸";
var cemptyv = "⦲";
var cent = "¢";
var centerdot = "·";
var CenterDot = "·";
var cfr = "𝔠";
var Cfr = "ℭ";
var CHcy = "Ч";
var chcy = "ч";
var check = "✓";
var checkmark = "✓";
var Chi = "Χ";
var chi = "χ";
var circ = "ˆ";
var circeq = "≗";
var circlearrowleft = "↺";
var circlearrowright = "↻";
var circledast = "⊛";
var circledcirc = "⊚";
var circleddash = "⊝";
var CircleDot = "⊙";
var circledR = "®";
var circledS = "Ⓢ";
var CircleMinus = "⊖";
var CirclePlus = "⊕";
var CircleTimes = "⊗";
var cir = "○";
var cirE = "⧃";
var cire = "≗";
var cirfnint = "⨐";
var cirmid = "⫯";
var cirscir = "⧂";
var ClockwiseContourIntegral = "∲";
var CloseCurlyDoubleQuote = "”";
var CloseCurlyQuote = "’";
var clubs = "♣";
var clubsuit = "♣";
var colon = ":";
var Colon = "∷";
var Colone = "⩴";
var colone = "≔";
var coloneq = "≔";
var comma = ",";
var commat = "@";
var comp = "∁";
var compfn = "∘";
var complement = "∁";
var complexes = "ℂ";
var cong = "≅";
var congdot = "⩭";
var Congruent = "≡";
var conint = "∮";
var Conint = "∯";
var ContourIntegral = "∮";
var copf = "𝕔";
var Copf = "ℂ";
var coprod = "∐";
var Coproduct = "∐";
var copy = "©";
var COPY = "©";
var copysr = "℗";
var CounterClockwiseContourIntegral = "∳";
var crarr = "↵";
var cross = "✗";
var Cross = "⨯";
var Cscr = "𝒞";
var cscr = "𝒸";
var csub = "⫏";
var csube = "⫑";
var csup = "⫐";
var csupe = "⫒";
var ctdot = "⋯";
var cudarrl = "⤸";
var cudarrr = "⤵";
var cuepr = "⋞";
var cuesc = "⋟";
var cularr = "↶";
var cularrp = "⤽";
var cupbrcap = "⩈";
var cupcap = "⩆";
var CupCap = "≍";
var cup = "∪";
var Cup = "⋓";
var cupcup = "⩊";
var cupdot = "⊍";
var cupor = "⩅";
var cups = "∪︀";
var curarr = "↷";
var curarrm = "⤼";
var curlyeqprec = "⋞";
var curlyeqsucc = "⋟";
var curlyvee = "⋎";
var curlywedge = "⋏";
var curren = "¤";
var curvearrowleft = "↶";
var curvearrowright = "↷";
var cuvee = "⋎";
var cuwed = "⋏";
var cwconint = "∲";
var cwint = "∱";
var cylcty = "⌭";
var dagger = "†";
var Dagger = "‡";
var daleth = "ℸ";
var darr = "↓";
var Darr = "↡";
var dArr = "⇓";
var dash = "‐";
var Dashv = "⫤";
var dashv = "⊣";
var dbkarow = "⤏";
var dblac = "˝";
var Dcaron = "Ď";
var dcaron = "ď";
var Dcy = "Д";
var dcy = "д";
var ddagger = "‡";
var ddarr = "⇊";
var DD = "ⅅ";
var dd = "ⅆ";
var DDotrahd = "⤑";
var ddotseq = "⩷";
var deg = "°";
var Del = "∇";
var Delta = "Δ";
var delta = "δ";
var demptyv = "⦱";
var dfisht = "⥿";
var Dfr = "𝔇";
var dfr = "𝔡";
var dHar = "⥥";
var dharl = "⇃";
var dharr = "⇂";
var DiacriticalAcute = "´";
var DiacriticalDot = "˙";
var DiacriticalDoubleAcute = "˝";
var DiacriticalGrave = "`";
var DiacriticalTilde = "˜";
var diam = "⋄";
var diamond = "⋄";
var Diamond = "⋄";
var diamondsuit = "♦";
var diams = "♦";
var die = "¨";
var DifferentialD = "ⅆ";
var digamma = "ϝ";
var disin = "⋲";
var div = "÷";
var divide = "÷";
var divideontimes = "⋇";
var divonx = "⋇";
var DJcy = "Ђ";
var djcy = "ђ";
var dlcorn = "⌞";
var dlcrop = "⌍";
var dollar = "$";
var Dopf = "𝔻";
var dopf = "𝕕";
var Dot = "¨";
var dot = "˙";
var DotDot = "⃜";
var doteq = "≐";
var doteqdot = "≑";
var DotEqual = "≐";
var dotminus = "∸";
var dotplus = "∔";
var dotsquare = "⊡";
var doublebarwedge = "⌆";
var DoubleContourIntegral = "∯";
var DoubleDot = "¨";
var DoubleDownArrow = "⇓";
var DoubleLeftArrow = "⇐";
var DoubleLeftRightArrow = "⇔";
var DoubleLeftTee = "⫤";
var DoubleLongLeftArrow = "⟸";
var DoubleLongLeftRightArrow = "⟺";
var DoubleLongRightArrow = "⟹";
var DoubleRightArrow = "⇒";
var DoubleRightTee = "⊨";
var DoubleUpArrow = "⇑";
var DoubleUpDownArrow = "⇕";
var DoubleVerticalBar = "∥";
var DownArrowBar = "⤓";
var downarrow = "↓";
var DownArrow = "↓";
var Downarrow = "⇓";
var DownArrowUpArrow = "⇵";
var DownBreve = "̑";
var downdownarrows = "⇊";
var downharpoonleft = "⇃";
var downharpoonright = "⇂";
var DownLeftRightVector = "⥐";
var DownLeftTeeVector = "⥞";
var DownLeftVectorBar = "⥖";
var DownLeftVector = "↽";
var DownRightTeeVector = "⥟";
var DownRightVectorBar = "⥗";
var DownRightVector = "⇁";
var DownTeeArrow = "↧";
var DownTee = "⊤";
var drbkarow = "⤐";
var drcorn = "⌟";
var drcrop = "⌌";
var Dscr = "𝒟";
var dscr = "𝒹";
var DScy = "Ѕ";
var dscy = "ѕ";
var dsol = "⧶";
var Dstrok = "Đ";
var dstrok = "đ";
var dtdot = "⋱";
var dtri = "▿";
var dtrif = "▾";
var duarr = "⇵";
var duhar = "⥯";
var dwangle = "⦦";
var DZcy = "Џ";
var dzcy = "џ";
var dzigrarr = "⟿";
var Eacute = "É";
var eacute = "é";
var easter = "⩮";
var Ecaron = "Ě";
var ecaron = "ě";
var Ecirc = "Ê";
var ecirc = "ê";
var ecir = "≖";
var ecolon = "≕";
var Ecy = "Э";
var ecy = "э";
var eDDot = "⩷";
var Edot = "Ė";
var edot = "ė";
var eDot = "≑";
var ee = "ⅇ";
var efDot = "≒";
var Efr = "𝔈";
var efr = "𝔢";
var eg = "⪚";
var Egrave = "È";
var egrave = "è";
var egs = "⪖";
var egsdot = "⪘";
var el = "⪙";
var Element = "∈";
var elinters = "⏧";
var ell = "ℓ";
var els = "⪕";
var elsdot = "⪗";
var Emacr = "Ē";
var emacr = "ē";
var empty = "∅";
var emptyset = "∅";
var EmptySmallSquare = "◻";
var emptyv = "∅";
var EmptyVerySmallSquare = "▫";
var emsp13 = " ";
var emsp14 = " ";
var emsp = " ";
var ENG = "Ŋ";
var eng = "ŋ";
var ensp = " ";
var Eogon = "Ę";
var eogon = "ę";
var Eopf = "𝔼";
var eopf = "𝕖";
var epar = "⋕";
var eparsl = "⧣";
var eplus = "⩱";
var epsi = "ε";
var Epsilon = "Ε";
var epsilon = "ε";
var epsiv = "ϵ";
var eqcirc = "≖";
var eqcolon = "≕";
var eqsim = "≂";
var eqslantgtr = "⪖";
var eqslantless = "⪕";
var Equal = "⩵";
var equals = "=";
var EqualTilde = "≂";
var equest = "≟";
var Equilibrium = "⇌";
var equiv = "≡";
var equivDD = "⩸";
var eqvparsl = "⧥";
var erarr = "⥱";
var erDot = "≓";
var escr = "ℯ";
var Escr = "ℰ";
var esdot = "≐";
var Esim = "⩳";
var esim = "≂";
var Eta = "Η";
var eta = "η";
var ETH = "Ð";
var eth = "ð";
var Euml = "Ë";
var euml = "ë";
var euro = "€";
var excl = "!";
var exist = "∃";
var Exists = "∃";
var expectation = "ℰ";
var exponentiale = "ⅇ";
var ExponentialE = "ⅇ";
var fallingdotseq = "≒";
var Fcy = "Ф";
var fcy = "ф";
var female = "♀";
var ffilig = "ﬃ";
var fflig = "ﬀ";
var ffllig = "ﬄ";
var Ffr = "𝔉";
var ffr = "𝔣";
var filig = "ﬁ";
var FilledSmallSquare = "◼";
var FilledVerySmallSquare = "▪";
var fjlig = "fj";
var flat = "♭";
var fllig = "ﬂ";
var fltns = "▱";
var fnof = "ƒ";
var Fopf = "𝔽";
var fopf = "𝕗";
var forall = "∀";
var ForAll = "∀";
var fork = "⋔";
var forkv = "⫙";
var Fouriertrf = "ℱ";
var fpartint = "⨍";
var frac12 = "½";
var frac13 = "⅓";
var frac14 = "¼";
var frac15 = "⅕";
var frac16 = "⅙";
var frac18 = "⅛";
var frac23 = "⅔";
var frac25 = "⅖";
var frac34 = "¾";
var frac35 = "⅗";
var frac38 = "⅜";
var frac45 = "⅘";
var frac56 = "⅚";
var frac58 = "⅝";
var frac78 = "⅞";
var frasl = "⁄";
var frown = "⌢";
var fscr = "𝒻";
var Fscr = "ℱ";
var gacute = "ǵ";
var Gamma = "Γ";
var gamma = "γ";
var Gammad = "Ϝ";
var gammad = "ϝ";
var gap = "⪆";
var Gbreve = "Ğ";
var gbreve = "ğ";
var Gcedil = "Ģ";
var Gcirc = "Ĝ";
var gcirc = "ĝ";
var Gcy = "Г";
var gcy = "г";
var Gdot = "Ġ";
var gdot = "ġ";
var ge = "≥";
var gE = "≧";
var gEl = "⪌";
var gel = "⋛";
var geq = "≥";
var geqq = "≧";
var geqslant = "⩾";
var gescc = "⪩";
var ges = "⩾";
var gesdot = "⪀";
var gesdoto = "⪂";
var gesdotol = "⪄";
var gesl = "⋛︀";
var gesles = "⪔";
var Gfr = "𝔊";
var gfr = "𝔤";
var gg = "≫";
var Gg = "⋙";
var ggg = "⋙";
var gimel = "ℷ";
var GJcy = "Ѓ";
var gjcy = "ѓ";
var gla = "⪥";
var gl = "≷";
var glE = "⪒";
var glj = "⪤";
var gnap = "⪊";
var gnapprox = "⪊";
var gne = "⪈";
var gnE = "≩";
var gneq = "⪈";
var gneqq = "≩";
var gnsim = "⋧";
var Gopf = "𝔾";
var gopf = "𝕘";
var grave = "`";
var GreaterEqual = "≥";
var GreaterEqualLess = "⋛";
var GreaterFullEqual = "≧";
var GreaterGreater = "⪢";
var GreaterLess = "≷";
var GreaterSlantEqual = "⩾";
var GreaterTilde = "≳";
var Gscr = "𝒢";
var gscr = "ℊ";
var gsim = "≳";
var gsime = "⪎";
var gsiml = "⪐";
var gtcc = "⪧";
var gtcir = "⩺";
var gt = ">";
var GT = ">";
var Gt = "≫";
var gtdot = "⋗";
var gtlPar = "⦕";
var gtquest = "⩼";
var gtrapprox = "⪆";
var gtrarr = "⥸";
var gtrdot = "⋗";
var gtreqless = "⋛";
var gtreqqless = "⪌";
var gtrless = "≷";
var gtrsim = "≳";
var gvertneqq = "≩︀";
var gvnE = "≩︀";
var Hacek = "ˇ";
var hairsp = " ";
var half = "½";
var hamilt = "ℋ";
var HARDcy = "Ъ";
var hardcy = "ъ";
var harrcir = "⥈";
var harr = "↔";
var hArr = "⇔";
var harrw = "↭";
var Hat = "^";
var hbar = "ℏ";
var Hcirc = "Ĥ";
var hcirc = "ĥ";
var hearts = "♥";
var heartsuit = "♥";
var hellip = "…";
var hercon = "⊹";
var hfr = "𝔥";
var Hfr = "ℌ";
var HilbertSpace = "ℋ";
var hksearow = "⤥";
var hkswarow = "⤦";
var hoarr = "⇿";
var homtht = "∻";
var hookleftarrow = "↩";
var hookrightarrow = "↪";
var hopf = "𝕙";
var Hopf = "ℍ";
var horbar = "―";
var HorizontalLine = "─";
var hscr = "𝒽";
var Hscr = "ℋ";
var hslash = "ℏ";
var Hstrok = "Ħ";
var hstrok = "ħ";
var HumpDownHump = "≎";
var HumpEqual = "≏";
var hybull = "⁃";
var hyphen = "‐";
var Iacute = "Í";
var iacute = "í";
var ic = "⁣";
var Icirc = "Î";
var icirc = "î";
var Icy = "И";
var icy = "и";
var Idot = "İ";
var IEcy = "Е";
var iecy = "е";
var iexcl = "¡";
var iff = "⇔";
var ifr = "𝔦";
var Ifr = "ℑ";
var Igrave = "Ì";
var igrave = "ì";
var ii = "ⅈ";
var iiiint = "⨌";
var iiint = "∭";
var iinfin = "⧜";
var iiota = "℩";
var IJlig = "Ĳ";
var ijlig = "ĳ";
var Imacr = "Ī";
var imacr = "ī";
var image = "ℑ";
var ImaginaryI = "ⅈ";
var imagline = "ℐ";
var imagpart = "ℑ";
var imath = "ı";
var Im = "ℑ";
var imof = "⊷";
var imped = "Ƶ";
var Implies = "⇒";
var incare = "℅";
var infin = "∞";
var infintie = "⧝";
var inodot = "ı";
var intcal = "⊺";
var int = "∫";
var Int = "∬";
var integers = "ℤ";
var Integral = "∫";
var intercal = "⊺";
var Intersection = "⋂";
var intlarhk = "⨗";
var intprod = "⨼";
var InvisibleComma = "⁣";
var InvisibleTimes = "⁢";
var IOcy = "Ё";
var iocy = "ё";
var Iogon = "Į";
var iogon = "į";
var Iopf = "𝕀";
var iopf = "𝕚";
var Iota = "Ι";
var iota = "ι";
var iprod = "⨼";
var iquest = "¿";
var iscr = "𝒾";
var Iscr = "ℐ";
var isin = "∈";
var isindot = "⋵";
var isinE = "⋹";
var isins = "⋴";
var isinsv = "⋳";
var isinv = "∈";
var it = "⁢";
var Itilde = "Ĩ";
var itilde = "ĩ";
var Iukcy = "І";
var iukcy = "і";
var Iuml = "Ï";
var iuml = "ï";
var Jcirc = "Ĵ";
var jcirc = "ĵ";
var Jcy = "Й";
var jcy = "й";
var Jfr = "𝔍";
var jfr = "𝔧";
var jmath = "ȷ";
var Jopf = "𝕁";
var jopf = "𝕛";
var Jscr = "𝒥";
var jscr = "𝒿";
var Jsercy = "Ј";
var jsercy = "ј";
var Jukcy = "Є";
var jukcy = "є";
var Kappa = "Κ";
var kappa = "κ";
var kappav = "ϰ";
var Kcedil = "Ķ";
var kcedil = "ķ";
var Kcy = "К";
var kcy = "к";
var Kfr = "𝔎";
var kfr = "𝔨";
var kgreen = "ĸ";
var KHcy = "Х";
var khcy = "х";
var KJcy = "Ќ";
var kjcy = "ќ";
var Kopf = "𝕂";
var kopf = "𝕜";
var Kscr = "𝒦";
var kscr = "𝓀";
var lAarr = "⇚";
var Lacute = "Ĺ";
var lacute = "ĺ";
var laemptyv = "⦴";
var lagran = "ℒ";
var Lambda = "Λ";
var lambda = "λ";
var lang = "⟨";
var Lang = "⟪";
var langd = "⦑";
var langle = "⟨";
var lap = "⪅";
var Laplacetrf = "ℒ";
var laquo = "«";
var larrb = "⇤";
var larrbfs = "⤟";
var larr = "←";
var Larr = "↞";
var lArr = "⇐";
var larrfs = "⤝";
var larrhk = "↩";
var larrlp = "↫";
var larrpl = "⤹";
var larrsim = "⥳";
var larrtl = "↢";
var latail = "⤙";
var lAtail = "⤛";
var lat = "⪫";
var late = "⪭";
var lates = "⪭︀";
var lbarr = "⤌";
var lBarr = "⤎";
var lbbrk = "❲";
var lbrace = "{";
var lbrack = "[";
var lbrke = "⦋";
var lbrksld = "⦏";
var lbrkslu = "⦍";
var Lcaron = "Ľ";
var lcaron = "ľ";
var Lcedil = "Ļ";
var lcedil = "ļ";
var lceil = "⌈";
var lcub = "{";
var Lcy = "Л";
var lcy = "л";
var ldca = "⤶";
var ldquo = "“";
var ldquor = "„";
var ldrdhar = "⥧";
var ldrushar = "⥋";
var ldsh = "↲";
var le = "≤";
var lE = "≦";
var LeftAngleBracket = "⟨";
var LeftArrowBar = "⇤";
var leftarrow = "←";
var LeftArrow = "←";
var Leftarrow = "⇐";
var LeftArrowRightArrow = "⇆";
var leftarrowtail = "↢";
var LeftCeiling = "⌈";
var LeftDoubleBracket = "⟦";
var LeftDownTeeVector = "⥡";
var LeftDownVectorBar = "⥙";
var LeftDownVector = "⇃";
var LeftFloor = "⌊";
var leftharpoondown = "↽";
var leftharpoonup = "↼";
var leftleftarrows = "⇇";
var leftrightarrow = "↔";
var LeftRightArrow = "↔";
var Leftrightarrow = "⇔";
var leftrightarrows = "⇆";
var leftrightharpoons = "⇋";
var leftrightsquigarrow = "↭";
var LeftRightVector = "⥎";
var LeftTeeArrow = "↤";
var LeftTee = "⊣";
var LeftTeeVector = "⥚";
var leftthreetimes = "⋋";
var LeftTriangleBar = "⧏";
var LeftTriangle = "⊲";
var LeftTriangleEqual = "⊴";
var LeftUpDownVector = "⥑";
var LeftUpTeeVector = "⥠";
var LeftUpVectorBar = "⥘";
var LeftUpVector = "↿";
var LeftVectorBar = "⥒";
var LeftVector = "↼";
var lEg = "⪋";
var leg = "⋚";
var leq = "≤";
var leqq = "≦";
var leqslant = "⩽";
var lescc = "⪨";
var les = "⩽";
var lesdot = "⩿";
var lesdoto = "⪁";
var lesdotor = "⪃";
var lesg = "⋚︀";
var lesges = "⪓";
var lessapprox = "⪅";
var lessdot = "⋖";
var lesseqgtr = "⋚";
var lesseqqgtr = "⪋";
var LessEqualGreater = "⋚";
var LessFullEqual = "≦";
var LessGreater = "≶";
var lessgtr = "≶";
var LessLess = "⪡";
var lesssim = "≲";
var LessSlantEqual = "⩽";
var LessTilde = "≲";
var lfisht = "⥼";
var lfloor = "⌊";
var Lfr = "𝔏";
var lfr = "𝔩";
var lg = "≶";
var lgE = "⪑";
var lHar = "⥢";
var lhard = "↽";
var lharu = "↼";
var lharul = "⥪";
var lhblk = "▄";
var LJcy = "Љ";
var ljcy = "љ";
var llarr = "⇇";
var ll = "≪";
var Ll = "⋘";
var llcorner = "⌞";
var Lleftarrow = "⇚";
var llhard = "⥫";
var lltri = "◺";
var Lmidot = "Ŀ";
var lmidot = "ŀ";
var lmoustache = "⎰";
var lmoust = "⎰";
var lnap = "⪉";
var lnapprox = "⪉";
var lne = "⪇";
var lnE = "≨";
var lneq = "⪇";
var lneqq = "≨";
var lnsim = "⋦";
var loang = "⟬";
var loarr = "⇽";
var lobrk = "⟦";
var longleftarrow = "⟵";
var LongLeftArrow = "⟵";
var Longleftarrow = "⟸";
var longleftrightarrow = "⟷";
var LongLeftRightArrow = "⟷";
var Longleftrightarrow = "⟺";
var longmapsto = "⟼";
var longrightarrow = "⟶";
var LongRightArrow = "⟶";
var Longrightarrow = "⟹";
var looparrowleft = "↫";
var looparrowright = "↬";
var lopar = "⦅";
var Lopf = "𝕃";
var lopf = "𝕝";
var loplus = "⨭";
var lotimes = "⨴";
var lowast = "∗";
var lowbar = "_";
var LowerLeftArrow = "↙";
var LowerRightArrow = "↘";
var loz = "◊";
var lozenge = "◊";
var lozf = "⧫";
var lpar = "(";
var lparlt = "⦓";
var lrarr = "⇆";
var lrcorner = "⌟";
var lrhar = "⇋";
var lrhard = "⥭";
var lrm = "‎";
var lrtri = "⊿";
var lsaquo = "‹";
var lscr = "𝓁";
var Lscr = "ℒ";
var lsh = "↰";
var Lsh = "↰";
var lsim = "≲";
var lsime = "⪍";
var lsimg = "⪏";
var lsqb = "[";
var lsquo = "‘";
var lsquor = "‚";
var Lstrok = "Ł";
var lstrok = "ł";
var ltcc = "⪦";
var ltcir = "⩹";
var lt = "<";
var LT = "<";
var Lt = "≪";
var ltdot = "⋖";
var lthree = "⋋";
var ltimes = "⋉";
var ltlarr = "⥶";
var ltquest = "⩻";
var ltri = "◃";
var ltrie = "⊴";
var ltrif = "◂";
var ltrPar = "⦖";
var lurdshar = "⥊";
var luruhar = "⥦";
var lvertneqq = "≨︀";
var lvnE = "≨︀";
var macr = "¯";
var male = "♂";
var malt = "✠";
var maltese = "✠";
var map$1 = "↦";
var mapsto = "↦";
var mapstodown = "↧";
var mapstoleft = "↤";
var mapstoup = "↥";
var marker = "▮";
var mcomma = "⨩";
var Mcy = "М";
var mcy = "м";
var mdash = "—";
var mDDot = "∺";
var measuredangle = "∡";
var MediumSpace = " ";
var Mellintrf = "ℳ";
var Mfr = "𝔐";
var mfr = "𝔪";
var mho = "℧";
var micro = "µ";
var midast = "*";
var midcir = "⫰";
var mid = "∣";
var middot = "·";
var minusb = "⊟";
var minus = "−";
var minusd = "∸";
var minusdu = "⨪";
var MinusPlus = "∓";
var mlcp = "⫛";
var mldr = "…";
var mnplus = "∓";
var models = "⊧";
var Mopf = "𝕄";
var mopf = "𝕞";
var mp = "∓";
var mscr = "𝓂";
var Mscr = "ℳ";
var mstpos = "∾";
var Mu = "Μ";
var mu = "μ";
var multimap = "⊸";
var mumap = "⊸";
var nabla = "∇";
var Nacute = "Ń";
var nacute = "ń";
var nang = "∠⃒";
var nap = "≉";
var napE = "⩰̸";
var napid = "≋̸";
var napos = "ŉ";
var napprox = "≉";
var natural = "♮";
var naturals = "ℕ";
var natur = "♮";
var nbsp = " ";
var nbump = "≎̸";
var nbumpe = "≏̸";
var ncap = "⩃";
var Ncaron = "Ň";
var ncaron = "ň";
var Ncedil = "Ņ";
var ncedil = "ņ";
var ncong = "≇";
var ncongdot = "⩭̸";
var ncup = "⩂";
var Ncy = "Н";
var ncy = "н";
var ndash = "–";
var nearhk = "⤤";
var nearr = "↗";
var neArr = "⇗";
var nearrow = "↗";
var ne = "≠";
var nedot = "≐̸";
var NegativeMediumSpace = "​";
var NegativeThickSpace = "​";
var NegativeThinSpace = "​";
var NegativeVeryThinSpace = "​";
var nequiv = "≢";
var nesear = "⤨";
var nesim = "≂̸";
var NestedGreaterGreater = "≫";
var NestedLessLess = "≪";
var NewLine = "\n";
var nexist = "∄";
var nexists = "∄";
var Nfr = "𝔑";
var nfr = "𝔫";
var ngE = "≧̸";
var nge = "≱";
var ngeq = "≱";
var ngeqq = "≧̸";
var ngeqslant = "⩾̸";
var nges = "⩾̸";
var nGg = "⋙̸";
var ngsim = "≵";
var nGt = "≫⃒";
var ngt = "≯";
var ngtr = "≯";
var nGtv = "≫̸";
var nharr = "↮";
var nhArr = "⇎";
var nhpar = "⫲";
var ni = "∋";
var nis = "⋼";
var nisd = "⋺";
var niv = "∋";
var NJcy = "Њ";
var njcy = "њ";
var nlarr = "↚";
var nlArr = "⇍";
var nldr = "‥";
var nlE = "≦̸";
var nle = "≰";
var nleftarrow = "↚";
var nLeftarrow = "⇍";
var nleftrightarrow = "↮";
var nLeftrightarrow = "⇎";
var nleq = "≰";
var nleqq = "≦̸";
var nleqslant = "⩽̸";
var nles = "⩽̸";
var nless = "≮";
var nLl = "⋘̸";
var nlsim = "≴";
var nLt = "≪⃒";
var nlt = "≮";
var nltri = "⋪";
var nltrie = "⋬";
var nLtv = "≪̸";
var nmid = "∤";
var NoBreak = "⁠";
var NonBreakingSpace = " ";
var nopf = "𝕟";
var Nopf = "ℕ";
var Not = "⫬";
var not = "¬";
var NotCongruent = "≢";
var NotCupCap = "≭";
var NotDoubleVerticalBar = "∦";
var NotElement = "∉";
var NotEqual = "≠";
var NotEqualTilde = "≂̸";
var NotExists = "∄";
var NotGreater = "≯";
var NotGreaterEqual = "≱";
var NotGreaterFullEqual = "≧̸";
var NotGreaterGreater = "≫̸";
var NotGreaterLess = "≹";
var NotGreaterSlantEqual = "⩾̸";
var NotGreaterTilde = "≵";
var NotHumpDownHump = "≎̸";
var NotHumpEqual = "≏̸";
var notin = "∉";
var notindot = "⋵̸";
var notinE = "⋹̸";
var notinva = "∉";
var notinvb = "⋷";
var notinvc = "⋶";
var NotLeftTriangleBar = "⧏̸";
var NotLeftTriangle = "⋪";
var NotLeftTriangleEqual = "⋬";
var NotLess = "≮";
var NotLessEqual = "≰";
var NotLessGreater = "≸";
var NotLessLess = "≪̸";
var NotLessSlantEqual = "⩽̸";
var NotLessTilde = "≴";
var NotNestedGreaterGreater = "⪢̸";
var NotNestedLessLess = "⪡̸";
var notni = "∌";
var notniva = "∌";
var notnivb = "⋾";
var notnivc = "⋽";
var NotPrecedes = "⊀";
var NotPrecedesEqual = "⪯̸";
var NotPrecedesSlantEqual = "⋠";
var NotReverseElement = "∌";
var NotRightTriangleBar = "⧐̸";
var NotRightTriangle = "⋫";
var NotRightTriangleEqual = "⋭";
var NotSquareSubset = "⊏̸";
var NotSquareSubsetEqual = "⋢";
var NotSquareSuperset = "⊐̸";
var NotSquareSupersetEqual = "⋣";
var NotSubset = "⊂⃒";
var NotSubsetEqual = "⊈";
var NotSucceeds = "⊁";
var NotSucceedsEqual = "⪰̸";
var NotSucceedsSlantEqual = "⋡";
var NotSucceedsTilde = "≿̸";
var NotSuperset = "⊃⃒";
var NotSupersetEqual = "⊉";
var NotTilde = "≁";
var NotTildeEqual = "≄";
var NotTildeFullEqual = "≇";
var NotTildeTilde = "≉";
var NotVerticalBar = "∤";
var nparallel = "∦";
var npar = "∦";
var nparsl = "⫽⃥";
var npart = "∂̸";
var npolint = "⨔";
var npr = "⊀";
var nprcue = "⋠";
var nprec = "⊀";
var npreceq = "⪯̸";
var npre = "⪯̸";
var nrarrc = "⤳̸";
var nrarr = "↛";
var nrArr = "⇏";
var nrarrw = "↝̸";
var nrightarrow = "↛";
var nRightarrow = "⇏";
var nrtri = "⋫";
var nrtrie = "⋭";
var nsc = "⊁";
var nsccue = "⋡";
var nsce = "⪰̸";
var Nscr = "𝒩";
var nscr = "𝓃";
var nshortmid = "∤";
var nshortparallel = "∦";
var nsim = "≁";
var nsime = "≄";
var nsimeq = "≄";
var nsmid = "∤";
var nspar = "∦";
var nsqsube = "⋢";
var nsqsupe = "⋣";
var nsub = "⊄";
var nsubE = "⫅̸";
var nsube = "⊈";
var nsubset = "⊂⃒";
var nsubseteq = "⊈";
var nsubseteqq = "⫅̸";
var nsucc = "⊁";
var nsucceq = "⪰̸";
var nsup = "⊅";
var nsupE = "⫆̸";
var nsupe = "⊉";
var nsupset = "⊃⃒";
var nsupseteq = "⊉";
var nsupseteqq = "⫆̸";
var ntgl = "≹";
var Ntilde = "Ñ";
var ntilde = "ñ";
var ntlg = "≸";
var ntriangleleft = "⋪";
var ntrianglelefteq = "⋬";
var ntriangleright = "⋫";
var ntrianglerighteq = "⋭";
var Nu = "Ν";
var nu = "ν";
var num = "#";
var numero = "№";
var numsp = " ";
var nvap = "≍⃒";
var nvdash = "⊬";
var nvDash = "⊭";
var nVdash = "⊮";
var nVDash = "⊯";
var nvge = "≥⃒";
var nvgt = ">⃒";
var nvHarr = "⤄";
var nvinfin = "⧞";
var nvlArr = "⤂";
var nvle = "≤⃒";
var nvlt = "<⃒";
var nvltrie = "⊴⃒";
var nvrArr = "⤃";
var nvrtrie = "⊵⃒";
var nvsim = "∼⃒";
var nwarhk = "⤣";
var nwarr = "↖";
var nwArr = "⇖";
var nwarrow = "↖";
var nwnear = "⤧";
var Oacute = "Ó";
var oacute = "ó";
var oast = "⊛";
var Ocirc = "Ô";
var ocirc = "ô";
var ocir = "⊚";
var Ocy = "О";
var ocy = "о";
var odash = "⊝";
var Odblac = "Ő";
var odblac = "ő";
var odiv = "⨸";
var odot = "⊙";
var odsold = "⦼";
var OElig = "Œ";
var oelig = "œ";
var ofcir = "⦿";
var Ofr = "𝔒";
var ofr = "𝔬";
var ogon = "˛";
var Ograve = "Ò";
var ograve = "ò";
var ogt = "⧁";
var ohbar = "⦵";
var ohm = "Ω";
var oint = "∮";
var olarr = "↺";
var olcir = "⦾";
var olcross = "⦻";
var oline = "‾";
var olt = "⧀";
var Omacr = "Ō";
var omacr = "ō";
var Omega = "Ω";
var omega = "ω";
var Omicron = "Ο";
var omicron = "ο";
var omid = "⦶";
var ominus = "⊖";
var Oopf = "𝕆";
var oopf = "𝕠";
var opar = "⦷";
var OpenCurlyDoubleQuote = "“";
var OpenCurlyQuote = "‘";
var operp = "⦹";
var oplus = "⊕";
var orarr = "↻";
var Or = "⩔";
var or = "∨";
var ord = "⩝";
var order = "ℴ";
var orderof = "ℴ";
var ordf = "ª";
var ordm = "º";
var origof = "⊶";
var oror = "⩖";
var orslope = "⩗";
var orv = "⩛";
var oS = "Ⓢ";
var Oscr = "𝒪";
var oscr = "ℴ";
var Oslash = "Ø";
var oslash = "ø";
var osol = "⊘";
var Otilde = "Õ";
var otilde = "õ";
var otimesas = "⨶";
var Otimes = "⨷";
var otimes = "⊗";
var Ouml = "Ö";
var ouml = "ö";
var ovbar = "⌽";
var OverBar = "‾";
var OverBrace = "⏞";
var OverBracket = "⎴";
var OverParenthesis = "⏜";
var para = "¶";
var parallel = "∥";
var par = "∥";
var parsim = "⫳";
var parsl = "⫽";
var part = "∂";
var PartialD = "∂";
var Pcy = "П";
var pcy = "п";
var percnt = "%";
var period = ".";
var permil = "‰";
var perp = "⊥";
var pertenk = "‱";
var Pfr = "𝔓";
var pfr = "𝔭";
var Phi = "Φ";
var phi = "φ";
var phiv = "ϕ";
var phmmat = "ℳ";
var phone = "☎";
var Pi = "Π";
var pi = "π";
var pitchfork = "⋔";
var piv = "ϖ";
var planck = "ℏ";
var planckh = "ℎ";
var plankv = "ℏ";
var plusacir = "⨣";
var plusb = "⊞";
var pluscir = "⨢";
var plus = "+";
var plusdo = "∔";
var plusdu = "⨥";
var pluse = "⩲";
var PlusMinus = "±";
var plusmn = "±";
var plussim = "⨦";
var plustwo = "⨧";
var pm = "±";
var Poincareplane = "ℌ";
var pointint = "⨕";
var popf = "𝕡";
var Popf = "ℙ";
var pound = "£";
var prap = "⪷";
var Pr = "⪻";
var pr = "≺";
var prcue = "≼";
var precapprox = "⪷";
var prec = "≺";
var preccurlyeq = "≼";
var Precedes = "≺";
var PrecedesEqual = "⪯";
var PrecedesSlantEqual = "≼";
var PrecedesTilde = "≾";
var preceq = "⪯";
var precnapprox = "⪹";
var precneqq = "⪵";
var precnsim = "⋨";
var pre = "⪯";
var prE = "⪳";
var precsim = "≾";
var prime = "′";
var Prime = "″";
var primes = "ℙ";
var prnap = "⪹";
var prnE = "⪵";
var prnsim = "⋨";
var prod = "∏";
var Product = "∏";
var profalar = "⌮";
var profline = "⌒";
var profsurf = "⌓";
var prop = "∝";
var Proportional = "∝";
var Proportion = "∷";
var propto = "∝";
var prsim = "≾";
var prurel = "⊰";
var Pscr = "𝒫";
var pscr = "𝓅";
var Psi = "Ψ";
var psi = "ψ";
var puncsp = " ";
var Qfr = "𝔔";
var qfr = "𝔮";
var qint = "⨌";
var qopf = "𝕢";
var Qopf = "ℚ";
var qprime = "⁗";
var Qscr = "𝒬";
var qscr = "𝓆";
var quaternions = "ℍ";
var quatint = "⨖";
var quest = "?";
var questeq = "≟";
var quot = "\"";
var QUOT = "\"";
var rAarr = "⇛";
var race = "∽̱";
var Racute = "Ŕ";
var racute = "ŕ";
var radic = "√";
var raemptyv = "⦳";
var rang = "⟩";
var Rang = "⟫";
var rangd = "⦒";
var range = "⦥";
var rangle = "⟩";
var raquo = "»";
var rarrap = "⥵";
var rarrb = "⇥";
var rarrbfs = "⤠";
var rarrc = "⤳";
var rarr = "→";
var Rarr = "↠";
var rArr = "⇒";
var rarrfs = "⤞";
var rarrhk = "↪";
var rarrlp = "↬";
var rarrpl = "⥅";
var rarrsim = "⥴";
var Rarrtl = "⤖";
var rarrtl = "↣";
var rarrw = "↝";
var ratail = "⤚";
var rAtail = "⤜";
var ratio = "∶";
var rationals = "ℚ";
var rbarr = "⤍";
var rBarr = "⤏";
var RBarr = "⤐";
var rbbrk = "❳";
var rbrace = "}";
var rbrack = "]";
var rbrke = "⦌";
var rbrksld = "⦎";
var rbrkslu = "⦐";
var Rcaron = "Ř";
var rcaron = "ř";
var Rcedil = "Ŗ";
var rcedil = "ŗ";
var rceil = "⌉";
var rcub = "}";
var Rcy = "Р";
var rcy = "р";
var rdca = "⤷";
var rdldhar = "⥩";
var rdquo = "”";
var rdquor = "”";
var rdsh = "↳";
var real = "ℜ";
var realine = "ℛ";
var realpart = "ℜ";
var reals = "ℝ";
var Re = "ℜ";
var rect = "▭";
var reg = "®";
var REG = "®";
var ReverseElement = "∋";
var ReverseEquilibrium = "⇋";
var ReverseUpEquilibrium = "⥯";
var rfisht = "⥽";
var rfloor = "⌋";
var rfr = "𝔯";
var Rfr = "ℜ";
var rHar = "⥤";
var rhard = "⇁";
var rharu = "⇀";
var rharul = "⥬";
var Rho = "Ρ";
var rho = "ρ";
var rhov = "ϱ";
var RightAngleBracket = "⟩";
var RightArrowBar = "⇥";
var rightarrow = "→";
var RightArrow = "→";
var Rightarrow = "⇒";
var RightArrowLeftArrow = "⇄";
var rightarrowtail = "↣";
var RightCeiling = "⌉";
var RightDoubleBracket = "⟧";
var RightDownTeeVector = "⥝";
var RightDownVectorBar = "⥕";
var RightDownVector = "⇂";
var RightFloor = "⌋";
var rightharpoondown = "⇁";
var rightharpoonup = "⇀";
var rightleftarrows = "⇄";
var rightleftharpoons = "⇌";
var rightrightarrows = "⇉";
var rightsquigarrow = "↝";
var RightTeeArrow = "↦";
var RightTee = "⊢";
var RightTeeVector = "⥛";
var rightthreetimes = "⋌";
var RightTriangleBar = "⧐";
var RightTriangle = "⊳";
var RightTriangleEqual = "⊵";
var RightUpDownVector = "⥏";
var RightUpTeeVector = "⥜";
var RightUpVectorBar = "⥔";
var RightUpVector = "↾";
var RightVectorBar = "⥓";
var RightVector = "⇀";
var ring = "˚";
var risingdotseq = "≓";
var rlarr = "⇄";
var rlhar = "⇌";
var rlm = "‏";
var rmoustache = "⎱";
var rmoust = "⎱";
var rnmid = "⫮";
var roang = "⟭";
var roarr = "⇾";
var robrk = "⟧";
var ropar = "⦆";
var ropf = "𝕣";
var Ropf = "ℝ";
var roplus = "⨮";
var rotimes = "⨵";
var RoundImplies = "⥰";
var rpar = ")";
var rpargt = "⦔";
var rppolint = "⨒";
var rrarr = "⇉";
var Rrightarrow = "⇛";
var rsaquo = "›";
var rscr = "𝓇";
var Rscr = "ℛ";
var rsh = "↱";
var Rsh = "↱";
var rsqb = "]";
var rsquo = "’";
var rsquor = "’";
var rthree = "⋌";
var rtimes = "⋊";
var rtri = "▹";
var rtrie = "⊵";
var rtrif = "▸";
var rtriltri = "⧎";
var RuleDelayed = "⧴";
var ruluhar = "⥨";
var rx = "℞";
var Sacute = "Ś";
var sacute = "ś";
var sbquo = "‚";
var scap = "⪸";
var Scaron = "Š";
var scaron = "š";
var Sc = "⪼";
var sc = "≻";
var sccue = "≽";
var sce = "⪰";
var scE = "⪴";
var Scedil = "Ş";
var scedil = "ş";
var Scirc = "Ŝ";
var scirc = "ŝ";
var scnap = "⪺";
var scnE = "⪶";
var scnsim = "⋩";
var scpolint = "⨓";
var scsim = "≿";
var Scy = "С";
var scy = "с";
var sdotb = "⊡";
var sdot = "⋅";
var sdote = "⩦";
var searhk = "⤥";
var searr = "↘";
var seArr = "⇘";
var searrow = "↘";
var sect = "§";
var semi = ";";
var seswar = "⤩";
var setminus = "∖";
var setmn = "∖";
var sext = "✶";
var Sfr = "𝔖";
var sfr = "𝔰";
var sfrown = "⌢";
var sharp = "♯";
var SHCHcy = "Щ";
var shchcy = "щ";
var SHcy = "Ш";
var shcy = "ш";
var ShortDownArrow = "↓";
var ShortLeftArrow = "←";
var shortmid = "∣";
var shortparallel = "∥";
var ShortRightArrow = "→";
var ShortUpArrow = "↑";
var shy = "­";
var Sigma = "Σ";
var sigma = "σ";
var sigmaf = "ς";
var sigmav = "ς";
var sim = "∼";
var simdot = "⩪";
var sime = "≃";
var simeq = "≃";
var simg = "⪞";
var simgE = "⪠";
var siml = "⪝";
var simlE = "⪟";
var simne = "≆";
var simplus = "⨤";
var simrarr = "⥲";
var slarr = "←";
var SmallCircle = "∘";
var smallsetminus = "∖";
var smashp = "⨳";
var smeparsl = "⧤";
var smid = "∣";
var smile = "⌣";
var smt = "⪪";
var smte = "⪬";
var smtes = "⪬︀";
var SOFTcy = "Ь";
var softcy = "ь";
var solbar = "⌿";
var solb = "⧄";
var sol = "/";
var Sopf = "𝕊";
var sopf = "𝕤";
var spades = "♠";
var spadesuit = "♠";
var spar = "∥";
var sqcap = "⊓";
var sqcaps = "⊓︀";
var sqcup = "⊔";
var sqcups = "⊔︀";
var Sqrt = "√";
var sqsub = "⊏";
var sqsube = "⊑";
var sqsubset = "⊏";
var sqsubseteq = "⊑";
var sqsup = "⊐";
var sqsupe = "⊒";
var sqsupset = "⊐";
var sqsupseteq = "⊒";
var square = "□";
var Square = "□";
var SquareIntersection = "⊓";
var SquareSubset = "⊏";
var SquareSubsetEqual = "⊑";
var SquareSuperset = "⊐";
var SquareSupersetEqual = "⊒";
var SquareUnion = "⊔";
var squarf = "▪";
var squ = "□";
var squf = "▪";
var srarr = "→";
var Sscr = "𝒮";
var sscr = "𝓈";
var ssetmn = "∖";
var ssmile = "⌣";
var sstarf = "⋆";
var Star = "⋆";
var star = "☆";
var starf = "★";
var straightepsilon = "ϵ";
var straightphi = "ϕ";
var strns = "¯";
var sub = "⊂";
var Sub = "⋐";
var subdot = "⪽";
var subE = "⫅";
var sube = "⊆";
var subedot = "⫃";
var submult = "⫁";
var subnE = "⫋";
var subne = "⊊";
var subplus = "⪿";
var subrarr = "⥹";
var subset = "⊂";
var Subset = "⋐";
var subseteq = "⊆";
var subseteqq = "⫅";
var SubsetEqual = "⊆";
var subsetneq = "⊊";
var subsetneqq = "⫋";
var subsim = "⫇";
var subsub = "⫕";
var subsup = "⫓";
var succapprox = "⪸";
var succ = "≻";
var succcurlyeq = "≽";
var Succeeds = "≻";
var SucceedsEqual = "⪰";
var SucceedsSlantEqual = "≽";
var SucceedsTilde = "≿";
var succeq = "⪰";
var succnapprox = "⪺";
var succneqq = "⪶";
var succnsim = "⋩";
var succsim = "≿";
var SuchThat = "∋";
var sum = "∑";
var Sum = "∑";
var sung = "♪";
var sup1 = "¹";
var sup2 = "²";
var sup3 = "³";
var sup = "⊃";
var Sup = "⋑";
var supdot = "⪾";
var supdsub = "⫘";
var supE = "⫆";
var supe = "⊇";
var supedot = "⫄";
var Superset = "⊃";
var SupersetEqual = "⊇";
var suphsol = "⟉";
var suphsub = "⫗";
var suplarr = "⥻";
var supmult = "⫂";
var supnE = "⫌";
var supne = "⊋";
var supplus = "⫀";
var supset = "⊃";
var Supset = "⋑";
var supseteq = "⊇";
var supseteqq = "⫆";
var supsetneq = "⊋";
var supsetneqq = "⫌";
var supsim = "⫈";
var supsub = "⫔";
var supsup = "⫖";
var swarhk = "⤦";
var swarr = "↙";
var swArr = "⇙";
var swarrow = "↙";
var swnwar = "⤪";
var szlig = "ß";
var Tab = "\t";
var target = "⌖";
var Tau = "Τ";
var tau = "τ";
var tbrk = "⎴";
var Tcaron = "Ť";
var tcaron = "ť";
var Tcedil = "Ţ";
var tcedil = "ţ";
var Tcy = "Т";
var tcy = "т";
var tdot = "⃛";
var telrec = "⌕";
var Tfr = "𝔗";
var tfr = "𝔱";
var there4 = "∴";
var therefore = "∴";
var Therefore = "∴";
var Theta = "Θ";
var theta = "θ";
var thetasym = "ϑ";
var thetav = "ϑ";
var thickapprox = "≈";
var thicksim = "∼";
var ThickSpace = "  ";
var ThinSpace = " ";
var thinsp = " ";
var thkap = "≈";
var thksim = "∼";
var THORN = "Þ";
var thorn = "þ";
var tilde = "˜";
var Tilde = "∼";
var TildeEqual = "≃";
var TildeFullEqual = "≅";
var TildeTilde = "≈";
var timesbar = "⨱";
var timesb = "⊠";
var times = "×";
var timesd = "⨰";
var tint = "∭";
var toea = "⤨";
var topbot = "⌶";
var topcir = "⫱";
var top = "⊤";
var Topf = "𝕋";
var topf = "𝕥";
var topfork = "⫚";
var tosa = "⤩";
var tprime = "‴";
var trade = "™";
var TRADE = "™";
var triangle = "▵";
var triangledown = "▿";
var triangleleft = "◃";
var trianglelefteq = "⊴";
var triangleq = "≜";
var triangleright = "▹";
var trianglerighteq = "⊵";
var tridot = "◬";
var trie = "≜";
var triminus = "⨺";
var TripleDot = "⃛";
var triplus = "⨹";
var trisb = "⧍";
var tritime = "⨻";
var trpezium = "⏢";
var Tscr = "𝒯";
var tscr = "𝓉";
var TScy = "Ц";
var tscy = "ц";
var TSHcy = "Ћ";
var tshcy = "ћ";
var Tstrok = "Ŧ";
var tstrok = "ŧ";
var twixt = "≬";
var twoheadleftarrow = "↞";
var twoheadrightarrow = "↠";
var Uacute = "Ú";
var uacute = "ú";
var uarr = "↑";
var Uarr = "↟";
var uArr = "⇑";
var Uarrocir = "⥉";
var Ubrcy = "Ў";
var ubrcy = "ў";
var Ubreve = "Ŭ";
var ubreve = "ŭ";
var Ucirc = "Û";
var ucirc = "û";
var Ucy = "У";
var ucy = "у";
var udarr = "⇅";
var Udblac = "Ű";
var udblac = "ű";
var udhar = "⥮";
var ufisht = "⥾";
var Ufr = "𝔘";
var ufr = "𝔲";
var Ugrave = "Ù";
var ugrave = "ù";
var uHar = "⥣";
var uharl = "↿";
var uharr = "↾";
var uhblk = "▀";
var ulcorn = "⌜";
var ulcorner = "⌜";
var ulcrop = "⌏";
var ultri = "◸";
var Umacr = "Ū";
var umacr = "ū";
var uml = "¨";
var UnderBar = "_";
var UnderBrace = "⏟";
var UnderBracket = "⎵";
var UnderParenthesis = "⏝";
var Union = "⋃";
var UnionPlus = "⊎";
var Uogon = "Ų";
var uogon = "ų";
var Uopf = "𝕌";
var uopf = "𝕦";
var UpArrowBar = "⤒";
var uparrow = "↑";
var UpArrow = "↑";
var Uparrow = "⇑";
var UpArrowDownArrow = "⇅";
var updownarrow = "↕";
var UpDownArrow = "↕";
var Updownarrow = "⇕";
var UpEquilibrium = "⥮";
var upharpoonleft = "↿";
var upharpoonright = "↾";
var uplus = "⊎";
var UpperLeftArrow = "↖";
var UpperRightArrow = "↗";
var upsi = "υ";
var Upsi = "ϒ";
var upsih = "ϒ";
var Upsilon = "Υ";
var upsilon = "υ";
var UpTeeArrow = "↥";
var UpTee = "⊥";
var upuparrows = "⇈";
var urcorn = "⌝";
var urcorner = "⌝";
var urcrop = "⌎";
var Uring = "Ů";
var uring = "ů";
var urtri = "◹";
var Uscr = "𝒰";
var uscr = "𝓊";
var utdot = "⋰";
var Utilde = "Ũ";
var utilde = "ũ";
var utri = "▵";
var utrif = "▴";
var uuarr = "⇈";
var Uuml = "Ü";
var uuml = "ü";
var uwangle = "⦧";
var vangrt = "⦜";
var varepsilon = "ϵ";
var varkappa = "ϰ";
var varnothing = "∅";
var varphi = "ϕ";
var varpi = "ϖ";
var varpropto = "∝";
var varr = "↕";
var vArr = "⇕";
var varrho = "ϱ";
var varsigma = "ς";
var varsubsetneq = "⊊︀";
var varsubsetneqq = "⫋︀";
var varsupsetneq = "⊋︀";
var varsupsetneqq = "⫌︀";
var vartheta = "ϑ";
var vartriangleleft = "⊲";
var vartriangleright = "⊳";
var vBar = "⫨";
var Vbar = "⫫";
var vBarv = "⫩";
var Vcy = "В";
var vcy = "в";
var vdash = "⊢";
var vDash = "⊨";
var Vdash = "⊩";
var VDash = "⊫";
var Vdashl = "⫦";
var veebar = "⊻";
var vee = "∨";
var Vee = "⋁";
var veeeq = "≚";
var vellip = "⋮";
var verbar = "|";
var Verbar = "‖";
var vert = "|";
var Vert = "‖";
var VerticalBar = "∣";
var VerticalLine = "|";
var VerticalSeparator = "❘";
var VerticalTilde = "≀";
var VeryThinSpace = " ";
var Vfr = "𝔙";
var vfr = "𝔳";
var vltri = "⊲";
var vnsub = "⊂⃒";
var vnsup = "⊃⃒";
var Vopf = "𝕍";
var vopf = "𝕧";
var vprop = "∝";
var vrtri = "⊳";
var Vscr = "𝒱";
var vscr = "𝓋";
var vsubnE = "⫋︀";
var vsubne = "⊊︀";
var vsupnE = "⫌︀";
var vsupne = "⊋︀";
var Vvdash = "⊪";
var vzigzag = "⦚";
var Wcirc = "Ŵ";
var wcirc = "ŵ";
var wedbar = "⩟";
var wedge = "∧";
var Wedge = "⋀";
var wedgeq = "≙";
var weierp = "℘";
var Wfr = "𝔚";
var wfr = "𝔴";
var Wopf = "𝕎";
var wopf = "𝕨";
var wp = "℘";
var wr = "≀";
var wreath = "≀";
var Wscr = "𝒲";
var wscr = "𝓌";
var xcap = "⋂";
var xcirc = "◯";
var xcup = "⋃";
var xdtri = "▽";
var Xfr = "𝔛";
var xfr = "𝔵";
var xharr = "⟷";
var xhArr = "⟺";
var Xi = "Ξ";
var xi = "ξ";
var xlarr = "⟵";
var xlArr = "⟸";
var xmap = "⟼";
var xnis = "⋻";
var xodot = "⨀";
var Xopf = "𝕏";
var xopf = "𝕩";
var xoplus = "⨁";
var xotime = "⨂";
var xrarr = "⟶";
var xrArr = "⟹";
var Xscr = "𝒳";
var xscr = "𝓍";
var xsqcup = "⨆";
var xuplus = "⨄";
var xutri = "△";
var xvee = "⋁";
var xwedge = "⋀";
var Yacute = "Ý";
var yacute = "ý";
var YAcy = "Я";
var yacy = "я";
var Ycirc = "Ŷ";
var ycirc = "ŷ";
var Ycy = "Ы";
var ycy = "ы";
var yen = "¥";
var Yfr = "𝔜";
var yfr = "𝔶";
var YIcy = "Ї";
var yicy = "ї";
var Yopf = "𝕐";
var yopf = "𝕪";
var Yscr = "𝒴";
var yscr = "𝓎";
var YUcy = "Ю";
var yucy = "ю";
var yuml = "ÿ";
var Yuml = "Ÿ";
var Zacute = "Ź";
var zacute = "ź";
var Zcaron = "Ž";
var zcaron = "ž";
var Zcy = "З";
var zcy = "з";
var Zdot = "Ż";
var zdot = "ż";
var zeetrf = "ℨ";
var ZeroWidthSpace = "​";
var Zeta = "Ζ";
var zeta = "ζ";
var zfr = "𝔷";
var Zfr = "ℨ";
var ZHcy = "Ж";
var zhcy = "ж";
var zigrarr = "⇝";
var zopf = "𝕫";
var Zopf = "ℤ";
var Zscr = "𝒵";
var zscr = "𝓏";
var zwj = "‍";
var zwnj = "‌";
var entities$1 = {
	Aacute: Aacute,
	aacute: aacute,
	Abreve: Abreve,
	abreve: abreve,
	ac: ac,
	acd: acd,
	acE: acE,
	Acirc: Acirc,
	acirc: acirc,
	acute: acute,
	Acy: Acy,
	acy: acy,
	AElig: AElig,
	aelig: aelig,
	af: af,
	Afr: Afr,
	afr: afr,
	Agrave: Agrave,
	agrave: agrave,
	alefsym: alefsym,
	aleph: aleph,
	Alpha: Alpha,
	alpha: alpha,
	Amacr: Amacr,
	amacr: amacr,
	amalg: amalg,
	amp: amp,
	AMP: AMP,
	andand: andand,
	And: And,
	and: and,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angmsd: angmsd,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	Aogon: Aogon,
	aogon: aogon,
	Aopf: Aopf,
	aopf: aopf,
	apacir: apacir,
	ap: ap,
	apE: apE,
	ape: ape,
	apid: apid,
	apos: apos,
	ApplyFunction: ApplyFunction,
	approx: approx,
	approxeq: approxeq,
	Aring: Aring,
	aring: aring,
	Ascr: Ascr,
	ascr: ascr,
	Assign: Assign,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	Atilde: Atilde,
	atilde: atilde,
	Auml: Auml,
	auml: auml,
	awconint: awconint,
	awint: awint,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	Backslash: Backslash,
	Barv: Barv,
	barvee: barvee,
	barwed: barwed,
	Barwed: Barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	Bcy: Bcy,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	Because: Because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	Bernoullis: Bernoullis,
	Beta: Beta,
	beta: beta,
	beth: beth,
	between: between,
	Bfr: Bfr,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block,
	bne: bne,
	bnequiv: bnequiv,
	bNot: bNot,
	bnot: bnot,
	Bopf: Bopf,
	bopf: bopf,
	bot: bot,
	bottom: bottom,
	bowtie: bowtie,
	boxbox: boxbox,
	boxdl: boxdl,
	boxdL: boxdL,
	boxDl: boxDl,
	boxDL: boxDL,
	boxdr: boxdr,
	boxdR: boxdR,
	boxDr: boxDr,
	boxDR: boxDR,
	boxh: boxh,
	boxH: boxH,
	boxhd: boxhd,
	boxHd: boxHd,
	boxhD: boxhD,
	boxHD: boxHD,
	boxhu: boxhu,
	boxHu: boxHu,
	boxhU: boxhU,
	boxHU: boxHU,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxul: boxul,
	boxuL: boxuL,
	boxUl: boxUl,
	boxUL: boxUL,
	boxur: boxur,
	boxuR: boxuR,
	boxUr: boxUr,
	boxUR: boxUR,
	boxv: boxv,
	boxV: boxV,
	boxvh: boxvh,
	boxvH: boxvH,
	boxVh: boxVh,
	boxVH: boxVH,
	boxvl: boxvl,
	boxvL: boxvL,
	boxVl: boxVl,
	boxVL: boxVL,
	boxvr: boxvr,
	boxvR: boxvR,
	boxVr: boxVr,
	boxVR: boxVR,
	bprime: bprime,
	breve: breve,
	Breve: Breve,
	brvbar: brvbar,
	bscr: bscr,
	Bscr: Bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsolb: bsolb,
	bsol: bsol,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	Bumpeq: Bumpeq,
	bumpeq: bumpeq,
	Cacute: Cacute,
	cacute: cacute,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	cap: cap,
	Cap: Cap,
	capcup: capcup,
	capdot: capdot,
	CapitalDifferentialD: CapitalDifferentialD,
	caps: caps,
	caret: caret,
	caron: caron,
	Cayleys: Cayleys,
	ccaps: ccaps,
	Ccaron: Ccaron,
	ccaron: ccaron,
	Ccedil: Ccedil,
	ccedil: ccedil,
	Ccirc: Ccirc,
	ccirc: ccirc,
	Cconint: Cconint,
	ccups: ccups,
	ccupssm: ccupssm,
	Cdot: Cdot,
	cdot: cdot,
	cedil: cedil,
	Cedilla: Cedilla,
	cemptyv: cemptyv,
	cent: cent,
	centerdot: centerdot,
	CenterDot: CenterDot,
	cfr: cfr,
	Cfr: Cfr,
	CHcy: CHcy,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	Chi: Chi,
	chi: chi,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	CircleDot: CircleDot,
	circledR: circledR,
	circledS: circledS,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	cir: cir,
	cirE: cirE,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	Colon: Colon,
	Colone: Colone,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	Congruent: Congruent,
	conint: conint,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	copf: copf,
	Copf: Copf,
	coprod: coprod,
	Coproduct: Coproduct,
	copy: copy,
	COPY: COPY,
	copysr: copysr,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	crarr: crarr,
	cross: cross,
	Cross: Cross,
	Cscr: Cscr,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	CupCap: CupCap,
	cup: cup,
	Cup: Cup,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curren: curren,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dagger: dagger,
	Dagger: Dagger,
	daleth: daleth,
	darr: darr,
	Darr: Darr,
	dArr: dArr,
	dash: dash,
	Dashv: Dashv,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	Dcaron: Dcaron,
	dcaron: dcaron,
	Dcy: Dcy,
	dcy: dcy,
	ddagger: ddagger,
	ddarr: ddarr,
	DD: DD,
	dd: dd,
	DDotrahd: DDotrahd,
	ddotseq: ddotseq,
	deg: deg,
	Del: Del,
	Delta: Delta,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	Dfr: Dfr,
	dfr: dfr,
	dHar: dHar,
	dharl: dharl,
	dharr: dharr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	diam: diam,
	diamond: diamond,
	Diamond: Diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	DifferentialD: DifferentialD,
	digamma: digamma,
	disin: disin,
	div: div,
	divide: divide,
	divideontimes: divideontimes,
	divonx: divonx,
	DJcy: DJcy,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	Dopf: Dopf,
	dopf: dopf,
	Dot: Dot,
	dot: dot,
	DotDot: DotDot,
	doteq: doteq,
	doteqdot: doteqdot,
	DotEqual: DotEqual,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrowBar: DownArrowBar,
	downarrow: downarrow,
	DownArrow: DownArrow,
	Downarrow: Downarrow,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownLeftVector: DownLeftVector,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVectorBar: DownRightVectorBar,
	DownRightVector: DownRightVector,
	DownTeeArrow: DownTeeArrow,
	DownTee: DownTee,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	Dscr: Dscr,
	dscr: dscr,
	DScy: DScy,
	dscy: dscy,
	dsol: dsol,
	Dstrok: Dstrok,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	DZcy: DZcy,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	Eacute: Eacute,
	eacute: eacute,
	easter: easter,
	Ecaron: Ecaron,
	ecaron: ecaron,
	Ecirc: Ecirc,
	ecirc: ecirc,
	ecir: ecir,
	ecolon: ecolon,
	Ecy: Ecy,
	ecy: ecy,
	eDDot: eDDot,
	Edot: Edot,
	edot: edot,
	eDot: eDot,
	ee: ee,
	efDot: efDot,
	Efr: Efr,
	efr: efr,
	eg: eg,
	Egrave: Egrave,
	egrave: egrave,
	egs: egs,
	egsdot: egsdot,
	el: el,
	Element: Element,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	Emacr: Emacr,
	emacr: emacr,
	empty: empty,
	emptyset: emptyset,
	EmptySmallSquare: EmptySmallSquare,
	emptyv: emptyv,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	ENG: ENG,
	eng: eng,
	ensp: ensp,
	Eogon: Eogon,
	eogon: eogon,
	Eopf: Eopf,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	Epsilon: Epsilon,
	epsilon: epsilon,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	Equal: Equal,
	equals: equals,
	EqualTilde: EqualTilde,
	equest: equest,
	Equilibrium: Equilibrium,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erarr: erarr,
	erDot: erDot,
	escr: escr,
	Escr: Escr,
	esdot: esdot,
	Esim: Esim,
	esim: esim,
	Eta: Eta,
	eta: eta,
	ETH: ETH,
	eth: eth,
	Euml: Euml,
	euml: euml,
	euro: euro,
	excl: excl,
	exist: exist,
	Exists: Exists,
	expectation: expectation,
	exponentiale: exponentiale,
	ExponentialE: ExponentialE,
	fallingdotseq: fallingdotseq,
	Fcy: Fcy,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	Ffr: Ffr,
	ffr: ffr,
	filig: filig,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	Fopf: Fopf,
	fopf: fopf,
	forall: forall,
	ForAll: ForAll,
	fork: fork,
	forkv: forkv,
	Fouriertrf: Fouriertrf,
	fpartint: fpartint,
	frac12: frac12,
	frac13: frac13,
	frac14: frac14,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac34: frac34,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	Fscr: Fscr,
	gacute: gacute,
	Gamma: Gamma,
	gamma: gamma,
	Gammad: Gammad,
	gammad: gammad,
	gap: gap,
	Gbreve: Gbreve,
	gbreve: gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	gcirc: gcirc,
	Gcy: Gcy,
	gcy: gcy,
	Gdot: Gdot,
	gdot: gdot,
	ge: ge,
	gE: gE,
	gEl: gEl,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	gescc: gescc,
	ges: ges,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	Gfr: Gfr,
	gfr: gfr,
	gg: gg,
	Gg: Gg,
	ggg: ggg,
	gimel: gimel,
	GJcy: GJcy,
	gjcy: gjcy,
	gla: gla,
	gl: gl,
	glE: glE,
	glj: glj,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gnE: gnE,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	Gopf: Gopf,
	gopf: gopf,
	grave: grave,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	gtcc: gtcc,
	gtcir: gtcir,
	gt: gt,
	GT: GT,
	Gt: Gt,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	Hacek: Hacek,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	HARDcy: HARDcy,
	hardcy: hardcy,
	harrcir: harrcir,
	harr: harr,
	hArr: hArr,
	harrw: harrw,
	Hat: Hat,
	hbar: hbar,
	Hcirc: Hcirc,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	Hopf: Hopf,
	horbar: horbar,
	HorizontalLine: HorizontalLine,
	hscr: hscr,
	Hscr: Hscr,
	hslash: hslash,
	Hstrok: Hstrok,
	hstrok: hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	hybull: hybull,
	hyphen: hyphen,
	Iacute: Iacute,
	iacute: iacute,
	ic: ic,
	Icirc: Icirc,
	icirc: icirc,
	Icy: Icy,
	icy: icy,
	Idot: Idot,
	IEcy: IEcy,
	iecy: iecy,
	iexcl: iexcl,
	iff: iff,
	ifr: ifr,
	Ifr: Ifr,
	Igrave: Igrave,
	igrave: igrave,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	IJlig: IJlig,
	ijlig: ijlig,
	Imacr: Imacr,
	imacr: imacr,
	image: image,
	ImaginaryI: ImaginaryI,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	Im: Im,
	imof: imof,
	imped: imped,
	Implies: Implies,
	incare: incare,
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	intcal: intcal,
	int: int,
	Int: Int,
	integers: integers,
	Integral: Integral,
	intercal: intercal,
	Intersection: Intersection,
	intlarhk: intlarhk,
	intprod: intprod,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	IOcy: IOcy,
	iocy: iocy,
	Iogon: Iogon,
	iogon: iogon,
	Iopf: Iopf,
	iopf: iopf,
	Iota: Iota,
	iota: iota,
	iprod: iprod,
	iquest: iquest,
	iscr: iscr,
	Iscr: Iscr,
	isin: isin,
	isindot: isindot,
	isinE: isinE,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	Itilde: Itilde,
	itilde: itilde,
	Iukcy: Iukcy,
	iukcy: iukcy,
	Iuml: Iuml,
	iuml: iuml,
	Jcirc: Jcirc,
	jcirc: jcirc,
	Jcy: Jcy,
	jcy: jcy,
	Jfr: Jfr,
	jfr: jfr,
	jmath: jmath,
	Jopf: Jopf,
	jopf: jopf,
	Jscr: Jscr,
	jscr: jscr,
	Jsercy: Jsercy,
	jsercy: jsercy,
	Jukcy: Jukcy,
	jukcy: jukcy,
	Kappa: Kappa,
	kappa: kappa,
	kappav: kappav,
	Kcedil: Kcedil,
	kcedil: kcedil,
	Kcy: Kcy,
	kcy: kcy,
	Kfr: Kfr,
	kfr: kfr,
	kgreen: kgreen,
	KHcy: KHcy,
	khcy: khcy,
	KJcy: KJcy,
	kjcy: kjcy,
	Kopf: Kopf,
	kopf: kopf,
	Kscr: Kscr,
	kscr: kscr,
	lAarr: lAarr,
	Lacute: Lacute,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	Lambda: Lambda,
	lambda: lambda,
	lang: lang,
	Lang: Lang,
	langd: langd,
	langle: langle,
	lap: lap,
	Laplacetrf: Laplacetrf,
	laquo: laquo,
	larrb: larrb,
	larrbfs: larrbfs,
	larr: larr,
	Larr: Larr,
	lArr: lArr,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	latail: latail,
	lAtail: lAtail,
	lat: lat,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lBarr: lBarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	Lcaron: Lcaron,
	lcaron: lcaron,
	Lcedil: Lcedil,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	Lcy: Lcy,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le,
	lE: lE,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrowBar: LeftArrowBar,
	leftarrow: leftarrow,
	LeftArrow: LeftArrow,
	Leftarrow: Leftarrow,
	LeftArrowRightArrow: LeftArrowRightArrow,
	leftarrowtail: leftarrowtail,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftDownVector: LeftDownVector,
	LeftFloor: LeftFloor,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	LeftRightArrow: LeftRightArrow,
	Leftrightarrow: Leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	LeftRightVector: LeftRightVector,
	LeftTeeArrow: LeftTeeArrow,
	LeftTee: LeftTee,
	LeftTeeVector: LeftTeeVector,
	leftthreetimes: leftthreetimes,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangle: LeftTriangle,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftUpVector: LeftUpVector,
	LeftVectorBar: LeftVectorBar,
	LeftVector: LeftVector,
	lEg: lEg,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	lescc: lescc,
	les: les,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	lessgtr: lessgtr,
	LessLess: LessLess,
	lesssim: lesssim,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	lfisht: lfisht,
	lfloor: lfloor,
	Lfr: Lfr,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lHar: lHar,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	LJcy: LJcy,
	ljcy: ljcy,
	llarr: llarr,
	ll: ll,
	Ll: Ll,
	llcorner: llcorner,
	Lleftarrow: Lleftarrow,
	llhard: llhard,
	lltri: lltri,
	Lmidot: Lmidot,
	lmidot: lmidot,
	lmoustache: lmoustache,
	lmoust: lmoust,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lnE: lnE,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	LongLeftArrow: LongLeftArrow,
	Longleftarrow: Longleftarrow,
	longleftrightarrow: longleftrightarrow,
	LongLeftRightArrow: LongLeftRightArrow,
	Longleftrightarrow: Longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	LongRightArrow: LongRightArrow,
	Longrightarrow: Longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	Lopf: Lopf,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	Lscr: Lscr,
	lsh: lsh,
	Lsh: Lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	Lstrok: Lstrok,
	lstrok: lstrok,
	ltcc: ltcc,
	ltcir: ltcir,
	lt: lt,
	LT: LT,
	Lt: Lt,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	ltrPar: ltrPar,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	macr: macr,
	male: male,
	malt: malt,
	maltese: maltese,
	map: map$1,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	Mcy: Mcy,
	mcy: mcy,
	mdash: mdash,
	mDDot: mDDot,
	measuredangle: measuredangle,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	mfr: mfr,
	mho: mho,
	micro: micro,
	midast: midast,
	midcir: midcir,
	mid: mid,
	middot: middot,
	minusb: minusb,
	minus: minus,
	minusd: minusd,
	minusdu: minusdu,
	MinusPlus: MinusPlus,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	Mopf: Mopf,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	Mscr: Mscr,
	mstpos: mstpos,
	Mu: Mu,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nabla: nabla,
	Nacute: Nacute,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natural: natural,
	naturals: naturals,
	natur: natur,
	nbsp: nbsp,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	Ncaron: Ncaron,
	ncaron: ncaron,
	Ncedil: Ncedil,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	Ncy: Ncy,
	ncy: ncy,
	ndash: ndash,
	nearhk: nearhk,
	nearr: nearr,
	neArr: neArr,
	nearrow: nearrow,
	ne: ne,
	nedot: nedot,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	nexist: nexist,
	nexists: nexists,
	Nfr: Nfr,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	nGg: nGg,
	ngsim: ngsim,
	nGt: nGt,
	ngt: ngt,
	ngtr: ngtr,
	nGtv: nGtv,
	nharr: nharr,
	nhArr: nhArr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	NJcy: NJcy,
	njcy: njcy,
	nlarr: nlarr,
	nlArr: nlArr,
	nldr: nldr,
	nlE: nlE,
	nle: nle,
	nleftarrow: nleftarrow,
	nLeftarrow: nLeftarrow,
	nleftrightarrow: nleftrightarrow,
	nLeftrightarrow: nLeftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nLl: nLl,
	nlsim: nlsim,
	nLt: nLt,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nLtv: nLtv,
	nmid: nmid,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	nopf: nopf,
	Nopf: Nopf,
	Not: Not,
	not: not,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	notin: notin,
	notindot: notindot,
	notinE: notinE,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	nparallel: nparallel,
	npar: npar,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	nprec: nprec,
	npreceq: npreceq,
	npre: npre,
	nrarrc: nrarrc,
	nrarr: nrarr,
	nrArr: nrArr,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nRightarrow: nRightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	Nscr: Nscr,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	Ntilde: Ntilde,
	ntilde: ntilde,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	Nu: Nu,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvap: nvap,
	nvdash: nvdash,
	nvDash: nvDash,
	nVdash: nVdash,
	nVDash: nVDash,
	nvge: nvge,
	nvgt: nvgt,
	nvHarr: nvHarr,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwArr: nwArr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	Oacute: Oacute,
	oacute: oacute,
	oast: oast,
	Ocirc: Ocirc,
	ocirc: ocirc,
	ocir: ocir,
	Ocy: Ocy,
	ocy: ocy,
	odash: odash,
	Odblac: Odblac,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	OElig: OElig,
	oelig: oelig,
	ofcir: ofcir,
	Ofr: Ofr,
	ofr: ofr,
	ogon: ogon,
	Ograve: Ograve,
	ograve: ograve,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	Omacr: Omacr,
	omacr: omacr,
	Omega: Omega,
	omega: omega,
	Omicron: Omicron,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	Oopf: Oopf,
	oopf: oopf,
	opar: opar,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	operp: operp,
	oplus: oplus,
	orarr: orarr,
	Or: Or,
	or: or,
	ord: ord,
	order: order,
	orderof: orderof,
	ordf: ordf,
	ordm: ordm,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oS: oS,
	Oscr: Oscr,
	oscr: oscr,
	Oslash: Oslash,
	oslash: oslash,
	osol: osol,
	Otilde: Otilde,
	otilde: otilde,
	otimesas: otimesas,
	Otimes: Otimes,
	otimes: otimes,
	Ouml: Ouml,
	ouml: ouml,
	ovbar: ovbar,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	para: para,
	parallel: parallel,
	par: par,
	parsim: parsim,
	parsl: parsl,
	part: part,
	PartialD: PartialD,
	Pcy: Pcy,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	Pfr: Pfr,
	pfr: pfr,
	Phi: Phi,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	Pi: Pi,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plus: plus,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	PlusMinus: PlusMinus,
	plusmn: plusmn,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	Poincareplane: Poincareplane,
	pointint: pointint,
	popf: popf,
	Popf: Popf,
	pound: pound,
	prap: prap,
	Pr: Pr,
	pr: pr,
	prcue: prcue,
	precapprox: precapprox,
	prec: prec,
	preccurlyeq: preccurlyeq,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	pre: pre,
	prE: prE,
	precsim: precsim,
	prime: prime,
	Prime: Prime,
	primes: primes,
	prnap: prnap,
	prnE: prnE,
	prnsim: prnsim,
	prod: prod,
	Product: Product,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop,
	Proportional: Proportional,
	Proportion: Proportion,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	Pscr: Pscr,
	pscr: pscr,
	Psi: Psi,
	psi: psi,
	puncsp: puncsp,
	Qfr: Qfr,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	Qopf: Qopf,
	qprime: qprime,
	Qscr: Qscr,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quot: quot,
	QUOT: QUOT,
	rAarr: rAarr,
	race: race,
	Racute: Racute,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	Rang: Rang,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raquo: raquo,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarr: rarr,
	Rarr: Rarr,
	rArr: rArr,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	Rarrtl: Rarrtl,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	rAtail: rAtail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rBarr: rBarr,
	RBarr: RBarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	Rcaron: Rcaron,
	rcaron: rcaron,
	Rcedil: Rcedil,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	Rcy: Rcy,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	Re: Re,
	rect: rect,
	reg: reg,
	REG: REG,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	Rfr: Rfr,
	rHar: rHar,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	Rho: Rho,
	rho: rho,
	rhov: rhov,
	RightAngleBracket: RightAngleBracket,
	RightArrowBar: RightArrowBar,
	rightarrow: rightarrow,
	RightArrow: RightArrow,
	Rightarrow: Rightarrow,
	RightArrowLeftArrow: RightArrowLeftArrow,
	rightarrowtail: rightarrowtail,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVectorBar: RightDownVectorBar,
	RightDownVector: RightDownVector,
	RightFloor: RightFloor,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	RightTeeArrow: RightTeeArrow,
	RightTee: RightTee,
	RightTeeVector: RightTeeVector,
	rightthreetimes: rightthreetimes,
	RightTriangleBar: RightTriangleBar,
	RightTriangle: RightTriangle,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVectorBar: RightUpVectorBar,
	RightUpVector: RightUpVector,
	RightVectorBar: RightVectorBar,
	RightVector: RightVector,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoustache: rmoustache,
	rmoust: rmoust,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	Ropf: Ropf,
	roplus: roplus,
	rotimes: rotimes,
	RoundImplies: RoundImplies,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	Rrightarrow: Rrightarrow,
	rsaquo: rsaquo,
	rscr: rscr,
	Rscr: Rscr,
	rsh: rsh,
	Rsh: Rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	RuleDelayed: RuleDelayed,
	ruluhar: ruluhar,
	rx: rx,
	Sacute: Sacute,
	sacute: sacute,
	sbquo: sbquo,
	scap: scap,
	Scaron: Scaron,
	scaron: scaron,
	Sc: Sc,
	sc: sc,
	sccue: sccue,
	sce: sce,
	scE: scE,
	Scedil: Scedil,
	scedil: scedil,
	Scirc: Scirc,
	scirc: scirc,
	scnap: scnap,
	scnE: scnE,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	Scy: Scy,
	scy: scy,
	sdotb: sdotb,
	sdot: sdot,
	sdote: sdote,
	searhk: searhk,
	searr: searr,
	seArr: seArr,
	searrow: searrow,
	sect: sect,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	Sfr: Sfr,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	SHCHcy: SHCHcy,
	shchcy: shchcy,
	SHcy: SHcy,
	shcy: shcy,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	shortmid: shortmid,
	shortparallel: shortparallel,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	shy: shy,
	Sigma: Sigma,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	SmallCircle: SmallCircle,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	SOFTcy: SOFTcy,
	softcy: softcy,
	solbar: solbar,
	solb: solb,
	sol: sol,
	Sopf: Sopf,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	Sqrt: Sqrt,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	square: square,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	squarf: squarf,
	squ: squ,
	squf: squf,
	srarr: srarr,
	Sscr: Sscr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	Star: Star,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub,
	Sub: Sub,
	subdot: subdot,
	subE: subE,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	Subset: Subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	SubsetEqual: SubsetEqual,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succapprox: succapprox,
	succ: succ,
	succcurlyeq: succcurlyeq,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	SuchThat: SuchThat,
	sum: sum,
	Sum: Sum,
	sung: sung,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	sup: sup,
	Sup: Sup,
	supdot: supdot,
	supdsub: supdsub,
	supE: supE,
	supe: supe,
	supedot: supedot,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	Supset: Supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swarhk: swarhk,
	swarr: swarr,
	swArr: swArr,
	swarrow: swarrow,
	swnwar: swnwar,
	szlig: szlig,
	Tab: Tab,
	target: target,
	Tau: Tau,
	tau: tau,
	tbrk: tbrk,
	Tcaron: Tcaron,
	tcaron: tcaron,
	Tcedil: Tcedil,
	tcedil: tcedil,
	Tcy: Tcy,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	Tfr: Tfr,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	Therefore: Therefore,
	Theta: Theta,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	THORN: THORN,
	thorn: thorn,
	tilde: tilde,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	timesbar: timesbar,
	timesb: timesb,
	times: times,
	timesd: timesd,
	tint: tint,
	toea: toea,
	topbot: topbot,
	topcir: topcir,
	top: top,
	Topf: Topf,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	TRADE: TRADE,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	TripleDot: TripleDot,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	Tscr: Tscr,
	tscr: tscr,
	TScy: TScy,
	tscy: tscy,
	TSHcy: TSHcy,
	tshcy: tshcy,
	Tstrok: Tstrok,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	Uacute: Uacute,
	uacute: uacute,
	uarr: uarr,
	Uarr: Uarr,
	uArr: uArr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	ubrcy: ubrcy,
	Ubreve: Ubreve,
	ubreve: ubreve,
	Ucirc: Ucirc,
	ucirc: ucirc,
	Ucy: Ucy,
	ucy: ucy,
	udarr: udarr,
	Udblac: Udblac,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	Ufr: Ufr,
	ufr: ufr,
	Ugrave: Ugrave,
	ugrave: ugrave,
	uHar: uHar,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	Umacr: Umacr,
	umacr: umacr,
	uml: uml,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	uogon: uogon,
	Uopf: Uopf,
	uopf: uopf,
	UpArrowBar: UpArrowBar,
	uparrow: uparrow,
	UpArrow: UpArrow,
	Uparrow: Uparrow,
	UpArrowDownArrow: UpArrowDownArrow,
	updownarrow: updownarrow,
	UpDownArrow: UpDownArrow,
	Updownarrow: Updownarrow,
	UpEquilibrium: UpEquilibrium,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	upsi: upsi,
	Upsi: Upsi,
	upsih: upsih,
	Upsilon: Upsilon,
	upsilon: upsilon,
	UpTeeArrow: UpTeeArrow,
	UpTee: UpTee,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	Uring: Uring,
	uring: uring,
	urtri: urtri,
	Uscr: Uscr,
	uscr: uscr,
	utdot: utdot,
	Utilde: Utilde,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	Uuml: Uuml,
	uuml: uuml,
	uwangle: uwangle,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	vArr: vArr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vBar: vBar,
	Vbar: Vbar,
	vBarv: vBarv,
	Vcy: Vcy,
	vcy: vcy,
	vdash: vdash,
	vDash: vDash,
	Vdash: Vdash,
	VDash: VDash,
	Vdashl: Vdashl,
	veebar: veebar,
	vee: vee,
	Vee: Vee,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	Verbar: Verbar,
	vert: vert,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	Vopf: Vopf,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	Vscr: Vscr,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	Vvdash: Vvdash,
	vzigzag: vzigzag,
	Wcirc: Wcirc,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	Wedge: Wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	Wfr: Wfr,
	wfr: wfr,
	Wopf: Wopf,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	Wscr: Wscr,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	Xfr: Xfr,
	xfr: xfr,
	xharr: xharr,
	xhArr: xhArr,
	Xi: Xi,
	xi: xi,
	xlarr: xlarr,
	xlArr: xlArr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	Xopf: Xopf,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrarr: xrarr,
	xrArr: xrArr,
	Xscr: Xscr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	Yacute: Yacute,
	yacute: yacute,
	YAcy: YAcy,
	yacy: yacy,
	Ycirc: Ycirc,
	ycirc: ycirc,
	Ycy: Ycy,
	ycy: ycy,
	yen: yen,
	Yfr: Yfr,
	yfr: yfr,
	YIcy: YIcy,
	yicy: yicy,
	Yopf: Yopf,
	yopf: yopf,
	Yscr: Yscr,
	yscr: yscr,
	YUcy: YUcy,
	yucy: yucy,
	yuml: yuml,
	Yuml: Yuml,
	Zacute: Zacute,
	zacute: zacute,
	Zcaron: Zcaron,
	zcaron: zcaron,
	Zcy: Zcy,
	zcy: zcy,
	Zdot: Zdot,
	zdot: zdot,
	zeetrf: zeetrf,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	zeta: zeta,
	zfr: zfr,
	Zfr: Zfr,
	ZHcy: ZHcy,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	Zopf: Zopf,
	Zscr: Zscr,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj,
	"in": "∈",
	"Map": "⤅"
};

var entities$2 = Object.freeze({
	Aacute: Aacute,
	aacute: aacute,
	Abreve: Abreve,
	abreve: abreve,
	ac: ac,
	acd: acd,
	acE: acE,
	Acirc: Acirc,
	acirc: acirc,
	acute: acute,
	Acy: Acy,
	acy: acy,
	AElig: AElig,
	aelig: aelig,
	af: af,
	Afr: Afr,
	afr: afr,
	Agrave: Agrave,
	agrave: agrave,
	alefsym: alefsym,
	aleph: aleph,
	Alpha: Alpha,
	alpha: alpha,
	Amacr: Amacr,
	amacr: amacr,
	amalg: amalg,
	amp: amp,
	AMP: AMP,
	andand: andand,
	And: And,
	and: and,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angmsd: angmsd,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	Aogon: Aogon,
	aogon: aogon,
	Aopf: Aopf,
	aopf: aopf,
	apacir: apacir,
	ap: ap,
	apE: apE,
	ape: ape,
	apid: apid,
	apos: apos,
	ApplyFunction: ApplyFunction,
	approx: approx,
	approxeq: approxeq,
	Aring: Aring,
	aring: aring,
	Ascr: Ascr,
	ascr: ascr,
	Assign: Assign,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	Atilde: Atilde,
	atilde: atilde,
	Auml: Auml,
	auml: auml,
	awconint: awconint,
	awint: awint,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	Backslash: Backslash,
	Barv: Barv,
	barvee: barvee,
	barwed: barwed,
	Barwed: Barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	Bcy: Bcy,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	Because: Because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	Bernoullis: Bernoullis,
	Beta: Beta,
	beta: beta,
	beth: beth,
	between: between,
	Bfr: Bfr,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block,
	bne: bne,
	bnequiv: bnequiv,
	bNot: bNot,
	bnot: bnot,
	Bopf: Bopf,
	bopf: bopf,
	bot: bot,
	bottom: bottom,
	bowtie: bowtie,
	boxbox: boxbox,
	boxdl: boxdl,
	boxdL: boxdL,
	boxDl: boxDl,
	boxDL: boxDL,
	boxdr: boxdr,
	boxdR: boxdR,
	boxDr: boxDr,
	boxDR: boxDR,
	boxh: boxh,
	boxH: boxH,
	boxhd: boxhd,
	boxHd: boxHd,
	boxhD: boxhD,
	boxHD: boxHD,
	boxhu: boxhu,
	boxHu: boxHu,
	boxhU: boxhU,
	boxHU: boxHU,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxul: boxul,
	boxuL: boxuL,
	boxUl: boxUl,
	boxUL: boxUL,
	boxur: boxur,
	boxuR: boxuR,
	boxUr: boxUr,
	boxUR: boxUR,
	boxv: boxv,
	boxV: boxV,
	boxvh: boxvh,
	boxvH: boxvH,
	boxVh: boxVh,
	boxVH: boxVH,
	boxvl: boxvl,
	boxvL: boxvL,
	boxVl: boxVl,
	boxVL: boxVL,
	boxvr: boxvr,
	boxvR: boxvR,
	boxVr: boxVr,
	boxVR: boxVR,
	bprime: bprime,
	breve: breve,
	Breve: Breve,
	brvbar: brvbar,
	bscr: bscr,
	Bscr: Bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsolb: bsolb,
	bsol: bsol,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	Bumpeq: Bumpeq,
	bumpeq: bumpeq,
	Cacute: Cacute,
	cacute: cacute,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	cap: cap,
	Cap: Cap,
	capcup: capcup,
	capdot: capdot,
	CapitalDifferentialD: CapitalDifferentialD,
	caps: caps,
	caret: caret,
	caron: caron,
	Cayleys: Cayleys,
	ccaps: ccaps,
	Ccaron: Ccaron,
	ccaron: ccaron,
	Ccedil: Ccedil,
	ccedil: ccedil,
	Ccirc: Ccirc,
	ccirc: ccirc,
	Cconint: Cconint,
	ccups: ccups,
	ccupssm: ccupssm,
	Cdot: Cdot,
	cdot: cdot,
	cedil: cedil,
	Cedilla: Cedilla,
	cemptyv: cemptyv,
	cent: cent,
	centerdot: centerdot,
	CenterDot: CenterDot,
	cfr: cfr,
	Cfr: Cfr,
	CHcy: CHcy,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	Chi: Chi,
	chi: chi,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	CircleDot: CircleDot,
	circledR: circledR,
	circledS: circledS,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	cir: cir,
	cirE: cirE,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	Colon: Colon,
	Colone: Colone,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	Congruent: Congruent,
	conint: conint,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	copf: copf,
	Copf: Copf,
	coprod: coprod,
	Coproduct: Coproduct,
	copy: copy,
	COPY: COPY,
	copysr: copysr,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	crarr: crarr,
	cross: cross,
	Cross: Cross,
	Cscr: Cscr,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	CupCap: CupCap,
	cup: cup,
	Cup: Cup,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curren: curren,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dagger: dagger,
	Dagger: Dagger,
	daleth: daleth,
	darr: darr,
	Darr: Darr,
	dArr: dArr,
	dash: dash,
	Dashv: Dashv,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	Dcaron: Dcaron,
	dcaron: dcaron,
	Dcy: Dcy,
	dcy: dcy,
	ddagger: ddagger,
	ddarr: ddarr,
	DD: DD,
	dd: dd,
	DDotrahd: DDotrahd,
	ddotseq: ddotseq,
	deg: deg,
	Del: Del,
	Delta: Delta,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	Dfr: Dfr,
	dfr: dfr,
	dHar: dHar,
	dharl: dharl,
	dharr: dharr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	diam: diam,
	diamond: diamond,
	Diamond: Diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	DifferentialD: DifferentialD,
	digamma: digamma,
	disin: disin,
	div: div,
	divide: divide,
	divideontimes: divideontimes,
	divonx: divonx,
	DJcy: DJcy,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	Dopf: Dopf,
	dopf: dopf,
	Dot: Dot,
	dot: dot,
	DotDot: DotDot,
	doteq: doteq,
	doteqdot: doteqdot,
	DotEqual: DotEqual,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrowBar: DownArrowBar,
	downarrow: downarrow,
	DownArrow: DownArrow,
	Downarrow: Downarrow,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownLeftVector: DownLeftVector,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVectorBar: DownRightVectorBar,
	DownRightVector: DownRightVector,
	DownTeeArrow: DownTeeArrow,
	DownTee: DownTee,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	Dscr: Dscr,
	dscr: dscr,
	DScy: DScy,
	dscy: dscy,
	dsol: dsol,
	Dstrok: Dstrok,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	DZcy: DZcy,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	Eacute: Eacute,
	eacute: eacute,
	easter: easter,
	Ecaron: Ecaron,
	ecaron: ecaron,
	Ecirc: Ecirc,
	ecirc: ecirc,
	ecir: ecir,
	ecolon: ecolon,
	Ecy: Ecy,
	ecy: ecy,
	eDDot: eDDot,
	Edot: Edot,
	edot: edot,
	eDot: eDot,
	ee: ee,
	efDot: efDot,
	Efr: Efr,
	efr: efr,
	eg: eg,
	Egrave: Egrave,
	egrave: egrave,
	egs: egs,
	egsdot: egsdot,
	el: el,
	Element: Element,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	Emacr: Emacr,
	emacr: emacr,
	empty: empty,
	emptyset: emptyset,
	EmptySmallSquare: EmptySmallSquare,
	emptyv: emptyv,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	ENG: ENG,
	eng: eng,
	ensp: ensp,
	Eogon: Eogon,
	eogon: eogon,
	Eopf: Eopf,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	Epsilon: Epsilon,
	epsilon: epsilon,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	Equal: Equal,
	equals: equals,
	EqualTilde: EqualTilde,
	equest: equest,
	Equilibrium: Equilibrium,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erarr: erarr,
	erDot: erDot,
	escr: escr,
	Escr: Escr,
	esdot: esdot,
	Esim: Esim,
	esim: esim,
	Eta: Eta,
	eta: eta,
	ETH: ETH,
	eth: eth,
	Euml: Euml,
	euml: euml,
	euro: euro,
	excl: excl,
	exist: exist,
	Exists: Exists,
	expectation: expectation,
	exponentiale: exponentiale,
	ExponentialE: ExponentialE,
	fallingdotseq: fallingdotseq,
	Fcy: Fcy,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	Ffr: Ffr,
	ffr: ffr,
	filig: filig,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	Fopf: Fopf,
	fopf: fopf,
	forall: forall,
	ForAll: ForAll,
	fork: fork,
	forkv: forkv,
	Fouriertrf: Fouriertrf,
	fpartint: fpartint,
	frac12: frac12,
	frac13: frac13,
	frac14: frac14,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac34: frac34,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	Fscr: Fscr,
	gacute: gacute,
	Gamma: Gamma,
	gamma: gamma,
	Gammad: Gammad,
	gammad: gammad,
	gap: gap,
	Gbreve: Gbreve,
	gbreve: gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	gcirc: gcirc,
	Gcy: Gcy,
	gcy: gcy,
	Gdot: Gdot,
	gdot: gdot,
	ge: ge,
	gE: gE,
	gEl: gEl,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	gescc: gescc,
	ges: ges,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	Gfr: Gfr,
	gfr: gfr,
	gg: gg,
	Gg: Gg,
	ggg: ggg,
	gimel: gimel,
	GJcy: GJcy,
	gjcy: gjcy,
	gla: gla,
	gl: gl,
	glE: glE,
	glj: glj,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gnE: gnE,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	Gopf: Gopf,
	gopf: gopf,
	grave: grave,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	gtcc: gtcc,
	gtcir: gtcir,
	gt: gt,
	GT: GT,
	Gt: Gt,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	Hacek: Hacek,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	HARDcy: HARDcy,
	hardcy: hardcy,
	harrcir: harrcir,
	harr: harr,
	hArr: hArr,
	harrw: harrw,
	Hat: Hat,
	hbar: hbar,
	Hcirc: Hcirc,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	Hopf: Hopf,
	horbar: horbar,
	HorizontalLine: HorizontalLine,
	hscr: hscr,
	Hscr: Hscr,
	hslash: hslash,
	Hstrok: Hstrok,
	hstrok: hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	hybull: hybull,
	hyphen: hyphen,
	Iacute: Iacute,
	iacute: iacute,
	ic: ic,
	Icirc: Icirc,
	icirc: icirc,
	Icy: Icy,
	icy: icy,
	Idot: Idot,
	IEcy: IEcy,
	iecy: iecy,
	iexcl: iexcl,
	iff: iff,
	ifr: ifr,
	Ifr: Ifr,
	Igrave: Igrave,
	igrave: igrave,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	IJlig: IJlig,
	ijlig: ijlig,
	Imacr: Imacr,
	imacr: imacr,
	image: image,
	ImaginaryI: ImaginaryI,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	Im: Im,
	imof: imof,
	imped: imped,
	Implies: Implies,
	incare: incare,
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	intcal: intcal,
	int: int,
	Int: Int,
	integers: integers,
	Integral: Integral,
	intercal: intercal,
	Intersection: Intersection,
	intlarhk: intlarhk,
	intprod: intprod,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	IOcy: IOcy,
	iocy: iocy,
	Iogon: Iogon,
	iogon: iogon,
	Iopf: Iopf,
	iopf: iopf,
	Iota: Iota,
	iota: iota,
	iprod: iprod,
	iquest: iquest,
	iscr: iscr,
	Iscr: Iscr,
	isin: isin,
	isindot: isindot,
	isinE: isinE,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	Itilde: Itilde,
	itilde: itilde,
	Iukcy: Iukcy,
	iukcy: iukcy,
	Iuml: Iuml,
	iuml: iuml,
	Jcirc: Jcirc,
	jcirc: jcirc,
	Jcy: Jcy,
	jcy: jcy,
	Jfr: Jfr,
	jfr: jfr,
	jmath: jmath,
	Jopf: Jopf,
	jopf: jopf,
	Jscr: Jscr,
	jscr: jscr,
	Jsercy: Jsercy,
	jsercy: jsercy,
	Jukcy: Jukcy,
	jukcy: jukcy,
	Kappa: Kappa,
	kappa: kappa,
	kappav: kappav,
	Kcedil: Kcedil,
	kcedil: kcedil,
	Kcy: Kcy,
	kcy: kcy,
	Kfr: Kfr,
	kfr: kfr,
	kgreen: kgreen,
	KHcy: KHcy,
	khcy: khcy,
	KJcy: KJcy,
	kjcy: kjcy,
	Kopf: Kopf,
	kopf: kopf,
	Kscr: Kscr,
	kscr: kscr,
	lAarr: lAarr,
	Lacute: Lacute,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	Lambda: Lambda,
	lambda: lambda,
	lang: lang,
	Lang: Lang,
	langd: langd,
	langle: langle,
	lap: lap,
	Laplacetrf: Laplacetrf,
	laquo: laquo,
	larrb: larrb,
	larrbfs: larrbfs,
	larr: larr,
	Larr: Larr,
	lArr: lArr,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	latail: latail,
	lAtail: lAtail,
	lat: lat,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lBarr: lBarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	Lcaron: Lcaron,
	lcaron: lcaron,
	Lcedil: Lcedil,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	Lcy: Lcy,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le,
	lE: lE,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrowBar: LeftArrowBar,
	leftarrow: leftarrow,
	LeftArrow: LeftArrow,
	Leftarrow: Leftarrow,
	LeftArrowRightArrow: LeftArrowRightArrow,
	leftarrowtail: leftarrowtail,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftDownVector: LeftDownVector,
	LeftFloor: LeftFloor,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	LeftRightArrow: LeftRightArrow,
	Leftrightarrow: Leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	LeftRightVector: LeftRightVector,
	LeftTeeArrow: LeftTeeArrow,
	LeftTee: LeftTee,
	LeftTeeVector: LeftTeeVector,
	leftthreetimes: leftthreetimes,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangle: LeftTriangle,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftUpVector: LeftUpVector,
	LeftVectorBar: LeftVectorBar,
	LeftVector: LeftVector,
	lEg: lEg,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	lescc: lescc,
	les: les,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	lessgtr: lessgtr,
	LessLess: LessLess,
	lesssim: lesssim,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	lfisht: lfisht,
	lfloor: lfloor,
	Lfr: Lfr,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lHar: lHar,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	LJcy: LJcy,
	ljcy: ljcy,
	llarr: llarr,
	ll: ll,
	Ll: Ll,
	llcorner: llcorner,
	Lleftarrow: Lleftarrow,
	llhard: llhard,
	lltri: lltri,
	Lmidot: Lmidot,
	lmidot: lmidot,
	lmoustache: lmoustache,
	lmoust: lmoust,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lnE: lnE,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	LongLeftArrow: LongLeftArrow,
	Longleftarrow: Longleftarrow,
	longleftrightarrow: longleftrightarrow,
	LongLeftRightArrow: LongLeftRightArrow,
	Longleftrightarrow: Longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	LongRightArrow: LongRightArrow,
	Longrightarrow: Longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	Lopf: Lopf,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	Lscr: Lscr,
	lsh: lsh,
	Lsh: Lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	Lstrok: Lstrok,
	lstrok: lstrok,
	ltcc: ltcc,
	ltcir: ltcir,
	lt: lt,
	LT: LT,
	Lt: Lt,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	ltrPar: ltrPar,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	macr: macr,
	male: male,
	malt: malt,
	maltese: maltese,
	map: map$1,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	Mcy: Mcy,
	mcy: mcy,
	mdash: mdash,
	mDDot: mDDot,
	measuredangle: measuredangle,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	mfr: mfr,
	mho: mho,
	micro: micro,
	midast: midast,
	midcir: midcir,
	mid: mid,
	middot: middot,
	minusb: minusb,
	minus: minus,
	minusd: minusd,
	minusdu: minusdu,
	MinusPlus: MinusPlus,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	Mopf: Mopf,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	Mscr: Mscr,
	mstpos: mstpos,
	Mu: Mu,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nabla: nabla,
	Nacute: Nacute,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natural: natural,
	naturals: naturals,
	natur: natur,
	nbsp: nbsp,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	Ncaron: Ncaron,
	ncaron: ncaron,
	Ncedil: Ncedil,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	Ncy: Ncy,
	ncy: ncy,
	ndash: ndash,
	nearhk: nearhk,
	nearr: nearr,
	neArr: neArr,
	nearrow: nearrow,
	ne: ne,
	nedot: nedot,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	nexist: nexist,
	nexists: nexists,
	Nfr: Nfr,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	nGg: nGg,
	ngsim: ngsim,
	nGt: nGt,
	ngt: ngt,
	ngtr: ngtr,
	nGtv: nGtv,
	nharr: nharr,
	nhArr: nhArr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	NJcy: NJcy,
	njcy: njcy,
	nlarr: nlarr,
	nlArr: nlArr,
	nldr: nldr,
	nlE: nlE,
	nle: nle,
	nleftarrow: nleftarrow,
	nLeftarrow: nLeftarrow,
	nleftrightarrow: nleftrightarrow,
	nLeftrightarrow: nLeftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nLl: nLl,
	nlsim: nlsim,
	nLt: nLt,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nLtv: nLtv,
	nmid: nmid,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	nopf: nopf,
	Nopf: Nopf,
	Not: Not,
	not: not,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	notin: notin,
	notindot: notindot,
	notinE: notinE,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	nparallel: nparallel,
	npar: npar,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	nprec: nprec,
	npreceq: npreceq,
	npre: npre,
	nrarrc: nrarrc,
	nrarr: nrarr,
	nrArr: nrArr,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nRightarrow: nRightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	Nscr: Nscr,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	Ntilde: Ntilde,
	ntilde: ntilde,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	Nu: Nu,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvap: nvap,
	nvdash: nvdash,
	nvDash: nvDash,
	nVdash: nVdash,
	nVDash: nVDash,
	nvge: nvge,
	nvgt: nvgt,
	nvHarr: nvHarr,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwArr: nwArr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	Oacute: Oacute,
	oacute: oacute,
	oast: oast,
	Ocirc: Ocirc,
	ocirc: ocirc,
	ocir: ocir,
	Ocy: Ocy,
	ocy: ocy,
	odash: odash,
	Odblac: Odblac,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	OElig: OElig,
	oelig: oelig,
	ofcir: ofcir,
	Ofr: Ofr,
	ofr: ofr,
	ogon: ogon,
	Ograve: Ograve,
	ograve: ograve,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	Omacr: Omacr,
	omacr: omacr,
	Omega: Omega,
	omega: omega,
	Omicron: Omicron,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	Oopf: Oopf,
	oopf: oopf,
	opar: opar,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	operp: operp,
	oplus: oplus,
	orarr: orarr,
	Or: Or,
	or: or,
	ord: ord,
	order: order,
	orderof: orderof,
	ordf: ordf,
	ordm: ordm,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oS: oS,
	Oscr: Oscr,
	oscr: oscr,
	Oslash: Oslash,
	oslash: oslash,
	osol: osol,
	Otilde: Otilde,
	otilde: otilde,
	otimesas: otimesas,
	Otimes: Otimes,
	otimes: otimes,
	Ouml: Ouml,
	ouml: ouml,
	ovbar: ovbar,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	para: para,
	parallel: parallel,
	par: par,
	parsim: parsim,
	parsl: parsl,
	part: part,
	PartialD: PartialD,
	Pcy: Pcy,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	Pfr: Pfr,
	pfr: pfr,
	Phi: Phi,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	Pi: Pi,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plus: plus,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	PlusMinus: PlusMinus,
	plusmn: plusmn,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	Poincareplane: Poincareplane,
	pointint: pointint,
	popf: popf,
	Popf: Popf,
	pound: pound,
	prap: prap,
	Pr: Pr,
	pr: pr,
	prcue: prcue,
	precapprox: precapprox,
	prec: prec,
	preccurlyeq: preccurlyeq,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	pre: pre,
	prE: prE,
	precsim: precsim,
	prime: prime,
	Prime: Prime,
	primes: primes,
	prnap: prnap,
	prnE: prnE,
	prnsim: prnsim,
	prod: prod,
	Product: Product,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop,
	Proportional: Proportional,
	Proportion: Proportion,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	Pscr: Pscr,
	pscr: pscr,
	Psi: Psi,
	psi: psi,
	puncsp: puncsp,
	Qfr: Qfr,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	Qopf: Qopf,
	qprime: qprime,
	Qscr: Qscr,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quot: quot,
	QUOT: QUOT,
	rAarr: rAarr,
	race: race,
	Racute: Racute,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	Rang: Rang,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raquo: raquo,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarr: rarr,
	Rarr: Rarr,
	rArr: rArr,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	Rarrtl: Rarrtl,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	rAtail: rAtail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rBarr: rBarr,
	RBarr: RBarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	Rcaron: Rcaron,
	rcaron: rcaron,
	Rcedil: Rcedil,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	Rcy: Rcy,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	Re: Re,
	rect: rect,
	reg: reg,
	REG: REG,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	Rfr: Rfr,
	rHar: rHar,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	Rho: Rho,
	rho: rho,
	rhov: rhov,
	RightAngleBracket: RightAngleBracket,
	RightArrowBar: RightArrowBar,
	rightarrow: rightarrow,
	RightArrow: RightArrow,
	Rightarrow: Rightarrow,
	RightArrowLeftArrow: RightArrowLeftArrow,
	rightarrowtail: rightarrowtail,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVectorBar: RightDownVectorBar,
	RightDownVector: RightDownVector,
	RightFloor: RightFloor,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	RightTeeArrow: RightTeeArrow,
	RightTee: RightTee,
	RightTeeVector: RightTeeVector,
	rightthreetimes: rightthreetimes,
	RightTriangleBar: RightTriangleBar,
	RightTriangle: RightTriangle,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVectorBar: RightUpVectorBar,
	RightUpVector: RightUpVector,
	RightVectorBar: RightVectorBar,
	RightVector: RightVector,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoustache: rmoustache,
	rmoust: rmoust,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	Ropf: Ropf,
	roplus: roplus,
	rotimes: rotimes,
	RoundImplies: RoundImplies,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	Rrightarrow: Rrightarrow,
	rsaquo: rsaquo,
	rscr: rscr,
	Rscr: Rscr,
	rsh: rsh,
	Rsh: Rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	RuleDelayed: RuleDelayed,
	ruluhar: ruluhar,
	rx: rx,
	Sacute: Sacute,
	sacute: sacute,
	sbquo: sbquo,
	scap: scap,
	Scaron: Scaron,
	scaron: scaron,
	Sc: Sc,
	sc: sc,
	sccue: sccue,
	sce: sce,
	scE: scE,
	Scedil: Scedil,
	scedil: scedil,
	Scirc: Scirc,
	scirc: scirc,
	scnap: scnap,
	scnE: scnE,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	Scy: Scy,
	scy: scy,
	sdotb: sdotb,
	sdot: sdot,
	sdote: sdote,
	searhk: searhk,
	searr: searr,
	seArr: seArr,
	searrow: searrow,
	sect: sect,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	Sfr: Sfr,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	SHCHcy: SHCHcy,
	shchcy: shchcy,
	SHcy: SHcy,
	shcy: shcy,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	shortmid: shortmid,
	shortparallel: shortparallel,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	shy: shy,
	Sigma: Sigma,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	SmallCircle: SmallCircle,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	SOFTcy: SOFTcy,
	softcy: softcy,
	solbar: solbar,
	solb: solb,
	sol: sol,
	Sopf: Sopf,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	Sqrt: Sqrt,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	square: square,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	squarf: squarf,
	squ: squ,
	squf: squf,
	srarr: srarr,
	Sscr: Sscr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	Star: Star,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub,
	Sub: Sub,
	subdot: subdot,
	subE: subE,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	Subset: Subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	SubsetEqual: SubsetEqual,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succapprox: succapprox,
	succ: succ,
	succcurlyeq: succcurlyeq,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	SuchThat: SuchThat,
	sum: sum,
	Sum: Sum,
	sung: sung,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	sup: sup,
	Sup: Sup,
	supdot: supdot,
	supdsub: supdsub,
	supE: supE,
	supe: supe,
	supedot: supedot,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	Supset: Supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swarhk: swarhk,
	swarr: swarr,
	swArr: swArr,
	swarrow: swarrow,
	swnwar: swnwar,
	szlig: szlig,
	Tab: Tab,
	target: target,
	Tau: Tau,
	tau: tau,
	tbrk: tbrk,
	Tcaron: Tcaron,
	tcaron: tcaron,
	Tcedil: Tcedil,
	tcedil: tcedil,
	Tcy: Tcy,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	Tfr: Tfr,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	Therefore: Therefore,
	Theta: Theta,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	THORN: THORN,
	thorn: thorn,
	tilde: tilde,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	timesbar: timesbar,
	timesb: timesb,
	times: times,
	timesd: timesd,
	tint: tint,
	toea: toea,
	topbot: topbot,
	topcir: topcir,
	top: top,
	Topf: Topf,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	TRADE: TRADE,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	TripleDot: TripleDot,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	Tscr: Tscr,
	tscr: tscr,
	TScy: TScy,
	tscy: tscy,
	TSHcy: TSHcy,
	tshcy: tshcy,
	Tstrok: Tstrok,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	Uacute: Uacute,
	uacute: uacute,
	uarr: uarr,
	Uarr: Uarr,
	uArr: uArr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	ubrcy: ubrcy,
	Ubreve: Ubreve,
	ubreve: ubreve,
	Ucirc: Ucirc,
	ucirc: ucirc,
	Ucy: Ucy,
	ucy: ucy,
	udarr: udarr,
	Udblac: Udblac,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	Ufr: Ufr,
	ufr: ufr,
	Ugrave: Ugrave,
	ugrave: ugrave,
	uHar: uHar,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	Umacr: Umacr,
	umacr: umacr,
	uml: uml,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	uogon: uogon,
	Uopf: Uopf,
	uopf: uopf,
	UpArrowBar: UpArrowBar,
	uparrow: uparrow,
	UpArrow: UpArrow,
	Uparrow: Uparrow,
	UpArrowDownArrow: UpArrowDownArrow,
	updownarrow: updownarrow,
	UpDownArrow: UpDownArrow,
	Updownarrow: Updownarrow,
	UpEquilibrium: UpEquilibrium,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	upsi: upsi,
	Upsi: Upsi,
	upsih: upsih,
	Upsilon: Upsilon,
	upsilon: upsilon,
	UpTeeArrow: UpTeeArrow,
	UpTee: UpTee,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	Uring: Uring,
	uring: uring,
	urtri: urtri,
	Uscr: Uscr,
	uscr: uscr,
	utdot: utdot,
	Utilde: Utilde,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	Uuml: Uuml,
	uuml: uuml,
	uwangle: uwangle,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	vArr: vArr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vBar: vBar,
	Vbar: Vbar,
	vBarv: vBarv,
	Vcy: Vcy,
	vcy: vcy,
	vdash: vdash,
	vDash: vDash,
	Vdash: Vdash,
	VDash: VDash,
	Vdashl: Vdashl,
	veebar: veebar,
	vee: vee,
	Vee: Vee,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	Verbar: Verbar,
	vert: vert,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	Vopf: Vopf,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	Vscr: Vscr,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	Vvdash: Vvdash,
	vzigzag: vzigzag,
	Wcirc: Wcirc,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	Wedge: Wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	Wfr: Wfr,
	wfr: wfr,
	Wopf: Wopf,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	Wscr: Wscr,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	Xfr: Xfr,
	xfr: xfr,
	xharr: xharr,
	xhArr: xhArr,
	Xi: Xi,
	xi: xi,
	xlarr: xlarr,
	xlArr: xlArr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	Xopf: Xopf,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrarr: xrarr,
	xrArr: xrArr,
	Xscr: Xscr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	Yacute: Yacute,
	yacute: yacute,
	YAcy: YAcy,
	yacy: yacy,
	Ycirc: Ycirc,
	ycirc: ycirc,
	Ycy: Ycy,
	ycy: ycy,
	yen: yen,
	Yfr: Yfr,
	yfr: yfr,
	YIcy: YIcy,
	yicy: yicy,
	Yopf: Yopf,
	yopf: yopf,
	Yscr: Yscr,
	yscr: yscr,
	YUcy: YUcy,
	yucy: yucy,
	yuml: yuml,
	Yuml: Yuml,
	Zacute: Zacute,
	zacute: zacute,
	Zcaron: Zcaron,
	zcaron: zcaron,
	Zcy: Zcy,
	zcy: zcy,
	Zdot: Zdot,
	zdot: zdot,
	zeetrf: zeetrf,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	zeta: zeta,
	zfr: zfr,
	Zfr: Zfr,
	ZHcy: ZHcy,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	Zopf: Zopf,
	Zscr: Zscr,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj,
	default: entities$1
});

var Aacute$1 = "Á";
var aacute$1 = "á";
var Acirc$1 = "Â";
var acirc$1 = "â";
var acute$1 = "´";
var AElig$1 = "Æ";
var aelig$1 = "æ";
var Agrave$1 = "À";
var agrave$1 = "à";
var amp$1 = "&";
var AMP$1 = "&";
var Aring$1 = "Å";
var aring$1 = "å";
var Atilde$1 = "Ã";
var atilde$1 = "ã";
var Auml$1 = "Ä";
var auml$1 = "ä";
var brvbar$1 = "¦";
var Ccedil$1 = "Ç";
var ccedil$1 = "ç";
var cedil$1 = "¸";
var cent$1 = "¢";
var copy$1 = "©";
var COPY$1 = "©";
var curren$1 = "¤";
var deg$1 = "°";
var divide$1 = "÷";
var Eacute$1 = "É";
var eacute$1 = "é";
var Ecirc$1 = "Ê";
var ecirc$1 = "ê";
var Egrave$1 = "È";
var egrave$1 = "è";
var ETH$1 = "Ð";
var eth$1 = "ð";
var Euml$1 = "Ë";
var euml$1 = "ë";
var frac12$1 = "½";
var frac14$1 = "¼";
var frac34$1 = "¾";
var gt$1 = ">";
var GT$1 = ">";
var Iacute$1 = "Í";
var iacute$1 = "í";
var Icirc$1 = "Î";
var icirc$1 = "î";
var iexcl$1 = "¡";
var Igrave$1 = "Ì";
var igrave$1 = "ì";
var iquest$1 = "¿";
var Iuml$1 = "Ï";
var iuml$1 = "ï";
var laquo$1 = "«";
var lt$1 = "<";
var LT$1 = "<";
var macr$1 = "¯";
var micro$1 = "µ";
var middot$1 = "·";
var nbsp$1 = " ";
var not$1 = "¬";
var Ntilde$1 = "Ñ";
var ntilde$1 = "ñ";
var Oacute$1 = "Ó";
var oacute$1 = "ó";
var Ocirc$1 = "Ô";
var ocirc$1 = "ô";
var Ograve$1 = "Ò";
var ograve$1 = "ò";
var ordf$1 = "ª";
var ordm$1 = "º";
var Oslash$1 = "Ø";
var oslash$1 = "ø";
var Otilde$1 = "Õ";
var otilde$1 = "õ";
var Ouml$1 = "Ö";
var ouml$1 = "ö";
var para$1 = "¶";
var plusmn$1 = "±";
var pound$1 = "£";
var quot$1 = "\"";
var QUOT$1 = "\"";
var raquo$1 = "»";
var reg$1 = "®";
var REG$1 = "®";
var sect$1 = "§";
var shy$1 = "­";
var sup1$1 = "¹";
var sup2$1 = "²";
var sup3$1 = "³";
var szlig$1 = "ß";
var THORN$1 = "Þ";
var thorn$1 = "þ";
var times$1 = "×";
var Uacute$1 = "Ú";
var uacute$1 = "ú";
var Ucirc$1 = "Û";
var ucirc$1 = "û";
var Ugrave$1 = "Ù";
var ugrave$1 = "ù";
var uml$1 = "¨";
var Uuml$1 = "Ü";
var uuml$1 = "ü";
var Yacute$1 = "Ý";
var yacute$1 = "ý";
var yen$1 = "¥";
var yuml$1 = "ÿ";
var legacy$2 = {
	Aacute: Aacute$1,
	aacute: aacute$1,
	Acirc: Acirc$1,
	acirc: acirc$1,
	acute: acute$1,
	AElig: AElig$1,
	aelig: aelig$1,
	Agrave: Agrave$1,
	agrave: agrave$1,
	amp: amp$1,
	AMP: AMP$1,
	Aring: Aring$1,
	aring: aring$1,
	Atilde: Atilde$1,
	atilde: atilde$1,
	Auml: Auml$1,
	auml: auml$1,
	brvbar: brvbar$1,
	Ccedil: Ccedil$1,
	ccedil: ccedil$1,
	cedil: cedil$1,
	cent: cent$1,
	copy: copy$1,
	COPY: COPY$1,
	curren: curren$1,
	deg: deg$1,
	divide: divide$1,
	Eacute: Eacute$1,
	eacute: eacute$1,
	Ecirc: Ecirc$1,
	ecirc: ecirc$1,
	Egrave: Egrave$1,
	egrave: egrave$1,
	ETH: ETH$1,
	eth: eth$1,
	Euml: Euml$1,
	euml: euml$1,
	frac12: frac12$1,
	frac14: frac14$1,
	frac34: frac34$1,
	gt: gt$1,
	GT: GT$1,
	Iacute: Iacute$1,
	iacute: iacute$1,
	Icirc: Icirc$1,
	icirc: icirc$1,
	iexcl: iexcl$1,
	Igrave: Igrave$1,
	igrave: igrave$1,
	iquest: iquest$1,
	Iuml: Iuml$1,
	iuml: iuml$1,
	laquo: laquo$1,
	lt: lt$1,
	LT: LT$1,
	macr: macr$1,
	micro: micro$1,
	middot: middot$1,
	nbsp: nbsp$1,
	not: not$1,
	Ntilde: Ntilde$1,
	ntilde: ntilde$1,
	Oacute: Oacute$1,
	oacute: oacute$1,
	Ocirc: Ocirc$1,
	ocirc: ocirc$1,
	Ograve: Ograve$1,
	ograve: ograve$1,
	ordf: ordf$1,
	ordm: ordm$1,
	Oslash: Oslash$1,
	oslash: oslash$1,
	Otilde: Otilde$1,
	otilde: otilde$1,
	Ouml: Ouml$1,
	ouml: ouml$1,
	para: para$1,
	plusmn: plusmn$1,
	pound: pound$1,
	quot: quot$1,
	QUOT: QUOT$1,
	raquo: raquo$1,
	reg: reg$1,
	REG: REG$1,
	sect: sect$1,
	shy: shy$1,
	sup1: sup1$1,
	sup2: sup2$1,
	sup3: sup3$1,
	szlig: szlig$1,
	THORN: THORN$1,
	thorn: thorn$1,
	times: times$1,
	Uacute: Uacute$1,
	uacute: uacute$1,
	Ucirc: Ucirc$1,
	ucirc: ucirc$1,
	Ugrave: Ugrave$1,
	ugrave: ugrave$1,
	uml: uml$1,
	Uuml: Uuml$1,
	uuml: uuml$1,
	Yacute: Yacute$1,
	yacute: yacute$1,
	yen: yen$1,
	yuml: yuml$1
};

var legacy$3 = Object.freeze({
	Aacute: Aacute$1,
	aacute: aacute$1,
	Acirc: Acirc$1,
	acirc: acirc$1,
	acute: acute$1,
	AElig: AElig$1,
	aelig: aelig$1,
	Agrave: Agrave$1,
	agrave: agrave$1,
	amp: amp$1,
	AMP: AMP$1,
	Aring: Aring$1,
	aring: aring$1,
	Atilde: Atilde$1,
	atilde: atilde$1,
	Auml: Auml$1,
	auml: auml$1,
	brvbar: brvbar$1,
	Ccedil: Ccedil$1,
	ccedil: ccedil$1,
	cedil: cedil$1,
	cent: cent$1,
	copy: copy$1,
	COPY: COPY$1,
	curren: curren$1,
	deg: deg$1,
	divide: divide$1,
	Eacute: Eacute$1,
	eacute: eacute$1,
	Ecirc: Ecirc$1,
	ecirc: ecirc$1,
	Egrave: Egrave$1,
	egrave: egrave$1,
	ETH: ETH$1,
	eth: eth$1,
	Euml: Euml$1,
	euml: euml$1,
	frac12: frac12$1,
	frac14: frac14$1,
	frac34: frac34$1,
	gt: gt$1,
	GT: GT$1,
	Iacute: Iacute$1,
	iacute: iacute$1,
	Icirc: Icirc$1,
	icirc: icirc$1,
	iexcl: iexcl$1,
	Igrave: Igrave$1,
	igrave: igrave$1,
	iquest: iquest$1,
	Iuml: Iuml$1,
	iuml: iuml$1,
	laquo: laquo$1,
	lt: lt$1,
	LT: LT$1,
	macr: macr$1,
	micro: micro$1,
	middot: middot$1,
	nbsp: nbsp$1,
	not: not$1,
	Ntilde: Ntilde$1,
	ntilde: ntilde$1,
	Oacute: Oacute$1,
	oacute: oacute$1,
	Ocirc: Ocirc$1,
	ocirc: ocirc$1,
	Ograve: Ograve$1,
	ograve: ograve$1,
	ordf: ordf$1,
	ordm: ordm$1,
	Oslash: Oslash$1,
	oslash: oslash$1,
	Otilde: Otilde$1,
	otilde: otilde$1,
	Ouml: Ouml$1,
	ouml: ouml$1,
	para: para$1,
	plusmn: plusmn$1,
	pound: pound$1,
	quot: quot$1,
	QUOT: QUOT$1,
	raquo: raquo$1,
	reg: reg$1,
	REG: REG$1,
	sect: sect$1,
	shy: shy$1,
	sup1: sup1$1,
	sup2: sup2$1,
	sup3: sup3$1,
	szlig: szlig$1,
	THORN: THORN$1,
	thorn: thorn$1,
	times: times$1,
	Uacute: Uacute$1,
	uacute: uacute$1,
	Ucirc: Ucirc$1,
	ucirc: ucirc$1,
	Ugrave: Ugrave$1,
	ugrave: ugrave$1,
	uml: uml$1,
	Uuml: Uuml$1,
	uuml: uuml$1,
	Yacute: Yacute$1,
	yacute: yacute$1,
	yen: yen$1,
	yuml: yuml$1,
	default: legacy$2
});

var amp$2 = "&";
var apos$1 = "'";
var gt$2 = ">";
var lt$2 = "<";
var quot$2 = "\"";
var xml = {
	amp: amp$2,
	apos: apos$1,
	gt: gt$2,
	lt: lt$2,
	quot: quot$2
};

var xml$1 = Object.freeze({
	amp: amp$2,
	apos: apos$1,
	gt: gt$2,
	lt: lt$2,
	quot: quot$2,
	default: xml
});

var require$$1$5 = ( entities$2 && entities$2['default'] ) || entities$2;

var require$$2$3 = ( legacy$3 && legacy$3['default'] ) || legacy$3;

var require$$3$3 = ( xml$1 && xml$1['default'] ) || xml$1;

var Tokenizer_1 = Tokenizer$1;

var decodeCodePoint = decode_codepoint;
var entityMap = require$$1$5;
var legacyMap = require$$2$3;
var xmlMap    = require$$3$3;
var i = 0;
var TEXT                      = i++;
var BEFORE_TAG_NAME           = i++;
var IN_TAG_NAME               = i++;
var IN_SELF_CLOSING_TAG       = i++;
var BEFORE_CLOSING_TAG_NAME   = i++;
var IN_CLOSING_TAG_NAME       = i++;
var AFTER_CLOSING_TAG_NAME    = i++;
var BEFORE_ATTRIBUTE_NAME     = i++;
var IN_ATTRIBUTE_NAME         = i++;
var AFTER_ATTRIBUTE_NAME      = i++;
var BEFORE_ATTRIBUTE_VALUE    = i++;
var IN_ATTRIBUTE_VALUE_DQ     = i++;
var IN_ATTRIBUTE_VALUE_SQ     = i++;
var IN_ATTRIBUTE_VALUE_NQ     = i++;
var BEFORE_DECLARATION        = i++;
var IN_DECLARATION            = i++;
var IN_PROCESSING_INSTRUCTION = i++;
var BEFORE_COMMENT            = i++;
var IN_COMMENT                = i++;
var AFTER_COMMENT_1           = i++;
var AFTER_COMMENT_2           = i++;
var BEFORE_CDATA_1            = i++;
var BEFORE_CDATA_2            = i++;
var BEFORE_CDATA_3            = i++;
var BEFORE_CDATA_4            = i++;
var BEFORE_CDATA_5            = i++;
var BEFORE_CDATA_6            = i++;
var IN_CDATA                  = i++;
var AFTER_CDATA_1             = i++;
var AFTER_CDATA_2             = i++;
var BEFORE_SPECIAL            = i++;
var BEFORE_SPECIAL_END        = i++;
var BEFORE_SCRIPT_1           = i++;
var BEFORE_SCRIPT_2           = i++;
var BEFORE_SCRIPT_3           = i++;
var BEFORE_SCRIPT_4           = i++;
var BEFORE_SCRIPT_5           = i++;
var AFTER_SCRIPT_1            = i++;
var AFTER_SCRIPT_2            = i++;
var AFTER_SCRIPT_3            = i++;
var AFTER_SCRIPT_4            = i++;
var AFTER_SCRIPT_5            = i++;
var BEFORE_STYLE_1            = i++;
var BEFORE_STYLE_2            = i++;
var BEFORE_STYLE_3            = i++;
var BEFORE_STYLE_4            = i++;
var AFTER_STYLE_1             = i++;
var AFTER_STYLE_2             = i++;
var AFTER_STYLE_3             = i++;
var AFTER_STYLE_4             = i++;
var BEFORE_ENTITY             = i++;
var BEFORE_NUMERIC_ENTITY     = i++;
var IN_NAMED_ENTITY           = i++;
var IN_NUMERIC_ENTITY         = i++;
var IN_HEX_ENTITY             = i++;
var j = 0;
var SPECIAL_NONE              = j++;
var SPECIAL_SCRIPT            = j++;
var SPECIAL_STYLE             = j++;

function whitespace(c){
	return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}

function characterState(char, SUCCESS){
	return function(c){
		if(c === char) { this._state = SUCCESS; }
	};
}

function ifElseState(upper, SUCCESS, FAILURE){
	var lower = upper.toLowerCase();

	if(upper === lower){
		return function(c){
			if(c === lower){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	} else {
		return function(c){
			if(c === lower || c === upper){
				this._state = SUCCESS;
			} else {
				this._state = FAILURE;
				this._index--;
			}
		};
	}
}

function consumeSpecialNameChar(upper, NEXT_STATE){
	var lower = upper.toLowerCase();

	return function(c){
		if(c === lower || c === upper){
			this._state = NEXT_STATE;
		} else {
			this._state = IN_TAG_NAME;
			this._index--; //consume the token again
		}
	};
}

function Tokenizer$1(options, cbs){
	this._state = TEXT;
	this._buffer = "";
	this._sectionStart = 0;
	this._index = 0;
	this._bufferOffset = 0; //chars removed from _buffer
	this._baseState = TEXT;
	this._special = SPECIAL_NONE;
	this._cbs = cbs;
	this._running = true;
	this._ended = false;
	this._xmlMode = !!(options && options.xmlMode);
	this._decodeEntities = !!(options && options.decodeEntities);
}

Tokenizer$1.prototype._stateText = function(c){
	if(c === "<"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._state = BEFORE_TAG_NAME;
		this._sectionStart = this._index;
	} else if(this._decodeEntities && this._special === SPECIAL_NONE && c === "&"){
		if(this._index > this._sectionStart){
			this._cbs.ontext(this._getSection());
		}
		this._baseState = TEXT;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateBeforeTagName = function(c){
	if(c === "/"){
		this._state = BEFORE_CLOSING_TAG_NAME;
	} else if(c === "<"){
		this._cbs.ontext(this._getSection());
		this._sectionStart = this._index;
	} else if(c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
		this._state = TEXT;
	} else if(c === "!"){
		this._state = BEFORE_DECLARATION;
		this._sectionStart = this._index + 1;
	} else if(c === "?"){
		this._state = IN_PROCESSING_INSTRUCTION;
		this._sectionStart = this._index + 1;
	} else {
		this._state = (!this._xmlMode && (c === "s" || c === "S")) ?
						BEFORE_SPECIAL : IN_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateInTagName = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._emitToken("onopentagname");
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer$1.prototype._stateBeforeCloseingTagName = function(c){
	if(whitespace(c)){  }
	else if(c === ">"){
		this._state = TEXT;
	} else if(this._special !== SPECIAL_NONE){
		if(c === "s" || c === "S"){
			this._state = BEFORE_SPECIAL_END;
		} else {
			this._state = TEXT;
			this._index--;
		}
	} else {
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateInCloseingTagName = function(c){
	if(c === ">" || whitespace(c)){
		this._emitToken("onclosetag");
		this._state = AFTER_CLOSING_TAG_NAME;
		this._index--;
	}
};

Tokenizer$1.prototype._stateAfterCloseingTagName = function(c){
	//skip everything until ">"
	if(c === ">"){
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer$1.prototype._stateBeforeAttributeName = function(c){
	if(c === ">"){
		this._cbs.onopentagend();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c === "/"){
		this._state = IN_SELF_CLOSING_TAG;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateInSelfClosingTag = function(c){
	if(c === ">"){
		this._cbs.onselfclosingtag();
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer$1.prototype._stateInAttributeName = function(c){
	if(c === "=" || c === "/" || c === ">" || whitespace(c)){
		this._cbs.onattribname(this._getSection());
		this._sectionStart = -1;
		this._state = AFTER_ATTRIBUTE_NAME;
		this._index--;
	}
};

Tokenizer$1.prototype._stateAfterAttributeName = function(c){
	if(c === "="){
		this._state = BEFORE_ATTRIBUTE_VALUE;
	} else if(c === "/" || c === ">"){
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(!whitespace(c)){
		this._cbs.onattribend();
		this._state = IN_ATTRIBUTE_NAME;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateBeforeAttributeValue = function(c){
	if(c === "\""){
		this._state = IN_ATTRIBUTE_VALUE_DQ;
		this._sectionStart = this._index + 1;
	} else if(c === "'"){
		this._state = IN_ATTRIBUTE_VALUE_SQ;
		this._sectionStart = this._index + 1;
	} else if(!whitespace(c)){
		this._state = IN_ATTRIBUTE_VALUE_NQ;
		this._sectionStart = this._index;
		this._index--; //reconsume token
	}
};

Tokenizer$1.prototype._stateInAttributeValueDoubleQuotes = function(c){
	if(c === "\""){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateInAttributeValueSingleQuotes = function(c){
	if(c === "'"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateInAttributeValueNoQuotes = function(c){
	if(whitespace(c) || c === ">"){
		this._emitToken("onattribdata");
		this._cbs.onattribend();
		this._state = BEFORE_ATTRIBUTE_NAME;
		this._index--;
	} else if(this._decodeEntities && c === "&"){
		this._emitToken("onattribdata");
		this._baseState = this._state;
		this._state = BEFORE_ENTITY;
		this._sectionStart = this._index;
	}
};

Tokenizer$1.prototype._stateBeforeDeclaration = function(c){
	this._state = c === "[" ? BEFORE_CDATA_1 :
					c === "-" ? BEFORE_COMMENT :
						IN_DECLARATION;
};

Tokenizer$1.prototype._stateInDeclaration = function(c){
	if(c === ">"){
		this._cbs.ondeclaration(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer$1.prototype._stateInProcessingInstruction = function(c){
	if(c === ">"){
		this._cbs.onprocessinginstruction(this._getSection());
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	}
};

Tokenizer$1.prototype._stateBeforeComment = function(c){
	if(c === "-"){
		this._state = IN_COMMENT;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
	}
};

Tokenizer$1.prototype._stateInComment = function(c){
	if(c === "-") { this._state = AFTER_COMMENT_1; }
};

Tokenizer$1.prototype._stateAfterComment1 = function(c){
	if(c === "-"){
		this._state = AFTER_COMMENT_2;
	} else {
		this._state = IN_COMMENT;
	}
};

Tokenizer$1.prototype._stateAfterComment2 = function(c){
	if(c === ">"){
		//remove 2 trailing chars
		this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "-"){
		this._state = IN_COMMENT;
	}
	// else: stay in AFTER_COMMENT_2 (`--->`)
};

Tokenizer$1.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
Tokenizer$1.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
Tokenizer$1.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
Tokenizer$1.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
Tokenizer$1.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);

Tokenizer$1.prototype._stateBeforeCdata6 = function(c){
	if(c === "["){
		this._state = IN_CDATA;
		this._sectionStart = this._index + 1;
	} else {
		this._state = IN_DECLARATION;
		this._index--;
	}
};

Tokenizer$1.prototype._stateInCdata = function(c){
	if(c === "]") { this._state = AFTER_CDATA_1; }
};

Tokenizer$1.prototype._stateAfterCdata1 = characterState("]", AFTER_CDATA_2);

Tokenizer$1.prototype._stateAfterCdata2 = function(c){
	if(c === ">"){
		//remove 2 trailing chars
		this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
		this._state = TEXT;
		this._sectionStart = this._index + 1;
	} else if(c !== "]") {
		this._state = IN_CDATA;
	}
	//else: stay in AFTER_CDATA_2 (`]]]>`)
};

Tokenizer$1.prototype._stateBeforeSpecial = function(c){
	if(c === "c" || c === "C"){
		this._state = BEFORE_SCRIPT_1;
	} else if(c === "t" || c === "T"){
		this._state = BEFORE_STYLE_1;
	} else {
		this._state = IN_TAG_NAME;
		this._index--; //consume the token again
	}
};

Tokenizer$1.prototype._stateBeforeSpecialEnd = function(c){
	if(this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")){
		this._state = AFTER_SCRIPT_1;
	} else if(this._special === SPECIAL_STYLE && (c === "t" || c === "T")){
		this._state = AFTER_STYLE_1;
	}
	else { this._state = TEXT; }
};

Tokenizer$1.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
Tokenizer$1.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
Tokenizer$1.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
Tokenizer$1.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);

Tokenizer$1.prototype._stateBeforeScript5 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_SCRIPT;
	}
	this._state = IN_TAG_NAME;
	this._index--; //consume the token again
};

Tokenizer$1.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
Tokenizer$1.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
Tokenizer$1.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
Tokenizer$1.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);

Tokenizer$1.prototype._stateAfterScript5 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 6;
		this._index--; //reconsume the token
	}
	else { this._state = TEXT; }
};

Tokenizer$1.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
Tokenizer$1.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
Tokenizer$1.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);

Tokenizer$1.prototype._stateBeforeStyle4 = function(c){
	if(c === "/" || c === ">" || whitespace(c)){
		this._special = SPECIAL_STYLE;
	}
	this._state = IN_TAG_NAME;
	this._index--; //consume the token again
};

Tokenizer$1.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
Tokenizer$1.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
Tokenizer$1.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);

Tokenizer$1.prototype._stateAfterStyle4 = function(c){
	if(c === ">" || whitespace(c)){
		this._special = SPECIAL_NONE;
		this._state = IN_CLOSING_TAG_NAME;
		this._sectionStart = this._index - 5;
		this._index--; //reconsume the token
	}
	else { this._state = TEXT; }
};

Tokenizer$1.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
Tokenizer$1.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);

//for entities terminated with a semicolon
Tokenizer$1.prototype._parseNamedEntityStrict = function(){
	//offset = 1
	if(this._sectionStart + 1 < this._index){
		var entity = this._buffer.substring(this._sectionStart + 1, this._index),
		    map = this._xmlMode ? xmlMap : entityMap;

		if(map.hasOwnProperty(entity)){
			this._emitPartial(map[entity]);
			this._sectionStart = this._index + 1;
		}
	}
};


//parses legacy entities (without trailing semicolon)
Tokenizer$1.prototype._parseLegacyEntity = function(){
	var this$1 = this;

	var start = this._sectionStart + 1,
	    limit = this._index - start;

	if(limit > 6) { limit = 6; } //the max length of legacy entities is 6

	while(limit >= 2){ //the min length of legacy entities is 2
		var entity = this$1._buffer.substr(start, limit);

		if(legacyMap.hasOwnProperty(entity)){
			this$1._emitPartial(legacyMap[entity]);
			this$1._sectionStart += limit + 1;
			return;
		} else {
			limit--;
		}
	}
};

Tokenizer$1.prototype._stateInNamedEntity = function(c){
	if(c === ";"){
		this._parseNamedEntityStrict();
		if(this._sectionStart + 1 < this._index && !this._xmlMode){
			this._parseLegacyEntity();
		}
		this._state = this._baseState;
	} else if((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")){
		if(this._xmlMode){  }
		else if(this._sectionStart + 1 === this._index){  }
		else if(this._baseState !== TEXT){
			if(c !== "="){
				this._parseNamedEntityStrict();
			}
		} else {
			this._parseLegacyEntity();
		}

		this._state = this._baseState;
		this._index--;
	}
};

Tokenizer$1.prototype._decodeNumericEntity = function(offset, base){
	var sectionStart = this._sectionStart + offset;

	if(sectionStart !== this._index){
		//parse entity
		var entity = this._buffer.substring(sectionStart, this._index);
		var parsed = parseInt(entity, base);

		this._emitPartial(decodeCodePoint(parsed));
		this._sectionStart = this._index;
	} else {
		this._sectionStart--;
	}

	this._state = this._baseState;
};

Tokenizer$1.prototype._stateInNumericEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(2, 10);
		this._sectionStart++;
	} else if(c < "0" || c > "9"){
		if(!this._xmlMode){
			this._decodeNumericEntity(2, 10);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer$1.prototype._stateInHexEntity = function(c){
	if(c === ";"){
		this._decodeNumericEntity(3, 16);
		this._sectionStart++;
	} else if((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")){
		if(!this._xmlMode){
			this._decodeNumericEntity(3, 16);
		} else {
			this._state = this._baseState;
		}
		this._index--;
	}
};

Tokenizer$1.prototype._cleanup = function (){
	if(this._sectionStart < 0){
		this._buffer = "";
		this._bufferOffset += this._index;
		this._index = 0;
	} else if(this._running){
		if(this._state === TEXT){
			if(this._sectionStart !== this._index){
				this._cbs.ontext(this._buffer.substr(this._sectionStart));
			}
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else if(this._sectionStart === this._index){
			//the section just started
			this._buffer = "";
			this._bufferOffset += this._index;
			this._index = 0;
		} else {
			//remove everything unnecessary
			this._buffer = this._buffer.substr(this._sectionStart);
			this._index -= this._sectionStart;
			this._bufferOffset += this._sectionStart;
		}

		this._sectionStart = 0;
	}
};

//TODO make events conditional
Tokenizer$1.prototype.write = function(chunk){
	if(this._ended) { this._cbs.onerror(Error(".write() after done!")); }

	this._buffer += chunk;
	this._parse();
};

Tokenizer$1.prototype._parse = function(){
	var this$1 = this;

	while(this._index < this._buffer.length && this._running){
		var c = this$1._buffer.charAt(this$1._index);
		if(this$1._state === TEXT) {
			this$1._stateText(c);
		} else if(this$1._state === BEFORE_TAG_NAME){
			this$1._stateBeforeTagName(c);
		} else if(this$1._state === IN_TAG_NAME) {
			this$1._stateInTagName(c);
		} else if(this$1._state === BEFORE_CLOSING_TAG_NAME){
			this$1._stateBeforeCloseingTagName(c);
		} else if(this$1._state === IN_CLOSING_TAG_NAME){
			this$1._stateInCloseingTagName(c);
		} else if(this$1._state === AFTER_CLOSING_TAG_NAME){
			this$1._stateAfterCloseingTagName(c);
		} else if(this$1._state === IN_SELF_CLOSING_TAG){
			this$1._stateInSelfClosingTag(c);
		}

		/*
		*	attributes
		*/
		else if(this$1._state === BEFORE_ATTRIBUTE_NAME){
			this$1._stateBeforeAttributeName(c);
		} else if(this$1._state === IN_ATTRIBUTE_NAME){
			this$1._stateInAttributeName(c);
		} else if(this$1._state === AFTER_ATTRIBUTE_NAME){
			this$1._stateAfterAttributeName(c);
		} else if(this$1._state === BEFORE_ATTRIBUTE_VALUE){
			this$1._stateBeforeAttributeValue(c);
		} else if(this$1._state === IN_ATTRIBUTE_VALUE_DQ){
			this$1._stateInAttributeValueDoubleQuotes(c);
		} else if(this$1._state === IN_ATTRIBUTE_VALUE_SQ){
			this$1._stateInAttributeValueSingleQuotes(c);
		} else if(this$1._state === IN_ATTRIBUTE_VALUE_NQ){
			this$1._stateInAttributeValueNoQuotes(c);
		}

		/*
		*	declarations
		*/
		else if(this$1._state === BEFORE_DECLARATION){
			this$1._stateBeforeDeclaration(c);
		} else if(this$1._state === IN_DECLARATION){
			this$1._stateInDeclaration(c);
		}

		/*
		*	processing instructions
		*/
		else if(this$1._state === IN_PROCESSING_INSTRUCTION){
			this$1._stateInProcessingInstruction(c);
		}

		/*
		*	comments
		*/
		else if(this$1._state === BEFORE_COMMENT){
			this$1._stateBeforeComment(c);
		} else if(this$1._state === IN_COMMENT){
			this$1._stateInComment(c);
		} else if(this$1._state === AFTER_COMMENT_1){
			this$1._stateAfterComment1(c);
		} else if(this$1._state === AFTER_COMMENT_2){
			this$1._stateAfterComment2(c);
		}

		/*
		*	cdata
		*/
		else if(this$1._state === BEFORE_CDATA_1){
			this$1._stateBeforeCdata1(c);
		} else if(this$1._state === BEFORE_CDATA_2){
			this$1._stateBeforeCdata2(c);
		} else if(this$1._state === BEFORE_CDATA_3){
			this$1._stateBeforeCdata3(c);
		} else if(this$1._state === BEFORE_CDATA_4){
			this$1._stateBeforeCdata4(c);
		} else if(this$1._state === BEFORE_CDATA_5){
			this$1._stateBeforeCdata5(c);
		} else if(this$1._state === BEFORE_CDATA_6){
			this$1._stateBeforeCdata6(c);
		} else if(this$1._state === IN_CDATA){
			this$1._stateInCdata(c);
		} else if(this$1._state === AFTER_CDATA_1){
			this$1._stateAfterCdata1(c);
		} else if(this$1._state === AFTER_CDATA_2){
			this$1._stateAfterCdata2(c);
		}

		/*
		* special tags
		*/
		else if(this$1._state === BEFORE_SPECIAL){
			this$1._stateBeforeSpecial(c);
		} else if(this$1._state === BEFORE_SPECIAL_END){
			this$1._stateBeforeSpecialEnd(c);
		}

		/*
		* script
		*/
		else if(this$1._state === BEFORE_SCRIPT_1){
			this$1._stateBeforeScript1(c);
		} else if(this$1._state === BEFORE_SCRIPT_2){
			this$1._stateBeforeScript2(c);
		} else if(this$1._state === BEFORE_SCRIPT_3){
			this$1._stateBeforeScript3(c);
		} else if(this$1._state === BEFORE_SCRIPT_4){
			this$1._stateBeforeScript4(c);
		} else if(this$1._state === BEFORE_SCRIPT_5){
			this$1._stateBeforeScript5(c);
		}

		else if(this$1._state === AFTER_SCRIPT_1){
			this$1._stateAfterScript1(c);
		} else if(this$1._state === AFTER_SCRIPT_2){
			this$1._stateAfterScript2(c);
		} else if(this$1._state === AFTER_SCRIPT_3){
			this$1._stateAfterScript3(c);
		} else if(this$1._state === AFTER_SCRIPT_4){
			this$1._stateAfterScript4(c);
		} else if(this$1._state === AFTER_SCRIPT_5){
			this$1._stateAfterScript5(c);
		}

		/*
		* style
		*/
		else if(this$1._state === BEFORE_STYLE_1){
			this$1._stateBeforeStyle1(c);
		} else if(this$1._state === BEFORE_STYLE_2){
			this$1._stateBeforeStyle2(c);
		} else if(this$1._state === BEFORE_STYLE_3){
			this$1._stateBeforeStyle3(c);
		} else if(this$1._state === BEFORE_STYLE_4){
			this$1._stateBeforeStyle4(c);
		}

		else if(this$1._state === AFTER_STYLE_1){
			this$1._stateAfterStyle1(c);
		} else if(this$1._state === AFTER_STYLE_2){
			this$1._stateAfterStyle2(c);
		} else if(this$1._state === AFTER_STYLE_3){
			this$1._stateAfterStyle3(c);
		} else if(this$1._state === AFTER_STYLE_4){
			this$1._stateAfterStyle4(c);
		}

		/*
		* entities
		*/
		else if(this$1._state === BEFORE_ENTITY){
			this$1._stateBeforeEntity(c);
		} else if(this$1._state === BEFORE_NUMERIC_ENTITY){
			this$1._stateBeforeNumericEntity(c);
		} else if(this$1._state === IN_NAMED_ENTITY){
			this$1._stateInNamedEntity(c);
		} else if(this$1._state === IN_NUMERIC_ENTITY){
			this$1._stateInNumericEntity(c);
		} else if(this$1._state === IN_HEX_ENTITY){
			this$1._stateInHexEntity(c);
		}

		else {
			this$1._cbs.onerror(Error("unknown _state"), this$1._state);
		}

		this$1._index++;
	}

	this._cleanup();
};

Tokenizer$1.prototype.pause = function(){
	this._running = false;
};
Tokenizer$1.prototype.resume = function(){
	this._running = true;

	if(this._index < this._buffer.length){
		this._parse();
	}
	if(this._ended){
		this._finish();
	}
};

Tokenizer$1.prototype.end = function(chunk){
	if(this._ended) { this._cbs.onerror(Error(".end() after done!")); }
	if(chunk) { this.write(chunk); }

	this._ended = true;

	if(this._running) { this._finish(); }
};

Tokenizer$1.prototype._finish = function(){
	//if there is remaining data, emit it in a reasonable way
	if(this._sectionStart < this._index){
		this._handleTrailingData();
	}

	this._cbs.onend();
};

Tokenizer$1.prototype._handleTrailingData = function(){
	var data = this._buffer.substr(this._sectionStart);

	if(this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2){
		this._cbs.oncdata(data);
	} else if(this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2){
		this._cbs.oncomment(data);
	} else if(this._state === IN_NAMED_ENTITY && !this._xmlMode){
		this._parseLegacyEntity();
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_NUMERIC_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(2, 10);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(this._state === IN_HEX_ENTITY && !this._xmlMode){
		this._decodeNumericEntity(3, 16);
		if(this._sectionStart < this._index){
			this._state = this._baseState;
			this._handleTrailingData();
		}
	} else if(
		this._state !== IN_TAG_NAME &&
		this._state !== BEFORE_ATTRIBUTE_NAME &&
		this._state !== BEFORE_ATTRIBUTE_VALUE &&
		this._state !== AFTER_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_NAME &&
		this._state !== IN_ATTRIBUTE_VALUE_SQ &&
		this._state !== IN_ATTRIBUTE_VALUE_DQ &&
		this._state !== IN_ATTRIBUTE_VALUE_NQ &&
		this._state !== IN_CLOSING_TAG_NAME
	){
		this._cbs.ontext(data);
	}
	//else, ignore remaining data
	//TODO add a way to remove current tag
};

Tokenizer$1.prototype.reset = function(){
	Tokenizer$1.call(this, {xmlMode: this._xmlMode, decodeEntities: this._decodeEntities}, this._cbs);
};

Tokenizer$1.prototype.getAbsoluteIndex = function(){
	return this._bufferOffset + this._index;
};

Tokenizer$1.prototype._getSection = function(){
	return this._buffer.substring(this._sectionStart, this._index);
};

Tokenizer$1.prototype._emitToken = function(name){
	this._cbs[name](this._getSection());
	this._sectionStart = -1;
};

Tokenizer$1.prototype._emitPartial = function(value){
	if(this._baseState !== TEXT){
		this._cbs.onattribdata(value); //TODO implement the new event
	} else {
		this._cbs.ontext(value);
	}
};

var _stub = function() {};

var _stub$1 = Object.freeze({
	default: _stub
});

var require$$1$6 = ( _stub$1 && _stub$1['default'] ) || _stub$1;

var require$$2$4 = ( _resolve_empty && _resolve_empty['default'] ) || _resolve_empty;

var Tokenizer$1$1 = Tokenizer_1;

/*
	Options:

	xmlMode: Disables the special behavior for script/style tags (false by default)
	lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
	lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
*/

/*
	Callbacks:

	oncdataend,
	oncdatastart,
	onclosetag,
	oncomment,
	oncommentend,
	onerror,
	onopentag,
	onprocessinginstruction,
	onreset,
	ontext
*/

var formTags = {
	input: true,
	option: true,
	optgroup: true,
	select: true,
	button: true,
	datalist: true,
	textarea: true
};

var openImpliesClose = {
	tr      : { tr:true, th:true, td:true },
	th      : { th:true },
	td      : { thead:true, th:true, td:true },
	body    : { head:true, link:true, script:true },
	li      : { li:true },
	p       : { p:true },
	h1      : { p:true },
	h2      : { p:true },
	h3      : { p:true },
	h4      : { p:true },
	h5      : { p:true },
	h6      : { p:true },
	select  : formTags,
	input   : formTags,
	output  : formTags,
	button  : formTags,
	datalist: formTags,
	textarea: formTags,
	option  : { option:true },
	optgroup: { optgroup:true }
};

var voidElements = {
	__proto__: null,
	area: true,
	base: true,
	basefont: true,
	br: true,
	col: true,
	command: true,
	embed: true,
	frame: true,
	hr: true,
	img: true,
	input: true,
	isindex: true,
	keygen: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,

	//common self closing svg elements
	path: true,
	circle: true,
	ellipse: true,
	line: true,
	rect: true,
	use: true,
	stop: true,
	polyline: true,
	polygon: true
};

var re_nameEnd = /\s|\//;

function Parser(cbs, options){
	this._options = options || {};
	this._cbs = cbs || {};

	this._tagname = "";
	this._attribname = "";
	this._attribvalue = "";
	this._attribs = null;
	this._stack = [];

	this.startIndex = 0;
	this.endIndex = null;

	this._lowerCaseTagNames = "lowerCaseTags" in this._options ?
									!!this._options.lowerCaseTags :
									!this._options.xmlMode;
	this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ?
									!!this._options.lowerCaseAttributeNames :
									!this._options.xmlMode;

	if(this._options.Tokenizer) {
		Tokenizer$1$1 = this._options.Tokenizer;
	}
	this._tokenizer = new Tokenizer$1$1(this._options, this);

	if(this._cbs.onparserinit) { this._cbs.onparserinit(this); }
}

require$$1$6(Parser, require$$2$4.EventEmitter);

Parser.prototype._updatePosition = function(initialOffset){
	if(this.endIndex === null){
		if(this._tokenizer._sectionStart <= initialOffset){
			this.startIndex = 0;
		} else {
			this.startIndex = this._tokenizer._sectionStart - initialOffset;
		}
	}
	else { this.startIndex = this.endIndex + 1; }
	this.endIndex = this._tokenizer.getAbsoluteIndex();
};

//Tokenizer event handlers
Parser.prototype.ontext = function(data){
	this._updatePosition(1);
	this.endIndex--;

	if(this._cbs.ontext) { this._cbs.ontext(data); }
};

Parser.prototype.onopentagname = function(name){
	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	this._tagname = name;

	if(!this._options.xmlMode && name in openImpliesClose) {
		for(
			var el;
			(el = this._stack[this._stack.length - 1]) in openImpliesClose[name];
			this.onclosetag(el)
		){  }
	}

	if(this._options.xmlMode || !(name in voidElements)){
		this._stack.push(name);
	}

	if(this._cbs.onopentagname) { this._cbs.onopentagname(name); }
	if(this._cbs.onopentag) { this._attribs = {}; }
};

Parser.prototype.onopentagend = function(){
	this._updatePosition(1);

	if(this._attribs){
		if(this._cbs.onopentag) { this._cbs.onopentag(this._tagname, this._attribs); }
		this._attribs = null;
	}

	if(!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements){
		this._cbs.onclosetag(this._tagname);
	}

	this._tagname = "";
};

Parser.prototype.onclosetag = function(name){
	var this$1 = this;

	this._updatePosition(1);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	if(this._stack.length && (!(name in voidElements) || this._options.xmlMode)){
		var pos = this._stack.lastIndexOf(name);
		if(pos !== -1){
			if(this._cbs.onclosetag){
				pos = this._stack.length - pos;
				while(pos--) { this$1._cbs.onclosetag(this$1._stack.pop()); }
			}
			else { this._stack.length = pos; }
		} else if(name === "p" && !this._options.xmlMode){
			this.onopentagname(name);
			this._closeCurrentTag();
		}
	} else if(!this._options.xmlMode && (name === "br" || name === "p")){
		this.onopentagname(name);
		this._closeCurrentTag();
	}
};

Parser.prototype.onselfclosingtag = function(){
	if(this._options.xmlMode || this._options.recognizeSelfClosing){
		this._closeCurrentTag();
	} else {
		this.onopentagend();
	}
};

Parser.prototype._closeCurrentTag = function(){
	var name = this._tagname;

	this.onopentagend();

	//self-closing tags will be on the top of the stack
	//(cheaper check than in onclosetag)
	if(this._stack[this._stack.length - 1] === name){
		if(this._cbs.onclosetag){
			this._cbs.onclosetag(name);
		}
		this._stack.pop();
	}
};

Parser.prototype.onattribname = function(name){
	if(this._lowerCaseAttributeNames){
		name = name.toLowerCase();
	}
	this._attribname = name;
};

Parser.prototype.onattribdata = function(value){
	this._attribvalue += value;
};

Parser.prototype.onattribend = function(){
	if(this._cbs.onattribute) { this._cbs.onattribute(this._attribname, this._attribvalue); }
	if(
		this._attribs &&
		!Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)
	){
		this._attribs[this._attribname] = this._attribvalue;
	}
	this._attribname = "";
	this._attribvalue = "";
};

Parser.prototype._getInstructionName = function(value){
	var idx = value.search(re_nameEnd),
	    name = idx < 0 ? value : value.substr(0, idx);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	return name;
};

Parser.prototype.ondeclaration = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("!" + name, "!" + value);
	}
};

Parser.prototype.onprocessinginstruction = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("?" + name, "?" + value);
	}
};

Parser.prototype.oncomment = function(value){
	this._updatePosition(4);

	if(this._cbs.oncomment) { this._cbs.oncomment(value); }
	if(this._cbs.oncommentend) { this._cbs.oncommentend(); }
};

Parser.prototype.oncdata = function(value){
	this._updatePosition(1);

	if(this._options.xmlMode || this._options.recognizeCDATA){
		if(this._cbs.oncdatastart) { this._cbs.oncdatastart(); }
		if(this._cbs.ontext) { this._cbs.ontext(value); }
		if(this._cbs.oncdataend) { this._cbs.oncdataend(); }
	} else {
		this.oncomment("[CDATA[" + value + "]]");
	}
};

Parser.prototype.onerror = function(err){
	if(this._cbs.onerror) { this._cbs.onerror(err); }
};

Parser.prototype.onend = function(){
	if(this._cbs.onclosetag){
		for(
			var i = this._stack.length;
			i > 0;
			this._cbs.onclosetag(this._stack[--i])
		){  }
	}
	if(this._cbs.onend) { this._cbs.onend(); }
};


//Resets the parser to a blank state, ready to parse a new HTML document
Parser.prototype.reset = function(){
	if(this._cbs.onreset) { this._cbs.onreset(); }
	this._tokenizer.reset();

	this._tagname = "";
	this._attribname = "";
	this._attribs = null;
	this._stack = [];

	if(this._cbs.onparserinit) { this._cbs.onparserinit(this); }
};

//Parses a complete HTML document and pushes it to the handler
Parser.prototype.parseComplete = function(data){
	this.reset();
	this.end(data);
};

Parser.prototype.write = function(chunk){
	this._tokenizer.write(chunk);
};

Parser.prototype.end = function(chunk){
	this._tokenizer.end(chunk);
};

Parser.prototype.pause = function(){
	this._tokenizer.pause();
};

Parser.prototype.resume = function(){
	this._tokenizer.resume();
};

//alias for backwards compat
Parser.prototype.parseChunk = Parser.prototype.write;
Parser.prototype.done = Parser.prototype.end;

var Parser_1 = Parser;

// monkey patching css-select/lib/attributes to reflect difference in how classes are stored
// Note: in XNode classes are stored in a Set instead of a string
var _elementRule = attributes.rules.element;
attributes.rules.element = function(next, data) {
  if (data.name === 'class') {
    var value = data.value;
    if (/\s/.test(value)) { return function() { return false } }
    return function clazz(elem) {
      var classes = elem.classes;
      return classes && classes.has(value) && next(elem)
    }
  } else {
    return _elementRule(next, data)
  }
};

Parser_1.prototype.oncdata = function(value){
  this._updatePosition(1);

  if(this._options.xmlMode){
    if(this._cbs.oncdatastart) { this._cbs.oncdatastart(value); }
    if(this._cbs.oncdataend) { this._cbs.oncdataend(); }
  } else {
    this.oncomment("[CDATA[" + value + "]]");
  }
};

var re_whitespace = /\s+/g;

/*
  Customized implementation of [DomHandler](https://github.com/fb55/domhandler).
*/
var XDomHandler = function XDomHandler(options) {
  if ( options === void 0 ) options = {};

  this.options = options;
  this.document = null;
  this._tagStack = [];
};

// called directly after construction of Parser and at the end of Parser.reset()
XDomHandler.prototype.onparserinit = function onparserinit (){
  this.document = new XNode('document', { format: this.options.format });
  this._tagStack = [this.document];
};

XDomHandler.prototype.onend = function onend (){};

XDomHandler.prototype.onerror = function onerror (error) {
  throw error
};

XDomHandler.prototype.onclosetag = function onclosetag () {
  this._tagStack.pop();
};

XDomHandler.prototype._addDomElement = function _addDomElement (element) {
  var parent = this._tagStack[this._tagStack.length - 1];
  if (!parent.childNodes) { parent.childNodes = []; }
  var siblings = parent.childNodes;

  var previousSibling = siblings[siblings.length - 1];
  // set up next/previous link
  element.next = null;
  if(previousSibling){
    element.prev = previousSibling;
    previousSibling.next = element;
  } else {
    element.prev = null;
  }
  // either push the element to the current open tag's children, or keep a reference as top-level element
  siblings.push(element);
  element.parent = parent || null;
};

XDomHandler.prototype.onopentag = function onopentag (name, attributes) {
  var element = this.document.createElement(name);
  forEach(attributes, function (val, key) {
    element.setAttribute(key, val);
  });
  this._addDomElement(element);
  this._tagStack.push(element);
};

XDomHandler.prototype.ontext = function ontext (text) {
  if (this.options.normalizeWhitespace) {
    text = text.replace(re_whitespace, " ");
  }
  var lastTag;
  var _top = this._tagStack[this._tagStack.length - 1];
  if (_top && _top.childNodes) { lastTag = _top.childNodes[_top.childNodes.length - 1]; }
  if (lastTag && lastTag.type === index.Text) {
    lastTag.data += text;
  } else {
    var element = this.document.createTextNode(text);
    this._addDomElement(element);
  }
};

XDomHandler.prototype.oncomment = function oncomment (data) {
  var lastTag = this._tagStack[this._tagStack.length - 1];
  if(lastTag && lastTag.type === index.Comment){
    lastTag.data += data;
  } else {
    var element = this.document.createComment(data);
    this._addDomElement(element);
    this._tagStack.push(element);
  }
};

XDomHandler.prototype.oncommentend = function oncommentend () {
  this._tagStack.pop();
};

XDomHandler.prototype.oncdatastart = function oncdatastart (data) {
  var element = this.document.createCDATASection(data);
  this._addDomElement(element);
  this._tagStack.push(element);
};

XDomHandler.prototype.oncdataend = function oncdataend () {
  this._tagStack.pop();
};

XDomHandler.prototype.onprocessinginstruction = function onprocessinginstruction (name, data) {
  var element = this.document.createProcessingInstruction(name, data);
  this._addDomElement(element);
};

/*
  Parses HTML or XML

  Options:
  - format: 'html' or 'xml'
  - ownerDocument: an XNode instance of type 'document'
*/
function parseMarkup(markup, options) {
  var format = options.ownerDocument ? options.ownerDocument.format : options.format;
  if (!format) {
    throw new Error("Either 'ownerDocument' or 'format' must be set.")
  }
  var parserOptions = {
    xmlMode : (format === 'xml')
  };
  var handler = new XDomHandler({ format: format });
  var parser = new Parser_1(handler, parserOptions);
  parser.end(markup);
  return handler.document
}

var XNode = (function (DOMElement$$1) {
  function XNode(type, args) {
    if ( args === void 0 ) args = {};

    DOMElement$$1.call(this);

    this.type = type;
    if (!type) { throw new Error("'type' is mandatory") }

    this.ownerDocument = args.ownerDocument;
    if (type !== 'document' && !this.ownerDocument) {
      throw new Error("'ownerDocument' is mandatory")
    }

    // NOTE: there are some properties which are named so that this
    // can be used together with htmlparser2 and css-select
    // but which could have a better naming, e.g., name -> tagName

    switch(type) {
      case index.Tag: {
        this.name = args.name;
        if (!this.name) { throw new Error("'name' is mandatory.") }
        this.properties = new Map();
        this.attributes = new Map();
        this.classes = new Set();
        this.styles = new Map();
        this.eventListeners = [];
        this.childNodes = args.children || args.childNodes || [];
        this._assign(args);
        break
      }
      case index.Text:
      case index.Comment: {
        this.data = args.data || '';
        break
      }
      case index.CDATA: {
        this.data = args.data || '';
        break
      }
      case index.Directive: {
        this.name = args.name;
        this.data = args.data;
        break
      }
      case 'document': {
        var format = args.format;
        this.format = format;
        if (!format) { throw new Error("'format' is mandatory.") }
        this.childNodes = args.children || args.childNodes || [];
        switch(format) {
          case 'xml':
            this.contentType = 'application/xml';
            break
          case 'html':
            this.contentType = 'text/html';
            break
          default:
            throw new Error('Unsupported format ' + format)
        }
        break
      }
      default:
        this.name = null;
        this.properties = new Map();
        this.attributes = new Map();
        this.classes = new Set();
        this.styles = new Map();
        this.eventListeners = [];
        this.childNodes = args.children || args.childNodes || [];
    }
  }

  if ( DOMElement$$1 ) XNode.__proto__ = DOMElement$$1;
  XNode.prototype = Object.create( DOMElement$$1 && DOMElement$$1.prototype );
  XNode.prototype.constructor = XNode;

  var prototypeAccessors = { tagName: {},children: {},attribs: {} };

  XNode.prototype.getNativeElement = function getNativeElement () {
    return this
  };

  XNode.prototype.clone = function clone (deep) {
    var clone = new XNode(this.type, this);
    if (this.childNodes) {
      clone.childNodes.length = 0;
      if (deep) {
        this.childNodes.forEach(function (child) {
          clone.appendChild(child.clone(deep));
        });
      }
    }
    return clone
  };

  prototypeAccessors.tagName.get = function () {
    return this.getTagName()
  };

  prototypeAccessors.tagName.set = function (tagName) {
    this.setTagName(tagName);
  };

  XNode.prototype.getTagName = function getTagName () {
    if (this.name) {
      if (this.getFormat() === 'xml') {
        return this.name
      } else {
        return this.name.toLowerCase()
      }
    }
  };

  XNode.prototype.setTagName = function setTagName (tagName) {
    if (this.getFormat() === 'xml') {
      this.name = String(tagName);
    } else {
      this.name = String(tagName).toLowerCase();
    }
    return this
  };

  XNode.prototype.hasAttribute = function hasAttribute (name) {
    switch(name) {
      case 'class':
        return Boolean(this.classes)
      case 'style':
        return Boolean(this.styles)
      default:
        return this.attributes.has(name)
    }
  };

  XNode.prototype.getAttribute = function getAttribute (name) {
    switch(name) {
      case 'class':
        return stringifyClasses(this.classes)
      case 'style':
        return stringifyStyles(this.styles)
      default:
        return this.attributes.get(name)
    }
  };

  XNode.prototype.setAttribute = function setAttribute (name, value) {
    switch(name) {
      case 'class':
        parseClasses(this.classes, value);
        break
      case 'style':
        parseStyles(this.styles, value);
        break
      default:
        this.attributes.set(name, value);
    }
    return this
  };

  XNode.prototype.removeAttribute = function removeAttribute (name) {
    switch(name) {
      case 'class':
        this.classes = new Set();
        break
      case 'style':
        this.styles = new Map();
        break
      default:
        this.attributes.delete(name);
    }
    return this
  };

  // ATTENTION: this comes without 'class' and 'style'
  XNode.prototype.getAttributes = function getAttributes () {
    return this.attributes
  };

  XNode.prototype.getProperties = function getProperties () {
    if (this.properties) {
      return this.properties
    }
  };

  XNode.prototype.getProperty = function getProperty (name) {
    if (this.properties) {
      return this.properties.get(name)
    }
  };

  XNode.prototype.setProperty = function setProperty (name, value) {
    if (this.properties) {
      this.properties.set(name, value);
    }
    return this
  };

  XNode.prototype.removeProperty = function removeProperty (name) {
    if (this.properties && this.properties.hasOwnProperty(name)) {
      delete this.properties[name];
    }
    return this
  };

  XNode.prototype.hasClass = function hasClass (name) {
    if (this.classes) {
      return this.classes.has(name)
    }
    return this
  };

  XNode.prototype.addClass = function addClass (name) {
    if (this.classes) {
      this.classes.add(name);
    }
    return this
  };

  XNode.prototype.removeClass = function removeClass (name) {
    if (this.classes) {
      this.classes.delete(name);
    }
    return this
  };

  XNode.prototype.getInnerHTML = function getInnerHTML () {
    return index$3.getInnerHTML(this)
  };

  // TODO: parse html using settings from el,
  // clear old childNodes and append new childNodes
  XNode.prototype.setInnerHTML = function setInnerHTML (html) {
    var this$1 = this;

    if (this.childNodes) {
      var _doc = parseMarkup(html, {
        ownerDocument: this.getOwnerDocument()
      });
      this.empty();
      // ATTENTION: important to copy the childNodes array first
      // as appendChild removes from parent
      _doc.childNodes.slice(0).forEach(function (child) {
        this$1.appendChild(child);
      });
    }
    return this
  };

  XNode.prototype.getOuterHTML = function getOuterHTML () {
    return render(this, { xmlMode: this.getFormat() === 'xml' })
  };

  XNode.prototype.getTextContent = function getTextContent () {
    return index$3.getText(this)
  };

  XNode.prototype.setTextContent = function setTextContent (text) {
    if (this.type === 'text') {
      this.data = text;
    } else if (this.childNodes) {
      var child = this.createTextNode(text);
      this.empty();
      this.appendChild(child);
    }
    return this
  };

  XNode.prototype.getStyle = function getStyle (name) {
    if (this.styles) {
      return this.styles.get(name)
    }
  };

  XNode.prototype.setStyle = function setStyle (name, value) {
    if (this.styles) {
      if (DOMElement$$1.pxStyles[name] && isNumber(value)) { value = value + "px"; }
      this.styles.set(name, value);
    }
    return this
  };

  XNode.prototype.is = function is (cssSelector) {
    return index$1.is(this, cssSelector, { xmlMode: this.getFormat() === 'xml' })
  };

  XNode.prototype.find = function find (cssSelector) {
    return index$1.selectOne(cssSelector, this, { xmlMode: this.getFormat() === 'xml' })
  };

  XNode.prototype.findAll = function findAll (cssSelector) {
    return index$1.selectAll(cssSelector, this, { xmlMode: this.getFormat() === 'xml' })
  };

  XNode.prototype.getChildCount = function getChildCount () {
    if (this.childNodes) {
      return this.childNodes.length
    } else {
      return 0
    }
  };

  XNode.prototype.getChildNodes = function getChildNodes () {
    return this.childNodes.slice(0)
  };

  XNode.prototype.getChildren = function getChildren () {
    return this.childNodes.filter(function(node) {
      return node.type === "tag"
    })
  };

  prototypeAccessors.children.get = function () {
    return this.getChildren()
  };

  XNode.prototype.getChildAt = function getChildAt (pos) {
    if (this.childNodes) {
      return this.childNodes[pos]
    }
  };

  XNode.prototype.getChildIndex = function getChildIndex (child) {
    if (this.childNodes) {
      return this.childNodes.indexOf(child)
    }
  };

  XNode.prototype.getLastChild = function getLastChild () {
    if (this.childNodes) {
      return last$2(this.childNodes)
    }
  };

  XNode.prototype.getFirstChild = function getFirstChild () {
    if (this.childNodes) {
      return this.childNodes[0]
    }
  };

  XNode.prototype.getNextSibling = function getNextSibling () {
    return this.next
  };

  XNode.prototype.getPreviousSibling = function getPreviousSibling () {
    return this.prev
  };

  XNode.prototype.getParent = function getParent () {
    return this.parent
  };

  XNode.prototype.getRoot = function getRoot () {
    var el = this;
    while (el.parent) { el = el.parent; }
    return el
  };

  XNode.prototype.getOwnerDocument = function getOwnerDocument () {
    return (this.type === 'document') ? this : this.ownerDocument
  };

  XNode.prototype.getFormat = function getFormat () {
    return this.getOwnerDocument().format
  };

  XNode.prototype.isTextNode = function isTextNode () {
    return this.type === "text"
  };

  XNode.prototype.isElementNode = function isElementNode () {
    return this.type === "tag" || this.type === "script"
  };

  XNode.prototype.isCommentNode = function isCommentNode () {
    return this.type === "comment"
  };

  XNode.prototype.isDocumentNode = function isDocumentNode () {
    return this.type === "document"
  };

  XNode.prototype.isComponentNode = function isComponentNode () {
    return this.type === "component"
  };

  XNode.prototype.createDocument = function createDocument (format) {
    return XNode.createDocument(format)
  };

  XNode.prototype.createElement = function createElement (tagName) {
    return new XNode(index.Tag, { name: tagName, ownerDocument: this.getOwnerDocument() })
  };

  XNode.prototype.createTextNode = function createTextNode (text) {
    return new XNode(index.Text, { data: text, ownerDocument: this.getOwnerDocument() })
  };

  XNode.prototype.createComment = function createComment (data) {
    return new XNode(index.Comment, { data: data, ownerDocument: this.getOwnerDocument() })
  };

  XNode.prototype.createProcessingInstruction = function createProcessingInstruction (name, data) {
    return new XNode(index.Directive, { name: name, data: data, ownerDocument: this.getOwnerDocument() })
  };

  XNode.prototype.createCDATASection = function createCDATASection (data) {
    return new XNode(index.CDATA, { data: data, ownerDocument: this.getOwnerDocument() })
  };

  XNode.prototype.appendChild = function appendChild (child) {
    if (this.childNodes && !isNil(child)) {
      child = this._normalizeChild(child);
      if (!child) { return this }
      index$3.appendChild(this, child);
      child.ownerDocument = this.getOwnerDocument();
      this._onAttach(child);
    }
    return this
  };

  XNode.prototype.removeChild = function removeChild (child) {
    if (child.parentNode === this) {
      child.remove();
    }
  };

  XNode.prototype.insertAt = function insertAt (pos, child) {
    child = this._normalizeChild(child);
    if (!child) { return this }
    var childNodes = this.childNodes;
    if (childNodes) {
      // NOTE: manipulating htmlparser's internal children array
      if (pos >= childNodes.length) {
        index$3.appendChild(this, child);
      } else {
        index$3.prepend(childNodes[pos], child);
      }
      child.ownerDocument = this.getOwnerDocument();
      this._onAttach(child);
    }
    return this
  };

  XNode.prototype.insertBefore = function insertBefore (newChild, before) {
    if (this.childNodes) {
      var pos = this.childNodes.indexOf(before);
      if (pos > -1) {
        index$3.prepend(before, newChild);
        newChild.ownerDocument = this.getOwnerDocument();
      } else {
        throw new Error('insertBefore(): reference node is not a child of this element.')
      }
      this._onAttach(newChild);
    }
    return this
  };

  XNode.prototype.removeAt = function removeAt (pos) {
    var childNodes = this.childNodes;
    if (childNodes) {
      var child = childNodes[pos];
      child.remove();
      this._onDetach(child);
    }
    return this
  };

  XNode.prototype.empty = function empty () {
    var this$1 = this;

    var childNodes = this.childNodes;
    if (childNodes) {
      childNodes.forEach(function (child) {
        child.next = child.prev = child.parent = null;
        this$1._onDetach(child);
      });
      childNodes.length = 0;
    }
    return this
  };

  XNode.prototype.remove = function remove () {
    var parent = this.parent;
    index$3.removeElement(this);
    if (parent) {
      parent._onDetach(this);
    }
    return this
  };

  XNode.prototype.replaceChild = function replaceChild (oldChild, newChild) {
    if (oldChild.parent === this) {
      oldChild.replaceWith(newChild);
    }
    return this
  };

  XNode.prototype.replaceWith = function replaceWith (newEl) {
    var parent = this.parent;
    newEl = this._normalizeChild(newEl);
    index$3.replaceElement(this, newEl);
    newEl.ownerDocument = this.getOwnerDocument();
    if (parent) {
      parent._onDetach(this);
      parent._onAttach(newEl);
    }
    return this
  };

  XNode.prototype.getEventListeners = function getEventListeners () {
    return this.eventListeners
  };

  XNode.prototype.addEventListener = function addEventListener (eventName, handler, options) {
    var listener;
    if (arguments.length === 1 && arguments[0]) {
      listener = arguments[0];
    } else {
      listener = new DOMEventListener(eventName, handler, options);
    }
    if (listener.options.selector && !listener.__hasEventDelegation__) {
      listener.handler = DelegatedEvent.delegatedHandler(listener, this);
      listener.__hasEventDelegation__ = true;
    }
    if (!this.eventListeners) {
      this.eventListeners = [];
    }
    listener._el = this;
    this.eventListeners.push(listener);
    return this
  };

  XNode.prototype.removeEventListener = function removeEventListener (eventName, handler) {
    // console.log('removing event listener', eventName, handler);
    var listener = null, idx = -1;
    idx = DOMEventListener.findIndex(this.eventListeners, eventName, handler);
    listener = this.eventListeners[idx];
    if (idx > -1) {
      this.eventListeners.splice(idx, 1);
      listener._el = null;
    }
    return this
  };

  XNode.prototype.click = function click () {
    this._emitEvent('click', { target: this });
    return this
  };

  // TODO: flesh this out
  XNode.prototype._emitEvent = function _emitEvent (eventName, data) {
    this._propagateEvent(new XNodeEvent(eventName, data));
  };

  XNode.prototype._propagateEvent = function _propagateEvent (event) {
    var listeners = this.eventListeners;
    if (listeners) {
      var listener = listeners.find(function (l) {
        return l.eventName === event._name
      });
      if (listener) { listener.handler(event); }
      if (event.stopped) { return }
      var p = this.parentNode;
      if (p) { p._propagateEvent(event); }
    }
  };

  XNode.prototype.removeAllEventListeners = function removeAllEventListeners () {
    this.eventListeners = [];
    return this
  };

  prototypeAccessors.attribs.get = function () {
    return this.attributes
  };

  XNode.prototype._assign = function _assign (other) {
    var this$1 = this;

    if (other.name) { this.name = other.name; }
    if (this.classes && other.classes) {
      other.classes.forEach(function (val) {
        this$1.classes.add(val);
      });
    }
    if (this.styles && other.styles) {
      forEach(other.styles, function (val, name) {
        this$1.styles.set(name, val);
      });
    }
    // TODO: while it is 'smart' to deal with 'style' and 'class'
    // implicitly, it introduces some confusion here
    var otherAttributes = other.attributes || other.attribs;
    if (this.attributes && otherAttributes) {
      forEach(other.attributes, function (val, name) {
        switch (name) {
          case 'class': {
            parseClasses(this$1.classes, val);
            break
          }
          case 'style': {
            parseStyles(this$1.styles, val);
            break
          }
          default:
            this$1.attributes.set(name, val);
        }
      });
    }
    if (this.properties && other.properties) {
      forEach(other.properties, function (val, name) {
        this$1.properties.set(name, val);
      });
    }
    if (this.eventListeners && other.eventListeners) {
      this.eventListeners = this.eventListeners.concat(other.eventListeners);
    }
  };

  XNode.prototype._onAttach = function _onAttach (child) {}; // eslint-disable-line no-unused-vars

  XNode.prototype._onDetach = function _onDetach (child) {}; // eslint-disable-line no-unused-vars

  XNode.prototype._normalizeChild = function _normalizeChild (child) {
    if (isString(child)) {
      child = this.createTextNode(child);
    }
    if (!child || !child._isXNode) {
      throw new Error('Illegal argument: only String and XNode instances are valid.')
    }
    return child
  };

  XNode.prototype._attach = function _attach (child) {
    child.parent = this;
  };

  XNode.prototype._detach = function _detach (child) {
    child.parent = null;
  };

  Object.defineProperties( XNode.prototype, prototypeAccessors );

  return XNode;
}(DOMElement));

XNode.prototype._isXNode = true;

XNode.createDocument = function(format) {
  if (format === 'xml') {
    return new XNode('document', { format: format })
  } else {
    return XNode.parseMarkup(DOMElement.EMPTY_HTML, 'html')
  }
};

XNode.createElement = function(tagName, ownerDocument) {
  return new XNode(index.Tag, {
    name: tagName,
    ownerDocument: ownerDocument
  })
};

XNode.createTextNode = function(text, ownerDocument) {
  return new XNode(index.Text, {
    data: text,
    ownerDocument: ownerDocument
  })
};

XNode.parseMarkup = function(str, format, isFullDoc) {
  if (!str) {
    return XNode.createDocument(format)
  }
  var doc;
  if (format === 'html') {
    isFullDoc = (str.search(/<\s*html/i)>=0);
    doc = parseMarkup(str, { format: format });
  } else if (format === 'xml') {
    doc = parseMarkup(str, { format: format });
  }
  if (doc) {
    if (format === 'html') {
      if (isFullDoc) {
        return doc.find('html')
      } else {
        // NOTE: for partials we create a consistent HTML structure and
        // append the parsed elements to body
        // TODO: this is maybe not 100% correct for all inputs (e.g. '<head></head>')
        var childNodes = doc.childNodes.slice(0);
        doc.empty();
        doc.appendChild(doc.createElement('head'));
        doc.appendChild(doc.createElement('body').append(childNodes));
        return _manyOrOne(childNodes)
      }
    } else if (format === 'xml') {
      if (isFullDoc) {
        return doc
      } else {
        return _manyOrOne(doc.childNodes)
      }
    }
  } else {
    throw new Error('Could not parse DOM string.')
  }

  function _manyOrOne(elements) {
    if (elements.length === 1) {
      return elements[0]
    } else {
      return elements
    }
  }
};

XNode.parseHTML = function(html, isFullDoc) {
  return XNode.parseMarkup(html, 'html', isFullDoc)
};

XNode.parseXML = function(html, isFullDoc) {
  return XNode.parseMarkup(html, 'xml', isFullDoc)
};

XNode.wrapNativeElement = function(el) {
  // HACK: at many places we have an `isBrowser` check
  // to skip code that uses window or window.document
  // To be able to test such code together with the memory DOM implementation
  // we stub out window and document
  if (inBrowser) {
    if (el === window || el === window.document) { return new DOMElementStub() }
  }
  if (!el._isXNode) { throw new Error('Illegal argument: expected XNode instance') }
  return el
};

function parseClasses(classes, classStr) {
  classStr.split(/\s+/).forEach(function (name) {
    classes.add(name);
  });
}

function stringifyClasses(classes) {
  return Array.from(classes).join(' ')
}

function parseStyles(styles, styleStr) {
  styleStr = (styleStr || '').trim();
  if (!styleStr) { return }
  styleStr.split(';').forEach(function (style) {
    var n = style.indexOf(':');
    // skip if there is no :, or if it is the first/last character
    if (n < 1 || n === style.length-1) { return }
    var name = style.slice(0,n).trim();
    var val = style.slice(n+1).trim();
    styles.set(name, val);
  });
}

function stringifyStyles(styles) {
  if (!styles) { return '' }
  var str = Object.keys(styles).map(function (name) {
    return name + ':' + styles[name]
  }).join(';');
  if (str.length > 0) { str += ';'; }
  return str
}

// TODO: could be a bit closer to the real DOM impl
var XNodeEvent = function XNodeEvent(name, data) {
  this._name = name;

  Object.assign(this, data);
};

XNodeEvent.prototype.stopPropagation = function stopPropagation () {
  this.stopped = true;
};

// just a stub
XNodeEvent.prototype.preventDefault = function preventDefault () {};

var DOMElementStub = function DOMElementStub () {};

DOMElementStub.prototype.on = function on () {};
DOMElementStub.prototype.off = function off (){};

var DefaultDOMElementClass = inBrowser ? BrowserDOMElement : XNode;

/**
  A Bridge to the default DOMElement implementation, either BrowserDOMElement, or MemoryDOMElement.
*/
var DefaultDOMElement = {};

DefaultDOMElement.createDocument = function(format) {
  return DefaultDOMElement._impl.createDocument(format)
};

DefaultDOMElement.createElement = function(tagName) {
  return DefaultDOMElement._impl.createElement(tagName)
};

DefaultDOMElement.createTextNode = function(text) {
  return DefaultDOMElement._impl.createTextNode(text)
};

/*
  A wrapper for Browser's `window` providing
  the DOMElement's eventlistener API.
*/
DefaultDOMElement.getBrowserWindow = function() {
  return DefaultDOMElement._impl.getBrowserWindow()
};

/*
  @param {String} html
  @returns {DOMElement|DOMElement[]}
*/
DefaultDOMElement.parseHTML = function(html) {
  return DefaultDOMElement._impl.parseHTML(html)
};

/*
  @param {String} xml
  @returns {DOMElement|DOMElement[]}
*/
DefaultDOMElement.parseXML = function(xml, fullDoc) {
  return DefaultDOMElement._impl.parseXML(xml, fullDoc)
};

DefaultDOMElement.wrap =
DefaultDOMElement.wrapNativeElement = function(el) {
  if (!el) { throw new Error('Illegal argument') }
  // in Browser we can use both implementations
  if (el._isXNode) { return el }
  else { return DefaultDOMElement._impl.wrapNativeElement(el) }
};

DefaultDOMElement.isReverse = function(anchorNode, anchorOffset, focusNode, focusOffset) {
  return DefaultDOMElement._impl.isReverse(anchorNode, anchorOffset, focusNode, focusOffset)
};

DefaultDOMElement._impl = DefaultDOMElementClass;

DefaultDOMElement._reset = function() {
  DefaultDOMElement._impl = DefaultDOMElementClass;
};

DefaultDOMElement._useXNode = function() {
  DefaultDOMElement._impl = XNode;
};

/*

  ## Rendering Algorithm

  TODO: document the algorithm

  ## Findings

  What makes our rendering algorithm so difficult?

  - Dependency Injection requires a (direct) parent to be allow constructor injection, i.e. that injected dependencies
    are available in the constructor already. As a consequence a component tree must to be constructed from top to down.

  - The earliest time to evaluate `$$(MyComponent)`, is when it has been attached to an existing component.
    I.e., to run `MyComponent.render()` an instance of `MyComponent` is needed, which can only be created with an existing
    parent component.

  - In general, it is *not* possible to have a naturally descending rendering algorithm, i.e. a simple recursion calling
    `render()` and creating or updating Components on the way, preserving a simple stack-trace.
    Instead, it requires calling `render()` on one level, then doing comparisons with the existing tree
    to be able to reuse components, and then descend into the sub-tree.

  - If components are passed down via props, things get even more difficult.
    For example, consider a situation where components are passed via props:
    ```
      render($$) {
        return $$('div').append(
          $$(Wrapper, {
            foo: $$(MyComponent)
          })
        )
      }
    ```
    At the time when this component gets rendered, `MyComponent` can not be instantiated, as it is not known what `Wrapper`
    actually does with it.
    While the general approach is working from top-to-down, in this case it has a bottom-to-up nature, i.e., the child needs
    to be rendered to know what to do with the passed component.

    Particularly, this is problematic when the passed component has a reference:
    ```
      render($$) {
        return $$('div').append(
          $$(Wrapper, {
            foo: $$(MyComponent).ref('foo')
          })
        )
      }
    ```
    As nothing is known at the time of descending about the content of `Wrapper` the rendering algorithm
    can not tell that it ought to be preserved. For now, the correct way to deal with this situation is
    to use a reference for the wrapper as well:
    ```
      render($$) {
        return $$('div').append(
          $$(Wrapper, {
            foo: $$(MyComponent).ref('foo')
          }).ref('wrapper')
        )
      }
    ```

  ## TODO

  There is a lot of hacks in the current implementation, which should be cleaned up when we have time.
  - remove means to change props of VirtualComponent dynamically: currently, it is possible to do something like
    ```
      $$(MyComponent).attr({ "data-id": "foo" }).append('foo')
    ```
    ATM, `attr()` and `append()` represent a means to change the `props` of the component.
    This is pretty inconsistent and creates confusion about the responsibility for rendering the element.
    Only the Component's `render()` should be responsible for that. If necessary, children or anything like that must
    be passed down via props.
  - remove outlets: outlets are just another way to change props.
  - try to fuse `virtualComponent._content` into virtualComponent: ATM, `VirtualComponent` uses a `VirtualHTMLElement`
    instance to store the result of `render()`. This makes understanding the virtual tree after rendering difficult,
    as there is another layer via `virtualComponent._content`.
  - Rethink strategy for 'reusing' components: ATM we consider refs as the key indicator whether to preserve a component
    or not. This makes sense essentially, but could be extended to an opportunistic strategy where components are reused
    implicitly when they are at the right place.
*/
var RenderingEngine = function RenderingEngine(options) {
  if ( options === void 0 ) options = {};

  this.elementFactory = options.elementFactory || DefaultDOMElement.createDocument('html');
};

RenderingEngine.prototype._render = function _render$1 (comp, oldProps, oldState) {
  // var t0 = Date.now();
  var vel = _createWrappingVirtualComponent(comp);
  var state = new RenderingEngine.State(this.elementFactory);
  if (oldProps) {
    state.setOldProps(vel, oldProps);
  }
  if (oldState) {
    state.setOldState(vel, oldState);
  }
  try {
    _capture(state, vel, 'forceCapture');
    if (vel._isVirtualComponent) {
      _render(state, vel._content);
    } else {
      _render(state, vel);
    }
    _triggerUpdate(state, vel);
  } finally {
    state.dispose();
  }
  // console.log("RenderingEngine: finished rendering in %s ms", Date.now()-t0);
};

// this is used together with the incremental Component API
RenderingEngine.prototype._renderChild = function _renderChild (comp, vel) {
  // HACK: to make this work with the rest of the implementation
  // we ingest a fake parent
  var state = new RenderingEngine.State(this.elementFactory);
  vel.parent = { _comp: comp };
  try {
    _capture(state, vel);
    _render(state, vel);
    return vel._comp;
  } finally {
    state.dispose();
  }
};


function _create(state, vel) {
  var comp = vel._comp;
  console.assert(!comp, "Component instance should not exist when this method is used.");
  var parent = vel.parent._comp;
  // making sure the parent components have been instantiated
  if (!parent) {
    parent = _create(state, vel.parent);
  }
  if (vel._isVirtualComponent) {
    console.assert(parent, "A Component should have a parent.");
    comp = new vel.ComponentClass(parent, vel.props);
    // HACK: making sure that we have the right props
    vel.props = comp.props;
    comp.__htmlConfig__ = vel._copyHTMLConfig();
  } else if (vel._isVirtualHTMLElement) {
    comp = new Component.Element(parent, vel);
  } else if (vel._isVirtualTextNode) {
    comp = new Component.TextNode(parent, vel);
  }
  if (vel._ref) {
    comp._ref = vel._ref;
  }
  if (vel._owner) {
    comp._owner = vel._owner._comp;
  }
  vel._comp = comp;
  return comp;
}

function _capture(state, vel, forceCapture) {
  if (state.isCaptured(vel)) {
    return vel;
  }
  // a captured VirtualElement has a component instance attached
  var comp = vel._comp;
  if (!comp) {
    comp = _create(state, vel);
    state.setNew(vel);
  }
  if (vel._isVirtualComponent) {
    var needRerender;
    // NOTE: forceCapture is used for the first entrance
    // from this.render(comp) where we want to fource capturing
    // as it has already been cleared that a rerender is necessary
    if (forceCapture) {
      needRerender = true;
    } else {
      // NOTE: don't ask shouldRerender if no element is there yet
      needRerender = !comp.el || comp.shouldRerender(vel.props, comp.state);
      comp.__htmlConfig__ = vel._copyHTMLConfig();
      state.setOldProps(vel, comp.props);
      state.setOldState(vel, comp.state);
      // updates prop triggering willReceiveProps
      comp._setProps(vel.props);
      if (!state.isNew(vel)) {
        state.setUpdated(vel);
      }
    }
    if (needRerender) {
      var context = new CaptureContext(vel);
      var content = comp.render(context.$$);
      if (!content || !content._isVirtualHTMLElement) {
        throw new Error("Component.render must return VirtualHTMLElement");
      }

      if (comp.__htmlConfig__) {
        content._mergeHTMLConfig(comp.__htmlConfig__);
      }
      content._comp = comp;
      vel._content = content;
      if (!state.isNew(vel) && comp.isMounted()) {
        state.setUpdated(vel);
      }
      // Mapping: map virtual elements to existing components based on refs
      _prepareVirtualComponent(state, comp, content);
      // Descending
      // TODO: only do this in DEBUG mode
      if (substanceGlobals.DEBUG_RENDERING) {
        // in this case we use the render() function as iterating function, where
        // $$ is a function which creates components and renders them recursively.
        // first we can create all element components that can be reached
        // without recursion
        var stack = content.children.slice(0);
        while (stack.length) {
          var child = stack.shift();
          if (state.isCaptured(child)) { continue }
          // virtual components are addressed via recursion, not captured here
          if (child._isVirtualComponent) { continue }
          if (!child._comp) {
            _create(state, child);
          }
          if (child._isVirtualHTMLElement && child.children.length > 0) {
            stack = stack.concat(child.children);
          }
          state.setCaptured(child);
        }
        state.setCaptured(content);
        // then we run comp.render($$) with a special $$ that captures VirtualComponent's
        // recursively
        var descendingContext = new DescendingContext(state, context);
        while (descendingContext.hasPendingCaptures()) {
          descendingContext.reset();
          comp.render(descendingContext.$$);
        }
      } else {
        // a VirtualComponent has its content as a VirtualHTMLElement
        // which needs to be captured recursively
        _capture(state, vel._content);
      }
    } else {
      state.setSkipped(vel);
    }
  } else if (vel._isVirtualHTMLElement) {
    for (var i = 0; i < vel.children.length; i++) {
      _capture(state, vel.children[i]);
    }
  }
  state.setCaptured(vel);
  return vel;
}

function _render(state, vel) {
  if (state.isSkipped(vel)) { return; }

  // before changes can be applied, a VirtualElement must have been captured
  // FIXME: with DEBUG_RENDERING we are having troubles with this assumption.
  // It happens when the rerendered component is having children injected from its parent.
  // Then the parent is no rerendered this, these injected components are not recaptured, and this assertion does not hold.
  // However, it seems not to be critical, as these components don't need to be rerendered
  // Still we should find a consistent way

  var comp = vel._comp;
  console.assert(comp && comp._isComponent, "A captured VirtualElement must have a component instance attached.");

  // VirtualComponents apply changes to its content element
  if (vel._isVirtualComponent) {
    _render(state, vel._content);
    return;
  }
  // render the element
  if (!comp.el) {
    comp.el = _createElement(state, vel);
    comp.el._comp = comp;
  }
  _updateElement(comp, vel);

  // structural updates are necessary only for HTML elements (without innerHTML set)
  if (vel._isVirtualHTMLElement && !vel.hasInnerHTML()) {
    var newChildren = vel.children;
    var oldComp, virtualComp, newComp;
    var pos1 = 0; var pos2 = 0;

    // HACK: removing all childNodes that are not owned by a component
    // this happened in Edge every 1s. Don't know why.
    // With this implementation all external DOM mutations will be eliminated
    var oldChildren = [];
    comp.el.getChildNodes().forEach(function(node) {
      var childComp = node._comp;

      // TODO: to allow mounting a prerendered DOM element
      // we would need to allow to 'take ownership' instead of removing
      // the element. This being a special situation, we should only
      // do that when mounting

      // remove orphaned nodes and relocated components
      if (!childComp || state.isRelocated(childComp)) {
        comp.el.removeChild(node);
      } else {
        oldChildren.push(childComp);
      }
    });

    while(pos1 < oldChildren.length || pos2 < newChildren.length) {
      // skip detached components
      // Note: components get detached when preserved nodes
      // are found in a swapped order. Then the only way is
      // to detach one of them from the DOM, and reinsert it later at the new position
      do {
        oldComp = oldChildren[pos1++];
      } while (oldComp && (state.isDetached(oldComp)));

      virtualComp = newChildren[pos2++];
      // remove remaining old ones if no new one is left
      if (oldComp && !virtualComp) {
        while (oldComp) {
          _removeChild(state, comp, oldComp);
          oldComp = oldChildren[pos1++];
        }
        break;
      }

      // Try to reuse TextNodes to avoid unnecesary DOM manipulations
      if (oldComp && oldComp.el.isTextNode() &&
          virtualComp && virtualComp._isVirtualTextNode &&
          oldComp.el.textContent === virtualComp.text ) {
        continue;
      }

      if (!state.isRendered(virtualComp)) {
        _render(state, virtualComp);
      }

      newComp = virtualComp._comp;

      // ATTENTION: relocating a component does not update its context
      if (state.isRelocated(newComp)) {
        newComp._setParent(comp);
      }

      console.assert(newComp, 'Component instance should now be available.');
      // append remaining new ones if no old one is left
      if (virtualComp && !oldComp) {
        _appendChild(state, comp, newComp);
        continue;
      }
      // Differential update
      else if (state.isMapped(virtualComp)) {
        // identity
        if (newComp === oldComp) {
          // no structural change
        } else {
          // the order of elements with ref has changed
          state.setDetached(oldComp);
          _removeChild(state, comp, oldComp);
          pos2--;
        }
      }
      else if (state.isMapped(oldComp)) {
        _insertChildBefore(state, comp, newComp, oldComp);
        pos1--;
      } else {
        // both elements are not mapped
        // TODO: we could try to reuse components if they are of same type
        // However, this needs a better mapping strategy, not only
        // based on refs.
        _replaceChild(state, comp, oldComp, newComp);
      }
    }
  }

  // HACK: a temporary solution to handle refs owned by an ancestor
  // is to store them here as well, so that we can map virtual components
  // efficiently
  var refs = {};
  var foreignRefs = {};
  if (vel._context) {
    forEach(vel._context.refs, function(vel, ref) {
      refs[ref] = vel._comp;
    });
    forEach(vel._context.foreignRefs, function(vel, ref) {
      foreignRefs[ref] = vel._comp;
    });
  }
  comp.refs = refs;
  comp.__foreignRefs__ = foreignRefs;

  state.setRendered(vel);
}

function _triggerUpdate(state, vel) {
  if (vel._isVirtualComponent) {
    if (!state.isSkipped(vel)) {
      vel._content.children.forEach(_triggerUpdate.bind(null, state));
    }
    if (state.isUpdated(vel)) {
      vel._comp.didUpdate(state.getOldProps(vel), state.getOldState(vel));
    }
  } else if (vel._isVirtualHTMLElement) {
    vel.children.forEach(_triggerUpdate.bind(null, state));
  }
}

function _appendChild(state, parent, child) {
  parent.el.appendChild(child.el);
  _triggerDidMount(state, parent, child);
}

function _replaceChild(state, parent, oldChild, newChild) {
  parent.el.replaceChild(oldChild.el, newChild.el);
  if (!state.isDetached(oldChild)) {
    oldChild.triggerDispose();
  }
  _triggerDidMount(state, parent, newChild);
}

function _insertChildBefore(state, parent, child, before) {
  parent.el.insertBefore(child.el, before.el);
  _triggerDidMount(state, parent, child);
}

function _removeChild(state, parent, child) {
  parent.el.removeChild(child.el);
  if (!state.isDetached(child)) {
    child.triggerDispose();
  }
}

function _triggerDidMount(state, parent, child) {
  if (!state.isDetached(child) &&
      parent.isMounted() && !child.isMounted()) {
    child.triggerDidMount(true);
  }
}

/*
  Prepares a new virtual component by comparing it with
  the old version.

  It sets the _comp references in the new version where its ancestors
  can be mapped to corresponding virtual components in the old version.
*/
function _prepareVirtualComponent(state, comp, vc) {
  var newRefs = {};
  var foreignRefs = {};
  // TODO: iron this out. refs are stored on the context
  // though, it would be cleaner if they were on the VirtualComponent
  // Where vc._owner would need to be a VirtualComponent and not a
  // component.
  if (vc._context) {
    newRefs = vc._context.refs;
    foreignRefs = vc._context.foreignRefs;
  }
  var oldRefs = comp.refs;
  var oldForeignRefs = comp.__foreignRefs__;
  // map virtual components to existing ones
  forEach(newRefs, function(vc, ref) {
    var comp = oldRefs[ref];
    if (comp) { _mapComponents(state, comp, vc); }
  });
  forEach(foreignRefs, function(vc, ref) {
    var comp = oldForeignRefs[ref];
    if (comp) { _mapComponents(state, comp, vc); }
  });
}

/*
  This tries to map the virtual component to existing component instances
  by looking at the old and new refs, making sure that the element type is
  compatible.
  This is then applied to the ancestors leading to an implicit
  mapping of parent elements, which makes
*/

function _mapComponents(state, comp, vc) {
  if (!comp && !vc) { return true; }
  if (!comp || !vc) { return false; }
  // Stop if one them has been mapped already
  // or the virtual element has its own component already
  // or if virtual element and component do not match semantically
  // Note: the owner component is mapped at very first, so this
  // recursion will stop at the owner at the latest.
  if (state.isMapped(vc) || state.isMapped(comp)) {
    return vc._comp === comp;
  }
  if (vc._comp) {
    if (vc._comp === comp) {
      state.setMapped(vc);
      state.setMapped(comp);
      return true;
    } else {
      return false;
    }
  }
  if (!_isOfSameType(comp, vc)) {
    return false;
  }

  vc._comp = comp;
  state.setMapped(vc);
  state.setMapped(comp);

  var canMapParent;
  var parent = comp.getParent();
  if (vc.parent) {
    canMapParent = _mapComponents(state, parent, vc.parent);
  }
  // to be able to support implicit retaining of elements
  // we need to propagate mapping through the 'preliminary' parent chain
  // i.e. not taking the real parents as rendered, but the Components into which
  // we have passed children (via vel.append() or vel.outlet().append())
  else if (vc._preliminaryParent) {
    while (parent && parent._isElementComponent) {
      parent = parent.getParent();
    }
    canMapParent = _mapComponents(state, parent, vc._preliminaryParent);
  }
  if (!canMapParent) {
    state.setRelocated(vc);
    state.setRelocated(comp);
  }
  return canMapParent;
}

function _isOfSameType(comp, vc) {
  return (
    (comp._isElementComponent && vc._isVirtualHTMLElement) ||
    (comp._isComponent && vc._isVirtualComponent && comp.constructor === vc.ComponentClass) ||
    (comp._isTextNodeComponent && vc._isVirtualTextNode)
  );
}

function _createElement(state, vel) {
  var el;
  if (vel._isVirtualTextNode) {
    el = state.elementFactory.createTextNode(vel.text);
  } else {
    el = state.elementFactory.createElement(vel.tagName);
  }
  return el;
}

function _updateElement(comp, vel) {
  if (comp._isTextNodeComponent) {
    comp.setTextContent(vel.text);
    return;
  }
  var el = comp.el;
  console.assert(el, "Component's element should exist at this point.");
  var tagName = el.getTagName();
  if (vel.tagName.toLowerCase() !== tagName) {
    el.setTagName(vel.tagName);
  }
  _updateHash({
    oldHash: el.getAttributes(),
    newHash: vel.getAttributes(),
    update: function(key, val) {
      el.setAttribute(key, val);
    },
    remove: function(key) {
      el.removeAttribute(key);
    }
  });
  _updateHash({
    oldHash: el.htmlProps,
    newHash: vel.htmlProps,
    update: function(key, val) {
      el.setProperty(key, val);
    },
    remove: function(key) {
      el.removeProperty(key);
    }
  });
  _updateListeners({
    el: el,
    oldListeners: el.getEventListeners(),
    newListeners: vel.getEventListeners()
  });

  // special treatment of HTML elements having custom innerHTML
  if (vel.hasInnerHTML()) {
    if (!el._hasInnerHTML) {
      el.empty();
      el.setInnerHTML(vel.getInnerHTML());
    } else {
      var oldInnerHTML = el.getInnerHTML();
      var newInnerHTML = vel.getInnerHTML();
      if (oldInnerHTML !== newInnerHTML) {
        el.setInnerHTML(newInnerHTML);
      }
    }
    el._hasInnerHTML = true;
  }
}

function _updateHash(args) {
  var newHash = args.newHash;
  var oldHash = args.oldHash || {};
  var updatedKeys = {};
  var update = args.update;
  var remove = args.remove;
  var key;
  for (key in newHash) {
    if (newHash.hasOwnProperty(key)) {
      var oldVal = oldHash[key];
      var newVal = newHash[key];
      updatedKeys[key] = true;
      if (oldVal !== newVal) {
        update(key, newVal);
      }
    }
  }
  for (key in oldHash) {
    if (oldHash.hasOwnProperty(key) && !updatedKeys[key]) {
      remove(key);
    }
  }
}

function _updateListeners(args) {
  var el = args.el;
  // NOTE: considering the low number of listeners
  // it is quicker to just remove all
  // and add again instead of computing the minimal update
  var newListeners = args.newListeners || [];
  el.removeAllEventListeners();
  for (var i=0; i<newListeners.length;i++) {
    el.addEventListener(newListeners[i]);
  }
}


/*
  Descending Context Used by RenderingEngine
*/

var DescendingContext = function DescendingContext(state, captureContext) {
  this.state = state;
  this.owner = captureContext.owner;
  this.refs = {};
  this.foreignRefs = {};
  this.elements = captureContext.elements;
  this.pos = 0;
  this.updates = captureContext.components.length;
  this.remaining = this.updates;

  this.$$ = this._createComponent.bind(this);
};

DescendingContext.prototype._createComponent = function _createComponent () {
  var state = this.state;
  var vel = this.elements[this.pos++];
  // only capture VirtualComponent's with a captured parent
  // all others have been captured at this point already
  // or will either be captured by a different owner
  if (!state.isCaptured(vel) && vel._isVirtualComponent &&
       vel.parent && state.isCaptured(vel.parent)) {
    _capture(state, vel);
    this.updates++;
    this.remaining--;
  }
  // Note: we return a new VirtualElement so that the render method does work
  // as expected.
  // TODO: instead of creating a new VirtualElement each time, we could return
  // an immutable wrapper for the already recorded element.
  vel = VirtualElement.createElement.apply(this, arguments);
  // these variables need to be set make the 'ref()' API work
  vel._context = this;
  vel._owner = this.owner;
  // Note: important to deactivate these methods as otherwise the captured
  // element will be damaged when calling el.append()
  vel._attach = function() {};
  vel._detach = function() {};
  return vel;
};

DescendingContext.prototype.hasPendingCaptures = function hasPendingCaptures () {
  return this.updates > 0 && this.remaining > 0;
};

DescendingContext.prototype.reset = function reset () {
  this.pos = 0;
  this.updates = 0;
  this.refs = {};
};

DescendingContext.prototype._ancestorsReady = function _ancestorsReady (vel) {
    var this$1 = this;

  while (vel) {
    if (this$1.state.isCaptured(vel) ||
        // TODO: iron this out
        vel === this$1.owner || vel === this$1.owner._content) {
      return true;
    }
    vel = vel.parent;
  }
  return false;
};

RenderingEngine._internal = {
  _capture: _capture,
  _wrap: _createWrappingVirtualComponent,
};

var CaptureContext = function CaptureContext(owner) {
  this.owner = owner;
  this.refs = {};
  this.foreignRefs = {};
  this.elements = [];
  this.components = [];
  this.$$ = this._createComponent.bind(this);
  this.$$.capturing = true;
};

CaptureContext.prototype._createComponent = function _createComponent () {
  var vel = VirtualElement.createElement.apply(this, arguments);
  vel._context = this;
  vel._owner = this.owner;
  if (vel._isVirtualComponent) {
    // virtual components need to be captured recursively
    this.components.push(vel);
  }
  this.elements.push(vel);
  return vel;
};


function _createWrappingVirtualComponent(comp) {
  var vel = new VirtualElement.Component(comp.constructor);
  vel._comp = comp;
  if (comp.__htmlConfig__) {
    vel._mergeHTMLConfig(comp.__htmlConfig__);
  }
  return vel;
}

RenderingEngine.createContext = function(comp) {
  var vel = _createWrappingVirtualComponent(comp);
  return new CaptureContext(vel);
};


var RenderingState = function RenderingState(elementFactory) {
  this.elementFactory = elementFactory;
  this.poluted = [];
  this.id = "__"+uuid();
};

RenderingState.prototype.dispose = function dispose () {
  var id = this.id;
  this.poluted.forEach(function(obj) {
    delete obj[id];
  });
};

RenderingState.prototype.set = function set (obj, key, val) {
  var info = obj[this.id];
  if (!info) {
    info = {};
    obj[this.id] = info;
    this.poluted.push(obj);
  }
  info[key] = val;
};

RenderingState.prototype.get = function get (obj, key) {
  var info = obj[this.id];
  if (info) {
    return info[key];
  }
};

RenderingState.prototype.setMapped = function setMapped (c) {
  this.set(c, 'mapped', true);
};


RenderingState.prototype.isMapped = function isMapped (c) {
  return Boolean(this.get(c, 'mapped'));
};

RenderingState.prototype.setRelocated = function setRelocated (c) {
  this.set(c, 'relocated', true);
};

RenderingState.prototype.isRelocated = function isRelocated (c) {
  return Boolean(this.get(c, 'relocated'));
};

RenderingState.prototype.setDetached = function setDetached (c) {
  this.set(c, 'detached', true);
};

RenderingState.prototype.isDetached = function isDetached (c) {
  return Boolean(this.get(c, 'detached'));
};

RenderingState.prototype.setCaptured = function setCaptured (vc) {
  this.set(vc, 'captured', true);
};

RenderingState.prototype.isCaptured = function isCaptured (vc) {
  return Boolean(this.get(vc, 'captured'));
};

RenderingState.prototype.setNew = function setNew (vc) {
  this.set(vc, 'created', true);
};

RenderingState.prototype.isNew = function isNew (vc) {
  return Boolean(this.get(vc, 'created'));
};

RenderingState.prototype.setUpdated = function setUpdated (vc) {
  this.set(vc, 'updated', true);
};

RenderingState.prototype.isUpdated = function isUpdated (vc) {
  return Boolean(this.get(vc, 'updated'));
};

RenderingState.prototype.setSkipped = function setSkipped (vc) {
  this.set(vc, 'skipped', true);
};

RenderingState.prototype.isSkipped = function isSkipped (vc) {
  return Boolean(this.get(vc, 'skipped'));
};

RenderingState.prototype.setRendered = function setRendered (vc) {
  this.set(vc, 'rendered', true);
};

RenderingState.prototype.isRendered = function isRendered (vc) {
  return Boolean(this.get(vc, 'rendered'));
};

RenderingState.prototype.setOldProps = function setOldProps (vc, oldProps) {
  this.set(vc, 'oldProps', oldProps);
};

RenderingState.prototype.getOldProps = function getOldProps (vc) {
  return this.get(vc, 'oldProps');
};

RenderingState.prototype.setOldState = function setOldState (vc, oldState) {
  this.set(vc, 'oldState', oldState);
};

RenderingState.prototype.getOldState = function getOldState (vc) {
  return this.get(vc, 'oldState');
};

RenderingEngine.State = RenderingState;

/**
  A light-weight component implementation inspired by
  [React](https://facebook.github.io/react/) and [Ember](http://emberjs.com/).
  In contrast to the large frameworks it does much less things automagically in
  favour of synchronous rendering and a minimalistic life-cycle. It also
  provides *up-tree* communication and *dependency injection*.

  ### Why synchronous rendering?

  Synchronous rendering, while it may *seem* less performant, is necessary
  because substance must render the model, after it has changed before the next
  change is triggered by the user.

  Asynchronous rendering as it exists in React means that the UI will
  eventually *catch* up to changes in the model. This is not acceptable in
  substance because substance plays with contenteditable and thus, cursor
  positions, etc are maintained in the browser's DOM. If we went the async way,
  the cursor in the DOM would be briefly inconsistent with the cursor in the
  model. In this brief window, changes triggered by the user would be impossible
  to apply.

  ### Concepts:

  - `props` are provided by a parent component.  An initial set of properties is provided
  via constructor. After that, the parent component can call `setProps` or `extendProps`
  to update these properties which triggers rerendering if the properties change.

  - `state` is a set of flags and values which are used to control how the component
  gets rendered given the current props. Using `setState` the component can change
  its internal state, which leads to a rerendering if the state changes.
  Prefer using `extendState` rather than `setState`.

    Normally, a component maintains its own state. It isn't recommended that a
  parent pass in or update state. If you find the need for this, you should be
  looking at `props`.

    State would be useful in situations where the component itself controls some
  aspect of rendering. Eg. whether a dropdown is open or not could be a state
  within the dropdown component itself since no other component needs to know
  it.

  - A child component with a `ref` id will be reused on rerender. All others will be
  wiped and rerender from scratch. If you want to preserve a grand-child (or lower), then
  make sure that all anchestors have a ref id. After rendering the child will be
  accessible via `this.refs[ref]`.

  - A component can send actions via `send` which are bubbled up through all parent
  components until one handles it. A component declares that it can handle an
  action by calling the `handleActions` method on itself in the constructor or
  the `didUpdate` lifecycle hook.

  ### Lifecycle hooks

  The {@link RenderingEngine} triggers a set of hooks for you to define behavior
  in various stages of the rendering cycle. The names are pretty self
  explanatory. If in doubt, please check out the method documentation below.

  1. {@link Component#didMount}
  1. {@link Component#didUpdate}
  1. {@link Component#dispose}
  1. {@link Component#willReceiveProps}
  1. {@link Component#willUpdateState}

  @implements EventEmitter

  @example

  Define a component:

  ```
  class HelloMessage extends Component {
    render() {
      return $$('div').append(
        'Hello ',
        this.props.name
      )
    }
  }
  ```

  And mount it to a DOM Element:

  ```
  HelloMessage.mount({name: 'John'}, document.body)
  ```
*/
var Component = (function (EventEmitter$$1) {
  function Component(parent, props, options) {
    if ( props === void 0 ) props = {};
    if ( options === void 0 ) options = {};

    EventEmitter$$1.call(this);

    // TODO: it turned out that the signature is sub-optimal
    // w.r.t. `parent`. Creating a root component allowing for manual dependency injection
    // we could change to `new Component(props, options)`
    // with options `parent` and `context`
    // Also, the parent-child relation could be inconsistent with the actual elements, which should be checked.

    this.parent = (parent && parent._isComponent) ? parent : null;

    // EXPERIMENTAL: used for attaching to existing/pre-rendered element
    this.el = options.el;

    // context from parent (dependency injection) or if given via options
    // the latter is a rather EXPERIMENTAL feature only used
    var context = options.context ? options.context : this._getContext() || {};
    this.context = context;
    Object.freeze(this.context);

    // used for rerendering and can be used by components for incremental rendering
    // Note: usually it is inherited from the parent. In case of root components
    // it can be provided via context or options
    this.renderingEngine = (parent && parent.renderingEngine) || context.renderingEngine || options.renderingEngine || new RenderingEngine();

    // HACK: to allow that ElementComponent and TextComponent can derive from Component
    // we need to skip the initialization of the rest
    if (this._SKIP_COMPONENT_INIT) { return }

    this.__id__ = uuid();

    // store for ref'd child components
    this.refs = {};
    // HACK: a temporary solution to handle refs owned by an ancestor
    // is to store them here as well, so that we can map virtual components
    // efficiently
    this.__foreignRefs__ = {};

    // action handlers added via `handleAction()` are stored here
    this._actionHandlers = {};

    // setting props without triggering willReceiveProps
    this.props = props;
    Object.freeze(this.props);

    // initializing state
    this.state = this.getInitialState() || {};
    Object.freeze(this.state);
  }

  if ( EventEmitter$$1 ) Component.__proto__ = EventEmitter$$1;
  Component.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Component.prototype.constructor = Component;

  var prototypeAccessors = { textContent: {},innerHTML: {},outerHTML: {},childNodes: {} };

  Component.prototype.getId = function getId () {
    return this.__id__
  };

  Component.prototype.setId = function setId () {
    throw new Error("'id' is readonly")
  };

  /**
    Provides the context which is delivered to every child component. Override
    if you want to provide your own child context. Child context is available to
    all components rendered from within this component's render method as
    `this.context`.

    @example

    ```
    class A extends Component {
    ...
      getChildContext() {
        // Optional, but useful to merge super's context
        return Object.assign({}, super.getChildContext(), {foo: 'bar'})
      }

      render($$) {
        return $$(B)
      }
    }

    class B extends Component {
      render($$) {
        // this.context.foo is available here
      }
    }
    ```
    Component

    @return {Object} the child context
  */
  Component.prototype.getChildContext = function getChildContext () {
    return this.childContext || {}
  };

  /**
    Override this within your component to provide the initial state for the
    component. This method is internally called by the
    {@link RenderingEngine} and the state defined here is made available to
    the {@link Component#render} method as this.state.

    @return {Object} the initial state
  */
  Component.prototype.getInitialState = function getInitialState () {
    return {}
  };

  /**
    Provides the parent of this component.

    @return {Component} the parent component or null if this component does not have a parent.
  */
  Component.prototype.getParent = function getParent () {
    return this.parent
  };

  /**
    Get the top-most Component. This the component mounted using
    {@link ui/Component.mount}
    @return {Component} The root component
  */
  Component.prototype.getRoot = function getRoot () {
    var comp = this;
    var parent = comp;
    while (parent) {
      comp = parent;
      parent = comp.getParent();
    }
    return comp
  };

  Component.prototype.getNativeElement = function getNativeElement () {
    return this.el.getNativeElement()
  };

  /**
    Short hand for using labelProvider API

    @example

    ```
    render($$) {
      let el = $$('div').addClass('sc-my-component')
      el.append(this.getLabel('first-name'))
      return el
    }
    ```
  */
  Component.prototype.getLabel = function getLabel (name) {
    var labelProvider = this.context.labelProvider;
    if (!labelProvider) { throw new Error('Missing labelProvider.') }
    return labelProvider.getLabel(name)
  };

  /**
    Get a component class for the component name provided. Use this within the
    render method to render children nodes.

    @example

    ```
    render($$) {
      let el = $$('div').addClass('sc-my-component')
      let caption = this.props.node.getCaption() // some method that returns a node
      let CaptionClass = this.getComponent(caption.type)
      el.append($$(CaptionClass, {node: caption}))
      return el
    }
    ```

    @param  {String} componentName The component's registration name
    @param  {Boolean} maybe if `true` then does not throw when no Component is found
    @return {Class}                The ComponentClass
  */
  Component.prototype.getComponent = function getComponent (componentName, maybe) {
    var componentRegistry = this.getComponentRegistry();
    if (!componentRegistry) { throw new Error('Missing componentRegistry.') }
    var ComponentClass = componentRegistry.get(componentName);
    if (!maybe && !ComponentClass) {
      throw new Error('No Component registered with name ' + componentName)
    }
    return ComponentClass
  };

  Component.prototype.getComponentRegistry = function getComponentRegistry () {
    return this.props.componentRegistry || this.context.componentRegistry
  };

  Component.prototype.getFlow = function getFlow () {
    return this.context.flow
  };

  /**
    Render the component.

    ATTENTION: this does not create a DOM presentation but
    a virtual representation which is compiled into a DOM element later.

    Every Component should override this method.

    @param {Function} $$ method to create components
    @return {VirtualElement} VirtualElement created using {@param $$}
  */
  Component.prototype.render = function render ($$) {
    /* istanbul ignore next */
    return $$('div')
  };

  /**
    Mount a component to the DOM.

    @example

    ```
    var app = Texture.mount({
      configurator: configurator,
      documentId: 'elife-15278'
    }, document.body)
    ```
  */
  Component.prototype.mount = function mount (el) {
    if (!el) {
      throw new Error('Element is required.')
    }
    if (!el._isDOMElement) {
      el = DefaultDOMElement.wrapNativeElement(el);
    }
    // this makes this component a root component
    this.parent = null;
    this.el = null;
    this.renderingEngine = new RenderingEngine({ elementFactory: el.getOwnerDocument() });
    this._render();
    el.appendChild(this.el);
    if (el.isInDocument()) {
      this.triggerDidMount(true);
    }
    return this
  };

  /**
    Determines if Component should be rendered again using {@link ui/Component#rerender}
    after changing props. For comparisons, you can use `this.props` and
    `newProps`.

    The default implementation simply returns true.

    @param {Object} newProps The new props being applied to this component.
    @param {Object} newState The new state being applied
    @return a boolean indicating whether rerender() should be run.
  */
  Component.prototype.shouldRerender = function shouldRerender (newProps, newState) { // eslint-disable-line
    return true
  };

  /**
    Rerenders the component.

    Call this to manually trigger a rerender.
  */
  Component.prototype.rerender = function rerender () {
    this._rerender(this.props, this.state);
  };

  Component.prototype._rerender = function _rerender (oldProps, oldState) {
    this._render(oldProps, oldState);
    // when this component is not mounted still trigger didUpdate()
    if (!this.isMounted()) {
      this.didUpdate(oldProps, oldState);
    }
  };

  Component.prototype._render = function _render (oldProps, oldState) {
    if (this.__isRendering__) {
      throw new Error('Component is rendering already.')
    }
    this.__isRendering__ = true;
    try {
      this.renderingEngine._render(this, oldProps, oldState);
    } finally {
      delete this.__isRendering__;
    }
  };

  /**
    Triggers didMount handlers recursively.

    Gets called when using `component.mount(el)` on an element being
    in the DOM already. Typically this is done for a root component.

    If this is not possible because you want to do things differently, make sure
    you call 'component.triggerDidMount()' on root components.

    @param isMounted an optional param for optimization, it's used mainly internally
    @private
    @example

    ```
    var frag = document.createDocumentFragment()
    var comp = MyComponent.mount(frag)
    ...
    $('body').append(frag)
    comp.triggerDidMount()
    ```
  */
  Component.prototype.triggerDidMount = function triggerDidMount () {
    // Trigger didMount for the children first
    this.getChildren().forEach(function(child) {
      // We pass isMounted=true to save costly calls to Component.isMounted
      // for each child / grandchild
      child.triggerDidMount(true);
    });
    // To prevent from multiple calls to didMount, which can happen under
    // specific circumstances we use a guard.
    if (!this.__isMounted__) {
      this.__isMounted__ = true;
      this.didMount();
    }
  };

  /**
    Called when the element is inserted into the DOM. Typically, you can use
    this to set up subscriptions to changes in the document or in a node of
    your interest.

    Remember to unsubscribe from all changes in the {@link ui/Component#dispose}
    method otherwise listeners you have attached may be called without a context.

    @example

    ```javascript
    class Foo extends Component {
      didMount() {
        this.context.editorSession.onRender('document', this.rerender, this, {
          path: [this.props.node.id, 'label']
        })
      }

      dispose() {
        this.context.editorSession.off(this)
      }
    }
    ```

    Make sure that you call `component.mount(el)` using an element
    which is already in the DOM.

    ```javascript
    var component = new MyComponent()
    component.mount($('body')[0])
    ```
  */
  Component.prototype.didMount = function didMount () {};

  /**
    Hook which is called after state or props have been updated and the implied
    rerender is completed.
  */
  Component.prototype.didUpdate = function didUpdate () {};

  /**
    @return {boolean} indicating if this component has been mounted
   */
  Component.prototype.isMounted = function isMounted () {
    return this.__isMounted__
  };

  /**
   Triggers dispose handlers recursively.

   @private
  */
  Component.prototype.triggerDispose = function triggerDispose () {
    this.getChildren().forEach(function(child) {
      child.triggerDispose();
    });
    this.dispose();
    this.__isMounted__ = false;
  };

  /**
    A hook which is called when the component is unmounted, i.e. removed from DOM,
    hence disposed. See {@link ui/Component#didMount} for example usage.

    Remember to unsubscribe all change listeners here.
  */
  Component.prototype.dispose = function dispose () {};

  /*
    Attention: this is used when a preserved component is relocated.
    E.g., rendered with a new parent.
  */
  Component.prototype._setParent = function _setParent (newParent) {
    this.parent = newParent;
    this.context = this._getContext() || {};
    Object.freeze(this.context);
  };

  /**
    Send an action request to the parent component, bubbling up the component
    hierarchy until an action handler is found.

    @param action the name of the action
    @param ... arbitrary number of arguments
    @returns {Boolean} true if the action was handled, false otherwise
    @example
  */
  Component.prototype.send = function send (action) {
    var arguments$1 = arguments;

    var comp = this;
    while(comp) {
      if (comp._actionHandlers && comp._actionHandlers[action]) {
        comp._actionHandlers[action].apply(comp, Array.prototype.slice.call(arguments$1, 1));
        return true
      }
      comp = comp.getParent();
    }
    console.warn('Action', action, 'was not handled.');
    return false
  };

  /**
    Define action handlers. Call this during construction/initialization of a component.
    @param {Object} actionHandler  An object where the keys define the handled
        actions and the values define the handler to be invoked.

    These handlers are automatically removed once the Component is disposed, so
    there is no need to unsubscribe these handlers in the {@link ui/Component#dispose}
    hook.

    @example

    ```
    class MyComponent extends Component {
      constructor(...args) {
        super(...args)
        this.handleActions({
         'openPrompt': this.openPrompt,
         'closePrompt': this.closePrompt
        })
      }
    }
    ```
  */
  Component.prototype.handleActions = function handleActions (actionHandlers) {
    forEach(actionHandlers, function(method, actionName) {
      this.handleAction(actionName, method);
    }.bind(this));
    return this
  };

  /**
    Define an action handler. Call this during construction/initialization of a component.

    @param {String} action name
    @param {Functon} a function of this component.
  */
  Component.prototype.handleAction = function handleAction (name, handler) {
    if (!name || !handler || !isFunction$2(handler)) {
      throw new Error('Illegal arguments.')
    }
    handler = handler.bind(this);
    this._actionHandlers[name] = handler;
  };

  /**
    Get the current component state

    @return {Object} the current state
  */
  Component.prototype.getState = function getState () {
    return this.state
  };

  /**
    Sets the state of this component, potentially leading to a rerender. It is
    better practice to use {@link ui/Component#extendState}. That way, the code
    which updates state only updates part relevant to it.

    Eg. If you have a Component that has a dropdown open state flag and another
    enabled/disabled state flag for a node in the dropdown, you want to isolate
    the pieces of your code making the two changes. The part of your code
    opening and closing the dropdown should not also automatically change or
    remove the enabled flag.

    Note: Usually this is used by the component itself.
    @param {object} newState an object with a partial update.
  */
  Component.prototype.setState = function setState (newState) {
    var oldProps = this.props;
    var oldState = this.state;
    // Note: while setting props it is allowed to call this.setState()
    // which will not lead to an extra rerender
    var needRerender = !this.__isSettingProps__ &&
      this.shouldRerender(this.getProps(), newState);
    // triggering this to provide a possibility to look at old before it is changed
    this.willUpdateState(newState);
    this.state = newState || {};
    Object.freeze(this.state);
    if (needRerender) {
      this._rerender(oldProps, oldState);
    } else if (!this.__isSettingProps__) {
      this.didUpdate(oldProps, oldState);
    }
  };

  /**
    This is similar to `setState()` but extends the existing state instead of
    replacing it.

    @param {object} newState an object with a partial update.
  */
  Component.prototype.extendState = function extendState (newState) {
    newState = extend({}, this.state, newState);
    this.setState(newState);
  };

  /**
    Called before state is changed.
  */
  Component.prototype.willUpdateState = function willUpdateState (newState) { // eslint-disable-line
  };

  /**
    Get the current properties

    @return {Object} the current state
  */
  Component.prototype.getProps = function getProps () {
    return this.props
  };

  /**
    Sets the properties of this component, potentially leading to a rerender.

    @param {object} an object with properties
  */
  Component.prototype.setProps = function setProps (newProps) {
    var oldProps = this.props;
    var oldState = this.state;
    var needRerender = this.shouldRerender(newProps, this.state);
    this._setProps(newProps);
    if (needRerender) {
      this._rerender(oldProps, oldState);
    } else {
      this.didUpdate(oldProps, oldState);
    }
  };

  Component.prototype._setProps = function _setProps (newProps) {
    newProps = newProps || {};
    // set a flag so that this.setState() can omit triggering render
    this.__isSettingProps__ = true;
    try {
      this.willReceiveProps(newProps);
      this.props = newProps || {};
      Object.freeze(newProps);
    } finally {
      delete this.__isSettingProps__;
    }
  };

  /**
    Extends the properties of the component, without necessarily leading to a
    rerender.

    @param {object} an object with properties
  */
  Component.prototype.extendProps = function extendProps (updatedProps) {
    var newProps = extend({}, this.props, updatedProps);
    this.setProps(newProps);
  };

  /**
    Hook which is called before properties are updated. Use this to dispose objects which will be replaced when properties change.

    For example you can use this to derive state from props.
    @param {object} newProps
  */
  Component.prototype.willReceiveProps = function willReceiveProps (newProps) { // eslint-disable-line
  };

  Component.prototype.getTextContent = function getTextContent () {
    if (this.el) {
      return this.el.textContent
    }
  };

  prototypeAccessors.textContent.get = function () {
    return this.getTextContent()
  };

  Component.prototype.getInnerHTML = function getInnerHTML () {
    if (this.el) {
      return this.el.getInnerHTML()
    }
  };

  prototypeAccessors.innerHTML.get = function () {
    return this.getInnerHTML()
  };

  Component.prototype.getOuterHTML = function getOuterHTML () {
    if (this.el) {
      return this.el.getOuterHTML()
    }
  };

  prototypeAccessors.outerHTML.get = function () {
    return this.getOuterHTML()
  };

  Component.prototype.getAttribute = function getAttribute (name) {
    if (this.el) {
      return this.el.getAttribute(name)
    }
  };

  Component.prototype.setAttribute = function setAttribute (name, val) {
    if (this.el) {
      this.el.setAttribute(name, val);
    }
    return this
  };

  Component.prototype.getProperty = function getProperty (name) {
    if (this.el) {
      return this.el.getProperty(name)
    }
  };

  Component.prototype.setProperty = function setProperty (name, val) {
    if (this.el) {
      this.el.setProperty(name, val);
    }
    return this
  };

  Component.prototype.hasClass = function hasClass (name) {
    if (this.el) {
      return this.el.hasClass(name)
    }
  };

  Component.prototype.addClass = function addClass (name) {
    if (this.el) {
      this.el.addClass(name);
    }
    return this
  };

  Component.prototype.removeClass = function removeClass (name) {
    if (this.el) {
      this.el.removeClass(name);
    }
    return this
  };

  Component.prototype.getStyle = function getStyle (name) {
    if (this.el) {
      return this.el.getStyle(name)
    }
  };

  Component.prototype.setStyle = function setStyle (name, val) {
    if (this.el) {
      return this.el.setStyle(name, val)
    }
    return this
  };

  Component.prototype.getValue = function getValue () {
    if (this.el) {
      return this.el.getValue()
    }
  };

  Component.prototype.setValue = function setValue (val) {
    if (this.el) {
      this.el.setValue(val);
    }
    return this
  };

  Component.prototype.getChildCount = function getChildCount () {
    if (!this.el) { return 0 }
    return this.el.getChildCount()
  };

  prototypeAccessors.childNodes.get = function () {
    return this.getChildNodes()
  };

  Component.prototype.getChildNodes = function getChildNodes () {
    if (!this.el) { return [] }
    var childNodes = this.el.getChildNodes();
    childNodes = childNodes.map(_unwrapComp).filter(Boolean);
    return childNodes
  };

  Component.prototype.getChildren = function getChildren () {
    if (!this.el) { return [] }
    var children = this.el.getChildren();
    children = children.map(_unwrapComp).filter(Boolean);
    return children
  };

  Component.prototype.getChildAt = function getChildAt (pos) {
    var node = this.el.getChildAt(pos);
    return _unwrapCompStrict(node)
  };

  Component.prototype.find = function find (cssSelector) {
    var el = this.el.find(cssSelector);
    return _unwrapComp(el)
  };

  Component.prototype.findAll = function findAll (cssSelector) {
    var els = this.el.findAll(cssSelector);
    return els.map(_unwrapComp).filter(Boolean)
  };

  Component.prototype.appendChild = function appendChild (child) {
    this.insertAt(this.getChildCount(), child);
  };

  Component.prototype.insertAt = function insertAt (pos, childEl) {
    if (isString(childEl)) {
      childEl = new VirtualElement.TextNode(childEl);
    }
    if (!childEl._isVirtualElement) {
      throw new Error('Invalid argument: "child" must be a VirtualElement.')
    }
    var child = this.renderingEngine._renderChild(this, childEl);
    this.el.insertAt(pos, child.el);
    _mountChild(this, child);
  };

  Component.prototype.removeAt = function removeAt (pos) {
    var childEl = this.el.getChildAt(pos);
    if (childEl) {
      var child = _unwrapCompStrict(childEl);
      _disposeChild(child);
      this.el.removeAt(pos);
    }
  };

  Component.prototype.removeChild = function removeChild (child) {
    if (!child || !child._isComponent) {
      throw new Error('removeChild(): Illegal arguments. Expecting a Component instance.')
    }
    // TODO: remove ref from owner
    _disposeChild(child);
    this.el.removeChild(child.el);
  };

  Component.prototype.replaceChild = function replaceChild (oldChild, newChild) {
    if (!newChild || !oldChild ||
        !newChild._isComponent || !oldChild._isComponent) {
      throw new Error('replaceChild(): Illegal arguments. Expecting BrowserDOMElement instances.')
    }
    // Attention: Node.replaceChild has weird semantics
    _disposeChild(oldChild);
    this.el.replaceChild(newChild.el, oldChild.el);
    if (this.isMounted()) {
      newChild.triggerDidMount(true);
    }
  };

  Component.prototype.empty = function empty () {
    if (this.el) {
      this.getChildNodes().forEach(function(child) {
        _disposeChild(child);
      });
      this.el.empty();
    }
    return this
  };

  Component.prototype.remove = function remove () {
    _disposeChild(this);
    this.el.remove();
  };

  Component.prototype.addEventListener = function addEventListener () {
    throw new Error("Not supported.")
  };

  Component.prototype.removeEventListener = function removeEventListener () {
    throw new Error("Not supported.")
  };

  Component.prototype.insertBefore = function insertBefore () {
    throw new Error("Not supported.")
  };

  Component.prototype.click = function click () {
    if (this.el) {
      this.el.click();
    }
  };

  Component.prototype.getComponentPath = function getComponentPath () {
    var path = [];
    var comp = this;
    while (comp) {
      path.unshift(comp);
      comp = comp.getParent();
    }
    return path
  };

  Component.prototype._getContext = function _getContext () {
    var context = {};
    var parent = this.getParent();
    if (parent) {
      context = extend(context, parent.context);
      if (parent.getChildContext) {
        return extend(context, parent.getChildContext())
      }
    }
    return context
  };

  Object.defineProperties( Component.prototype, prototypeAccessors );

  return Component;
}(EventEmitter));

Component.prototype._isComponent = true;

Component.prototype.attr = DOMElement.prototype.attr;

Component.prototype.htmlProp = DOMElement.prototype.htmlProp;

Component.prototype.val = DOMElement.prototype.val;

Component.prototype.css = DOMElement.prototype.css;

Component.prototype.text = DOMElement.prototype.text;

Component.prototype.append = DOMElement.prototype.append;

Component.unwrap = _unwrapComp;

Component.render = function(props) {
  props = props || {};
  var ComponentClass = this;
  var comp = new ComponentClass(null, props);
  comp._render();
  return comp
};

Component.mount = function(props, el) {
  if (arguments.length === 1) {
    el = props;
    props = {};
  }
  if (!el) { throw new Error("'el' is required.") }
  if (isString(el)) {
    var selector = el;
    if (inBrowser) {
      el = window.document.querySelector(selector);
    } else {
      throw new Error("This selector is not supported on server side.")
    }
  }
  if (!el._isDOMElement) {
    el = new DefaultDOMElement.wrapNativeElement(el);
  }
  var ComponentClass = this;
  var comp = new ComponentClass(null, props);
  comp.mount(el);
  return comp
};

Component.getComponentForDOMElement = function(el) {
  return _unwrapComp(el)
};

Component.unwrapDOMElement = function(el) {
  console.warn('DEPRECATED: Use Component.getComponentForDOMElement');
  return Component.getComponentForDOMElement(el)
};

Component.getComponentFromNativeElement = function(nativeEl) {
  // while it sounds strange to wrap a native element
  // first, it makes sense after all, as DefaultDOMElement.wrapNativeElement()
  // provides the DOMElement instance of a previously wrapped native element.
  return _unwrapComp(DefaultDOMElement.wrapNativeElement(nativeEl))
};

// NOTE: this is used for incremental updates only
function _disposeChild(child) {
  child.triggerDispose();
  if (child._owner && child._ref) {
    console.assert(child._owner.refs[child._ref] === child, "Owner's ref should point to this child instance.");
    delete child._owner.refs[child._ref];
  }
}

// NOTE: this is used for incremental updates only
function _mountChild(parent, child) {
  if (parent.isMounted()) {
    child.triggerDidMount(true);
  }
  if (child._owner && child._ref) {
    child._owner.refs[child._ref] = child;
  }
}

// NOTE: we keep a reference to the component in all DOMElement instances
function _unwrapComp(el) {
  if (el) {
    if (!el._isDOMElement) { el = el._wrapper; }
    if (el) { return el._comp }
  }
}

function _unwrapCompStrict(el) {
  var comp = _unwrapComp(el);
  if (!comp) { throw new Error("Expecting a back-link to the component instance.") }
  return comp
}


var ElementComponent = (function (Component) {
  function ElementComponent(parent) {
    Component.call(this, parent);
  }

  if ( Component ) ElementComponent.__proto__ = Component;
  ElementComponent.prototype = Object.create( Component && Component.prototype );
  ElementComponent.prototype.constructor = ElementComponent;

  return ElementComponent;
}(Component));

ElementComponent.prototype._isElementComponent = true;
ElementComponent.prototype._SKIP_COMPONENT_INIT = true;

var TextNodeComponent = (function (Component) {
  function TextNodeComponent(parent) {
    Component.call(this, parent);
  }

  if ( Component ) TextNodeComponent.__proto__ = Component;
  TextNodeComponent.prototype = Object.create( Component && Component.prototype );
  TextNodeComponent.prototype.constructor = TextNodeComponent;

  TextNodeComponent.prototype.setTextContent = function setTextContent (text) {
    if (!this.el) {
      throw new Error('Component must be rendered first.')
    }
    if (this.el.textContent !== text) {
      this.el.textContent = text;
    }
  };

  TextNodeComponent.prototype.getChildNodes = function getChildNodes () {
    return []
  };

  TextNodeComponent.prototype.getChildren = function getChildren () {
    return []
  };

  return TextNodeComponent;
}(Component));

TextNodeComponent.prototype._isTextNodeComponent = true;
TextNodeComponent.prototype._SKIP_COMPONENT_INIT = true;


Component.Element = ElementComponent;
Component.TextNode = TextNodeComponent;

var DragAndDropHandler = function DragAndDropHandler () {};

var prototypeAccessors$6 = { _isDragAndDropHandler: {} };

DragAndDropHandler.prototype.match = function match (dragState, context) { // eslint-disable-line
  return false
};

DragAndDropHandler.prototype.drop = function drop (dragState, context) { // eslint-disable-line
  // nothing
};

prototypeAccessors$6._isDragAndDropHandler.get = function () {
  return true
};

Object.defineProperties( DragAndDropHandler.prototype, prototypeAccessors$6 );

/**
  @module

  Platform utilities such as browser detection etc.

  @example

  ```js
  import platform from 'substance/util/platform'
  ```
*/
var platform = {

  inBrowser: inBrowser,

  /**
    True if user agent is Internet Explorer or Microsoft Edge.
  */
  isIE: false,
  /**
    True if user agent is Firefox
  */

  isFF: false,

  isWebkit: false,

  /*
    Major version

    ATTENTION: at the moment only extracted for IE
  */
  version: -1,

  // TODO: make sure that this is implemented correctly

  isWindows: (inBrowser && window.navigator !== undefined && window.navigator.appVersion && window.navigator.appVersion.indexOf("Win") !== -1),

  isMac: (inBrowser && window.navigator !== undefined && window.navigator.platform.indexOf('Mac') >= 0)

};

if (typeof window !== 'undefined') {
  // Detect Internet Explorer / Edge
  var ua = window.navigator.userAgent;
  var msie = ua.indexOf('MSIE ');
  var trident = ua.indexOf('Trident/');
  var edge = ua.indexOf('Edge/');

  if (msie > 0) {
    // IE 10 or older => return version number
    platform.isIE = true;
    platform.version = 10;
    // TODO: if we need someday, this would be the exact version number
    // parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10)
  } else if (trident > 0) {
    // IE 11 => return version number
    platform.isIE = true;
    platform.version = 11;
    platform.isTrident = true;
    // TODO: if we need someday, this would be the exact version number
    // var rv = ua.indexOf('rv:')
    // parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10)
  } else if (edge > 0) {
    // IE 12 => return version number
    platform.isIE = true;
    platform.isEdge = true;
    platform.version = 12;
    // TODO: if we need someday, this would be the exact version number
    parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
  }

  // Detect Firefox
  platform.isFF = window.navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

  // TODO: explicit detection of Webkit&/Blink
  platform.isWebkit = !platform.isFF && !platform.isIE;
}

function getDOMRangeFromEvent(evt) {
  var range, x = evt.clientX, y = evt.clientY;
  // Try the simple IE way first
  if (document.body.createTextRange) {
    range = document.body.createTextRange();
    range.moveToPoint(x, y);
  }
  else if (!isNil(document.createRange)) {
    // Try Mozilla's rangeOffset and rangeParent properties,
    // which are exactly what we want
    if (!isNil(evt.rangeParent)) {
      range = document.createRange();
      range.setStart(evt.rangeParent, evt.rangeOffset);
      range.collapse(true);
    }
    // Try the standards-based way next
    else if (document.caretPositionFromPoint) {
      var pos = document.caretPositionFromPoint(x, y);
      range = document.createRange();
      range.setStart(pos.offsetNode, pos.offset);
      range.collapse(true);
    }
    // Next, the WebKit way
    else if (document.caretRangeFromPoint) {
      range = document.caretRangeFromPoint(x, y);
    }
  }
  return range
}

/*
  Get selection rectangle relative to panel content element
*/
function getSelectionRect(parentRect) {
  if (inBrowser) {
    var wsel = window.getSelection();
    if (wsel.rangeCount === 0) { return }
    var wrange = wsel.getRangeAt(0);
    var contentRect = parentRect;
    var selectionRect = wrange.getBoundingClientRect();
    if (selectionRect.top === 0 && selectionRect.bottom === 0) {
      selectionRect = _fixForCursorRectBug();
    }
    return getRelativeRect(contentRect, selectionRect)
  }
}

function _fixForCursorRectBug() {
  var wsel = window.getSelection();
  var rects = wsel.anchorNode.parentElement.getClientRects();
  return rects[0]
}

function getRelativeRect(parentRect, childRect) {
  var left = childRect.left - parentRect.left;
  var top = childRect.top - parentRect.top;
  return {
    left: left,
    top: top,
    right: parentRect.width - left - childRect.width,
    bottom: parentRect.height - top - childRect.height,
    width: childRect.width,
    height: childRect.height
  }
}

function isMouseInsideDOMSelection(e) {
  var wsel = window.getSelection();
  if (wsel.rangeCount === 0) {
    return false
  }
  var wrange = wsel.getRangeAt(0);
  var selectionRect = wrange.getBoundingClientRect();
  return e.clientX >= selectionRect.left &&
         e.clientX <= selectionRect.right &&
         e.clientY >= selectionRect.top &&
         e.clientY <= selectionRect.bottom
}

var DragManager = (function (EventEmitter$$1) {
  function DragManager(customDropHandlers, context) {
    EventEmitter$$1.call(this);

    this.context = context;

    var dropAssetHandlers = [];
    var moveInlineHandlers = [];
    customDropHandlers.forEach(function (h) {
      // legacy: default type = 'asset'
      var type = h.type || 'drop-asset';
      switch (type) {
        case 'drop-asset': {
          dropAssetHandlers.push(h);
          break
        }
        case 'move-inline': {
          moveInlineHandlers.push(h);
          break
        }
        default:
          console.warn('Unknown type of drop handler.', h);
      }
    });

    // TODO: This could live in the configurator at some point
    this.dropHandlers = [
      // source is a PropertySelection, target is a property
      new MoveInline(moveInlineHandlers),
      // source is a NodeSelection, target is a container position
      new MoveBlockNode(),
      // drop external files
      new InsertNodes(dropAssetHandlers, this.context),
      // dynamic custom handler, activated via custom dropzone
      // not via configuration
      new CustomHandler() ];
    if (inBrowser) {
      this.el = DefaultDOMElement.wrapNativeElement(document);
      this.el.on('dragstart', this.onDragStart, this);
      // this.el.on('dragend', this.onDragEnd, this)
      this.el.on('drop', this.onDragEnd, this);
      this.el.on('dragenter', this.onDragEnter, this);
      this.el.on('dragexit', this.onDragExit, this);
      this.el.on('mousedown', this.onMousedown, this);
    }
  }

  if ( EventEmitter$$1 ) DragManager.__proto__ = EventEmitter$$1;
  DragManager.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  DragManager.prototype.constructor = DragManager;

  DragManager.prototype.dispose = function dispose () {
    if (this.el) {
      this.el.off(this);
    }
  };

  DragManager.prototype.onDragStart = function onDragStart (e) {
    // console.log('#### DragManager.onDragStart')
    this._initDrag(e, { external: false });
    // Ensure we have a small dragIcon, so dragged content does not eat up
    // all screen space.
    var img = document.createElement("img");
    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    e.dataTransfer.setDragImage(img, 0, 0);
    // TODO: the following might probably not work in FF as it disallows setting the drag data
    // Note: setData('text/html', ... ) is necessary so that the browser shows
    // the target caret while dragging, the content must be allowed to drop inline
    // console.log('#### dragState.mode', )
    // TODO: at this point we should do it similar as in Clipboard
    // i.e. copy the selection and export it to HTML
    if (this.dragState.mode === 'inline') {
      e.dataTransfer.setData('text/html', img.outerHTML);
    } else {
      // otherwise we clear the data trying to make the caret
      // invisible this way
      e.dataTransfer.setData('text/html', '<div></div>');
    }
    // console.log('####', this.dragState)
  };

  /*
    When drag starts externally, e.g. draggin a file into the workspace
  */
  DragManager.prototype.onDragEnter = function onDragEnter (e) {
    if (!this.dragState) {
      // console.log('onDragEnter(e)', e)
      this._initDrag(e, {external: true});
    }
  };

  DragManager.prototype.onDragEnd = function onDragEnd (event) {
    if (event.__reserved__) { return }
    // console.log('onDragEnd', event)
    if (this.dragState) {
      event.stopPropagation();
      event.preventDefault();
      // HACK: there is no way to know if Dropzones wants to
      // extend state, as it can only do it on drop
      this._onDragEnd(event);
    }
  };

  DragManager.prototype.onDragExit = function onDragExit (e) {
    if (platform.isFF) {
      // FF fires this quite rapidly
    } else {
      // TODO: OTOH, we need to find out if this
      // is really necessary in the other browsers
      // console.log('onDragExit', e)
      this._onDragEnd(e);
    }
  };

  DragManager.prototype.extendDragState = function extendDragState (extState) {
    Object.assign(this.dragState, extState);
  };

  // used to at least reset on the next mousedown
  // TODO: figure out if we could make this only 'once'
  DragManager.prototype.onMousedown = function onMousedown (event) {
    if (this.dragState) {
      this.dragState = null;
      this._onDragEnd(event);
    }
  };

  DragManager.prototype._onDragEnd = function _onDragEnd (event) {
    if (!this.dragState) {
      // TODO: There are cases where _onDragEnd is called manually via
      // handleDrop and another time via the native dragend event. check
      // why this happens and how it can be avoided
      console.warn('Not in a valid drag state.');
    } else {
      this._handleDrop(event);
    }
    this.emit('drag:finished');
    this.dragState = null;
  };

  /*
    Called by Dropzones component after drop received
  */
  DragManager.prototype._handleDrop = function _handleDrop (e) {
    var this$1 = this;

    var dragState = this.dragState;
    var i, handler;
    var match = false;
    dragState.event = e;
    dragState.data = this._getData(e);
    // Run through drop handlers and call the first that matches
    for (i = 0; i < this.dropHandlers.length && !match; i++) {
      handler = this$1.dropHandlers[i];
      match = handler.match(dragState);
    }
    if (match) {
      var editorSession = this.context.editorSession;
      editorSession.transaction(function (tx) {
        handler.drop(tx, dragState);
      });
    } else {
      console.error('No drop handler could be found.');
    }
  };

  /*
    Initializes dragState, which encapsulate state through the whole
    drag + drop operation.

    ATTENTION: This can not be debugged properly in Chrome
  */
  DragManager.prototype._initDrag = function _initDrag (event, options) {
    // TODO: we need to figure out how to enable dragging cursors
    // e.g., when dragging an inline node containing an img, it looks
    // nice, showing the target caret and a dragging cursor.
    // Doing the same just with text content does show the forbidden symbol

    // console.log('_initDrag')
    var sel = this._getSelection();
    var dragState = Object.assign({ startEvent: event }, options);
    this.dragState = dragState;

    // external drag
    // Note: we only consider drops on the block-level or with custom dropzones
    if (dragState.external) {
      dragState.selectionDrag = false;
      dragState.sourceSelection = null;
      dragState.scrollPanes = this._getSurfacesGroupedByScrollPane();
      this.emit('drag:started', dragState);
      return
    }

    // Note: selection drags are always without drop-zones,
    // but using the native cursor
    var isSelectionDrag = (
      (sel.isPropertySelection() || sel.isContainerSelection()) &&
      isMouseInsideDOMSelection(event)
    );
    if (isSelectionDrag) {
      // TODO: we do not support dragging of ContainerSelection yet
      if (sel.isContainerSelection()) {
        console.warn('Dragging of ContainerSelection is not supported yet.');
        return _stop()
      }
      // console.log('DragManager: starting a selection drag', sel.toString())
      dragState.inline = true;
      dragState.selectionDrag = true;
      dragState.sourceSelection = sel;
      // TODO: should we emit for dropzones?
      return
    }
    var comp = Component.unwrap(event.target);
    if (!comp) { return _stop() }
    var isolatedNodeComponent;
    if (comp._isInlineNodeComponent) {
      isolatedNodeComponent = comp;
      dragState.inline = true;
      dragState.sourceNode = comp.props.node;
    } else {
      isolatedNodeComponent = comp.context.isolatedNodeComponent;
    }
    if (!isolatedNodeComponent) { return _stop() }
    var surface = isolatedNodeComponent.context.surface;
    // dragging an InlineNode
    if(isolatedNodeComponent._isInlineNodeComponent) {
      var inlineNode = isolatedNodeComponent.props.node;
      dragState.inline = true;
      dragState.selectionDrag = true;
      dragState.sourceSelection = {
        type: 'property',
        path: inlineNode.start.path,
        startOffset: inlineNode.start.offset,
        endOffset: inlineNode.end.offset,
        containerId: surface.getContainerId(),
        surfaceId: surface.id
      };
      return
    }
    // dragging an IsolatedNode
    // console.log('DragManager: started dragging a node or from external')
    dragState.selectionDrag = false;
    dragState.nodeDrag = true;
    dragState.sourceSelection = {
      type: 'node',
      nodeId: isolatedNodeComponent.props.node.id,
      containerId: surface.getContainerId(),
      surfaceId: surface.id
    };
    // We store the scrollPanes in dragState so the Dropzones component
    // can use it to compute dropzones per scrollpane for each contained
    // surface
    dragState.scrollPanes = this._getSurfacesGroupedByScrollPane();
    // console.log('... emitting dragstart for Dropzones')
    this.emit('drag:started', dragState);

    function _stop() {
      // console.log('.... NOPE')
      event.preventDefault();
      event.stopPropagation();
    }
  };

  DragManager.prototype._getSurfacesGroupedByScrollPane = function _getSurfacesGroupedByScrollPane () {
    // We need to determine all ContainerEditors and their scrollPanes; those have the drop
    // zones attached
    var surfaces = this.context.surfaceManager.getSurfaces();
    var scrollPanes = {};
    surfaces.forEach(function (surface) {
      // Skip for everything but container editors
      if (!surface.isContainerEditor()) { return }
      var scrollPane = surface.context.scrollPane;
      var scrollPaneName = scrollPane.getName();
      var surfaceName = surface.getName();
      if (!scrollPanes[scrollPaneName]) {
        var surfaces = {};
        surfaces[surfaceName] = surface;
        scrollPanes[scrollPaneName] = { scrollPane: scrollPane, surfaces: surfaces };
      } else {
        scrollPanes[scrollPaneName].surfaces[surfaceName] = surface;
      }
    });
    return scrollPanes
  };

  DragManager.prototype._getSelection = function _getSelection () {
    return this.context.editorSession.getSelection()
  };

  DragManager.prototype._getComponents = function _getComponents (targetEl) {
    var res = [];
    var curr = targetEl;
    while (curr) {
      var comp = Component.getComponentForDOMElement(curr);
      if (comp) {
        res.unshift(comp);
        if(comp._isSurface) {
          return res
        }
      }
      curr = curr.parentNode;
    }
    return null
  };

  DragManager.prototype._getIsolatedNodeOrContainerChild = function _getIsolatedNodeOrContainerChild (targetEl) {
    var parent, current;
    current = targetEl;
    parent = current.parentNode;
    while(parent) {
      if (parent._comp && parent._comp._isContainerEditor) {
        return current._comp
      } else if (current._comp && current._comp._isIsolatedNode) {
        return current._comp
      }
      current = parent;
      parent = current.parentNode;
    }
  };

  /*
    Following best practice from Mozilla for URI extraction

    See: https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Recommended_Drag_Types#link
  */
  DragManager.prototype._extractUris = function _extractUris (dataTransfer) {
    var uris = [];
    var rawUriList = dataTransfer.getData('text/uri-list');
    if (rawUriList) {
      uris = rawUriList.split('\n').filter(function(item) {
        return !item.startsWith('#')
      });
    }
    return uris
  };

  /*
    Extracts information from e.dataTransfer (files, uris, text, html)
  */
  DragManager.prototype._getData = function _getData (e) {
    var dataTransfer = e.dataTransfer;
    if (dataTransfer) {
      return {
        files: Array.prototype.slice.call(dataTransfer.files),
        uris: this._extractUris(dataTransfer),
        text: dataTransfer.getData('text/plain'),
        html: dataTransfer.getData('text/html')
      }
    }
  };

  return DragManager;
}(EventEmitter));

/*
  Moves a selected node to a new location.

  Used as a drop handler for internal drags with NodeSelections.
*/
var MoveBlockNode = (function (DragAndDropHandler$$1) {
  function MoveBlockNode () {
    DragAndDropHandler$$1.apply(this, arguments);
  }

  if ( DragAndDropHandler$$1 ) MoveBlockNode.__proto__ = DragAndDropHandler$$1;
  MoveBlockNode.prototype = Object.create( DragAndDropHandler$$1 && DragAndDropHandler$$1.prototype );
  MoveBlockNode.prototype.constructor = MoveBlockNode;

  MoveBlockNode.prototype.match = function match (dragState) {
    var ref = dragState.dropParams;
    var insertPos = ref.insertPos;
    // - sourceSeletion must be a NodeSelection
    return (!dragState.external && dragState.nodeDrag &&
      dragState.dropType === 'place' && insertPos >= 0
    )
  };

  MoveBlockNode.prototype.drop = function drop (tx, dragState) {
    // - remember current selection (node that is dragged)
    // - delete current selection (removes node from original position)
    // - determine node selection based on given insertPos
    // - paste node at new insert position
    var ref = dragState.dropParams;
    var insertPos = ref.insertPos;
    tx.setSelection(dragState.sourceSelection);
    var copy = tx.copySelection();
    // just clear, but don't merge or don't insert a new node
    tx.deleteSelection({ clear: true });
    var containerId = dragState.targetSurface.getContainerId();
    var surfaceId = dragState.targetSurface.getName();
    var container = tx.get(containerId);
    var targetNode = container.nodes[insertPos];
    var insertMode = 'before';
    if (!targetNode) {
      targetNode = container.nodes[insertPos-1];
      insertMode = 'after';
    }
    tx.setSelection({
      type: 'node',
      nodeId: targetNode,
      mode: insertMode,
      containerId: containerId,
      surfaceId: surfaceId
    });
    tx.paste(copy);
  };

  return MoveBlockNode;
}(DragAndDropHandler));

var MoveInline = (function (DragAndDropHandler$$1) {
  function MoveInline () {
    DragAndDropHandler$$1.apply(this, arguments);
  }

  if ( DragAndDropHandler$$1 ) MoveInline.__proto__ = DragAndDropHandler$$1;
  MoveInline.prototype = Object.create( DragAndDropHandler$$1 && DragAndDropHandler$$1.prototype );
  MoveInline.prototype.constructor = MoveInline;

  MoveInline.prototype.match = function match (dragState) {
    return !dragState.external && dragState.inline
  };

  MoveInline.prototype.drop = function drop (tx, dragState) {
    var event = dragState.event;
    var sourceSel = dragState.sourceSelection;
    var wrange = getDOMRangeFromEvent(event);
    if (!wrange) { return }
    var comp = Component.unwrap(event.target);
    if (!comp) { return }
    var domSelection = comp.context.domSelection;
    if (!domSelection) { return }
    var range = domSelection.mapDOMRange(wrange);
    if (!range) { return }
    var targetSel = tx.getDocument()._createSelectionFromRange(range);

    // TODO: iterate custom move-inline handlers
    tx.selection = sourceSel;
    var snippet = tx.copySelection();
    tx.deleteSelection();
    tx.selection = DocumentChange.transformSelection(targetSel, tx);
    tx.paste(snippet);
  };

  return MoveInline;
}(DragAndDropHandler));

var InsertNodes = (function (DragAndDropHandler$$1) {
  function InsertNodes(assetHandlers, context) {
    DragAndDropHandler$$1.call(this);
    this.assetHandlers = assetHandlers;
    this.context = context;
  }

  if ( DragAndDropHandler$$1 ) InsertNodes.__proto__ = DragAndDropHandler$$1;
  InsertNodes.prototype = Object.create( DragAndDropHandler$$1 && DragAndDropHandler$$1.prototype );
  InsertNodes.prototype.constructor = InsertNodes;

  InsertNodes.prototype.match = function match (dragState) {
    return dragState.dropType === 'place' && dragState.external
  };

  InsertNodes.prototype.drop = function drop (tx, dragState) {
    var this$1 = this;

    var ref = dragState.dropParams;
    var insertPos = ref.insertPos;
    var files = dragState.data.files;
    var uris = dragState.data.uris;
    var containerId = dragState.targetSurface.getContainerId();
    var surfaceId = dragState.targetSurface.id;
    var container = tx.get(containerId);
    var targetNode = container.nodes[insertPos];
    var insertMode = 'before';
    if (!targetNode) {
      targetNode = container.nodes[insertPos-1];
      insertMode = 'after';
    }
    tx.setSelection({
      type: 'node',
      nodeId: targetNode,
      mode: insertMode,
      containerId: containerId,
      surfaceId: surfaceId
    });
    if (files.length > 0) {
      files.forEach(function (file) {
        this$1._callHandlers(tx, {
          file: file,
          type: 'file'
        });
      });
    } else if (uris.length > 0) {
      uris.forEach(function (uri) {
        this$1._callHandlers(tx, {
          uri: uri,
          type: 'uri'
        });
      });
    } else {
      console.info('TODO: implement html/text drop here');
    }
  };

  InsertNodes.prototype._callHandlers = function _callHandlers (tx, params) {
    var this$1 = this;

    var i, handler;
    for (i = 0; i < this.assetHandlers.length; i++) {
      handler = this$1.assetHandlers[i];

      var match = handler.match(params, this$1.context);
      if (match) {
        handler.drop(tx, params, this$1.context);
        break
      }
    }
  };

  return InsertNodes;
}(DragAndDropHandler));

/*
  Built-in handler that calls a custom handler, specified
  on the component (e.g. see ImageComponent).
*/
var CustomHandler = (function (DragAndDropHandler$$1) {
  function CustomHandler () {
    DragAndDropHandler$$1.apply(this, arguments);
  }

  if ( DragAndDropHandler$$1 ) CustomHandler.__proto__ = DragAndDropHandler$$1;
  CustomHandler.prototype = Object.create( DragAndDropHandler$$1 && DragAndDropHandler$$1.prototype );
  CustomHandler.prototype.constructor = CustomHandler;

  CustomHandler.prototype.match = function match (dragState) {
    return dragState.dropType === 'custom'
  };

  CustomHandler.prototype.drop = function drop (tx, dragState) {
    // Delegate handling to component which set up the custom dropzone
    dragState.component.handleDrop(tx, dragState);
  };

  return CustomHandler;
}(DragAndDropHandler));

/*
  Experimental

  We are seeking for a solution providing access to global DOM events
  while considering the current app state ~ document session state.

  This implementation is just a prototype and might change with the next releases.
*/

/*
  TODO: to be 100% safe we would need to introduce a hidden contenteditable
  where we put the selection in case of non-surface situations
  so that we are still able to receive events such as 'copy' -- actually only Edge is not dispatching
  to window.document.
*/

var events = [ 'keydown', 'keyup', 'keypress', 'mousedown', 'mouseup' , 'copy'];

var GlobalEventHandler = function GlobalEventHandler(editorSession, surfaceManager) {
  this.editorSession = editorSession;
  this.surfaceManager = surfaceManager;
  this.listeners = [];
  this.initialize();
};

GlobalEventHandler.prototype.initialize = function initialize () {
  if (inBrowser) {
    var document = DefaultDOMElement.wrapNativeElement(window.document);
    events.forEach(function(name) {
      document.on(name, this._dispatch.bind(this, name), this);
    }.bind(this));
  }
};

GlobalEventHandler.prototype.dispose = function dispose () {
  if (inBrowser) {
    var document = DefaultDOMElement.wrapNativeElement(window.document);
    document.off(this);
  }
};

GlobalEventHandler.prototype.addEventListener = function addEventListener (eventName, handler, options) {
  if (!options.id) {
    throw new Error("GlobalEventHandler can only be used with option 'id'")
  }
  var listener = new DOMEventListener(eventName, handler, options);
  this.listeners.push(listener);
};

GlobalEventHandler.prototype.removeEventListener = function removeEventListener (listener) {
  var idx = this.listeners.indexOf(listener);
  if (idx > -1) {
    this.listeners.splice(idx, 1);
  }
};

GlobalEventHandler.prototype.getEventListeners = function getEventListeners () {
  return this.listeners
};

GlobalEventHandler.prototype._getActiveListener = function _getActiveListener (eventName) {
    var this$1 = this;

  var editorSession = this.editorSession;
  var sel = editorSession.getSelection();
  if (sel) {
    var surfaceId = sel.surfaceId;
    for (var i = 0; i < this.listeners.length; i++) {
      var listener = this$1.listeners[i];
      if (listener.eventName === eventName && listener.options.id === surfaceId) {
        return listener
      }
    }
  }
};

GlobalEventHandler.prototype._dispatch = function _dispatch (eventName, e) {
  var listener = this._getActiveListener(eventName);
  if (listener) {
    listener.handler(e);
  }
};

GlobalEventHandler.prototype.on = DOMElement.prototype.on;
GlobalEventHandler.prototype.off = DOMElement.prototype.off;

var MacroManager = function MacroManager(context, macros) {
  this.context = context;
  this.macros = macros;
  this.context.editorSession.onFinalize('document', this.onDocumentChanged, this);
};

MacroManager.prototype.dispose = function dispose () {
  this.context.editorSession.off(this);
};

MacroManager.prototype.onDocumentChanged = function onDocumentChanged (change, info) {
  this.executeMacros(change, info);
};

MacroManager.prototype.executeMacros = function executeMacros (change, info) {
    var this$1 = this;

  var doc = this.context.editorSession.getDocument();
  var nodeId, node, text, start, end;
  var path;
  // HACK: we exploit the information of the internal structure
  // of this document changes
  switch(info.action) {
    case 'type': {
      var op = change.ops[0];
      if (op.type === 'update' && op.diff._isTextOperation) {
        path = op.path;
        nodeId = path[0];
        node = doc.get(nodeId);
        text = doc.get(path);
        start = op.diff.pos;
        end = start+op.diff.getLength();
      }
      break
    }
    case 'break': {
      // FIXME: this impl turned out to be fragile,
      // as the selection before the transaction
      // can show to nodes not being there anymore

      // We interpret a 'break' as kind of confirmation
      // of the current node
      // so we take the original selection
      // to determine the original node
      var sel = change.before.selection;
      if (!sel.isPropertySelection()) { return }
      path = sel.path;
      nodeId = path[0];
      node = doc.get(nodeId);
      // HACK: fragile - before.selection is not a good reference
      if (!node || !node.isText()) { return }
      text = node.getText();
      start = sel.start.offset;
      end = start;
      break
    }
    case 'paste': {
      // HACK: just support primitive plain-text paste
      if (change.ops.length === 1) {
        var op$1 = change.ops[0];
        if (op$1.type === 'update' && op$1.propertyType === 'string') {
          path = op$1.path;
          nodeId = path[0];
          node = doc.get(nodeId);
          if (!node.isText()) { return }
          text = node.getText();
          start = op$1.diff.pos;
          end = start+op$1.diff.getLength();
        }
      }
      break
    }
    default:
      return
  }

  var props = {
    action: info.action,
    node: node,
    path: path,
    text: text,
    start: start,
    end: end,
    editorSession: this.context.editorSession,
    selection: this.context.editorSession.getSelection()
  };

  setTimeout(function () {
    for (var i = 0; i < this$1.macros.length; i++) {
      var macro = this$1.macros[i];
      var executed = macro.execute(props, this$1.context);
      if (executed) {
        break
      }
    }
  });

};

/* eslint-disable strict */
var keys = {
  UNDEFINED: 0,
  BACKSPACE: 8,
  DELETE: 46,
  LEFT: 37,
  RIGHT: 39,
  UP: 38,
  DOWN: 40,
  ENTER: 13,
  END: 35,
  HOME: 36,
  TAB: 9,
  PAGEUP: 33,
  PAGEDOWN: 34,
  ESCAPE: 27,
  SHIFT: 16,
  SPACE: 32
};

var ExecuteCommandHandler = function ExecuteCommandHandler(editorSession, commandName) {
  this.editorSession = editorSession;
  this.commandName = commandName;
};
ExecuteCommandHandler.prototype.execute = function execute (params) {
  var commandState = params.editorSession.getCommandStates()[this.commandName];
  if (!commandState || commandState.disabled) { return false }
  this.editorSession.executeCommand(this.commandName, params);
  return true
};

var KeyboardManager = function KeyboardManager(editorSession, bindings, options) {
  var this$1 = this;

  this.editorSession = editorSession;

  this.context = options.context || {};

  this.keydownBindings = {};
  this.textinputBindings = {};

  bindings.forEach(function (ref) {
    var key = ref.key;
    var spec = ref.spec;

    // default combos are evaluated on keydown
    var type = spec.type || 'keydown';
    if(spec.command) {
      var handler = new ExecuteCommandHandler(editorSession, spec.command);
      var hook = handler.execute.bind(handler);
      if (type === 'keydown') {
        this$1.keydownBindings[parseCombo(key)] = hook;
      } else if (type === 'textinput') {
        this$1.textinputBindings[key] = hook;
      }
    } else {
      throw new Error('Keyboard binding not supported', spec)
    }
  });
};

KeyboardManager.prototype.onKeydown = function onKeydown (event) {
  var key = generateKey(event);
  var hook = this.keydownBindings[key];
  if (hook) {
    event.preventDefault();
    event.stopPropagation();
    var params = this._getParams();
    return hook(params, this.context)
  }
};

KeyboardManager.prototype.onTextInput = function onTextInput (text) {
  var hook = this.textinputBindings[text];
  if (hook) {
    var params = this._getParams();
    return hook(params, this.context)
  }
};

KeyboardManager.prototype._getParams = function _getParams () {
  var editorSession = this.editorSession;
  var selectionState = editorSession.getSelectionState();
  var sel = selectionState.getSelection();
  var surface = this.context.surfaceManager.getFocusedSurface();
  return {
    editorSession: editorSession,
    selectionState: selectionState,
    surface: surface,
    selection: sel,
  }
};

// transforms a string like 'cmd+a' into an internal normalized representation

function generateKey(event) {
  var frags = [];
  if (event.altKey) {
    if (event.code === 'AltRight') {
      frags.push('ALTGR');
    } else {
      frags.push('ALT');
    }
  }
  if (event.ctrlKey) { frags.push('CTRL'); }
  if (event.metaKey) { frags.push('META'); }
  if (event.shiftKey) { frags.push('SHIFT'); }
  frags.push(event.keyCode);
  return frags.join('+')
}

function parseCombo(combo) {
  var frags = combo.split('+');
  var data = {
    keyCode: -1
  };
  for (var i = 0; i < frags.length; i++) {
    var frag = frags[i].toUpperCase();
    switch(frag) {
      case 'ALT': {
        data.altKey = true;
        break
      }
      case 'ALTGR': {
        data.altKey = true;
        data.code = 'AltRight';
        break
      }
      case 'CMD': {
        data.metaKey = true;
        break
      }
      case 'CTRL': {
        data.ctrlKey = true;
        break
      }
      case 'SHIFT': {
        data.shiftKey = true;
        break
      }
      default:
        if (frag.length === 1) {
          data.keyCode = frag.charCodeAt(0);
        } else if (keys.hasOwnProperty(frag)) {
          data.keyCode = keys[frag];
        } else {
          throw new Error('Unsupported keyboard command: '+ combo)
        }
    }
  }
  return generateKey(data)
}

KeyboardManager.parseCombo = parseCombo;

/*
  Storage for files such as images and other assets.

  This accumulates files created or loaded during a session
  so that it is possible to pick up a file after undo+redo.
*/
var FileManager = function FileManager(editorSession, extensions, context) {
  var this$1 = this;

  this.editorSession = editorSession;
  this.extensions = extensions;
  this.proxies = {};
  this.context = context;

  // adapt all existing files
  forEach(editorSession.getDocument().getNodes(), function (node) {
    if (node._isFileNode) { this$1.storeFile(node); }
  });

  this.editorSession.onUpdate('document', this._onDocumentChange, this);
};

FileManager.prototype.dispose = function dispose () {
  this.editorSession.off(this);
};

FileManager.prototype.storeFile = function storeFile (fileNode) {
  var proxy = this.proxies[fileNode.id];
  // don't adapt the file if we already have it
  if (!proxy) {
    proxy = this.createFileProxy(fileNode);
    if (proxy) {
      this.proxies[fileNode.id] = proxy;
    }
  }
  fileNode.proxy = proxy;
  return proxy
};

FileManager.prototype.createFileProxy = function createFileProxy (fileNode) {
    var this$1 = this;
 // eslint-disable-line
  var context = this.context;
  for (var i = 0; i < this.extensions.length; i++) {
    var ExtClass = this$1.extensions[i];
    if (ExtClass.match(fileNode, context)) {
      return new ExtClass(fileNode, context)
    }
  }
  console.error('No file adapter found for ', fileNode);
};

FileManager.prototype.getProxy = function getProxy (fileNode) {
  return this.proxies[fileNode.id]
};

FileManager.prototype.sync = function sync () {
  // Note: potentially this could be a bi-directional sync
  // ATM, we only consider upload
  var promises = map(this.proxies, function (proxy) {
    return proxy.sync()
  });
  return Promise.all(promises)
};

FileManager.prototype._onDocumentChange = function _onDocumentChange (change) {
    var this$1 = this;

  var doc = this.editorSession.getDocument();
  forEach(change.created, function (nodeData) {
    // we would need the real node to support inheritance
    var node = doc.get(nodeData.id);
    if (node._isFileNode) {
      this$1.storeFile(node);
    }
  });
};

var EditorSession = (function (EventEmitter$$1) {
  function EditorSession(doc, options) {
    EventEmitter$$1.call(this);

    options = options || {};

    this.document = doc;
    if (!options.configurator) {
      throw new Error('No configurator provided.')
    }
    this.configurator = options.configurator;

    this._transaction = new Transaction(doc, this);

    this._history = new ChangeHistory();
    // used for change accumulation (in a collab environment)
    this._currentChange = null;

    // TODO: while it is good to have these selection
    // related derived state informations separated
    // it would feel better to have the selection itself
    // as a property of this session
    this._selectionState = new SelectionState(doc);

    this._commandStates = [];

    // the session exposes these resources, and keeps track of changes
    this._resources = ['document', 'selection', 'commandStates'];
    // flags to keep track which resources have changed since the last 'flow'
    this._dirtyFlags = {};
    // set during a change
    this._change = null;
    this._info = null;

    this._flowStages = ['update', 'pre-render', 'render', 'post-render', 'position', 'finalize'];
    // to get something executed directly after a flow
    this._postponed = [];

    this._observers = {};

    this._lang = options.lang || this.configurator.getDefaultLanguage();
    this._dir = options.dir || 'ltr';

    // Managers
    // --------

    // surface manager takes care of surfaces, keeps track of the currently focused surface
    // and makes sure the DOM selection is rendered properly at the end of a flow
    this.surfaceManager = new SurfaceManager(this);
    // this context is provided to commands, tools, etc.
    this._context = {
      editorSession: this,
      //legacy
      surfaceManager: this.surfaceManager,
    };
    // to expose custom context just provide optios.context
    if (options.context) {
      Object.assign(this._context, options.context);
    }

    var configurator = this.configurator;
    var commands = configurator.getCommands();
    var dropHandlers = configurator.getDropHandlers();
    var macros = configurator.getMacros();
    var converterRegistry = configurator.getConverterRegistry();
    var editingBehavior = configurator.getEditingBehavior();

    this.fileManager = options.fileManager || new FileManager(this, configurator.getFileAdapters(), this._context);

    // Handling of saving
    this._hasUnsavedChanges = false;
    this._isSaving = false;

    if (options.saveHandler) {
      this.saveHandler = options.saveHandler;
    } else {
      this.saveHandler = configurator.getSaveHandler();
    }

    // The command manager keeps the commandStates up-to-date
    this.commandManager = new CommandManager(this._context, commands);
    // The drag manager dispatches drag requests to registered drag handlers
    // TODO: after consolidating the API of this class, we probably need a less diverse context
    this.dragManager = new DragManager(dropHandlers, Object.assign({}, this._context, {
      commandManager: this.commandManager
    }));
    // The macro manager dispatches to macro detectors at the end of the flow
    this.macroManager = new MacroManager(this._context, macros);
    this.globalEventHandler = new GlobalEventHandler(this, this.surfaceManager);
    this.markersManager = new MarkersManager(this);
    this.keyboardManager = new KeyboardManager(this, configurator.getKeyboardShortcuts(), {
      context: this._context
    });

    // TODO: see how we want to expose these
    this.converterRegistry = converterRegistry;
    this.editingBehavior = editingBehavior;
  }

  if ( EventEmitter$$1 ) EditorSession.__proto__ = EventEmitter$$1;
  EditorSession.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  EditorSession.prototype.constructor = EditorSession;

  EditorSession.prototype.dispose = function dispose () {
    this.surfaceManager.dispose();
    this.fileManager.dispose();
    this.commandManager.dispose();
    this.dragManager.dispose();
    this.macroManager.dispose();
    this.globalEventHandler.dispose();
    this.markersManager.dispose();
  };

  EditorSession.prototype.hasChanged = function hasChanged (resource) {
    return this._dirtyFlags[resource]
  };

  EditorSession.prototype.hasDocumentChanged = function hasDocumentChanged () {
    return this.hasChanged('document')
  };

  EditorSession.prototype.hasSelectionChanged = function hasSelectionChanged () {
    return this.hasChanged('selection')
  };

  EditorSession.prototype.hasCommandStatesChanged = function hasCommandStatesChanged () {
    return this.hasChanged('commandStates')
  };

  EditorSession.prototype.hasLanguageChanged = function hasLanguageChanged () {
    return this.hasChanged('lang')
  };

  EditorSession.prototype.hasTextDirectionChanged = function hasTextDirectionChanged () {
    return this.hasChanged('dir')
  };

  EditorSession.prototype.get = function get (resourceName) {
    switch(resourceName) {
      case 'document':
        return this.getDocument()
      case 'selection':
        return this.getSelection()
      case 'commandStates':
        return this.getCommandStates()
      case 'change':
        return this.getChange()
      default:
        throw new Error('Unknown resource: ' + resourceName)
    }
  };

  EditorSession.prototype.getConfigurator = function getConfigurator () {
    return this.configurator
  };

  EditorSession.prototype.getDocument = function getDocument () {
    return this.document
  };

  EditorSession.prototype.getSelection = function getSelection () {
    return this.getSelectionState().getSelection()
  };

  EditorSession.prototype.getSelectionState = function getSelectionState () {
    return this._selectionState
  };

  EditorSession.prototype.getCommandStates = function getCommandStates () {
    return this._commandStates
  };

  EditorSession.prototype.getChange = function getChange () {
    return this._change
  };

  EditorSession.prototype.getChangeInfo = function getChangeInfo () {
    return this._info
  };

  EditorSession.prototype.getFocusedSurface = function getFocusedSurface () {
    return this.surfaceManager.getFocusedSurface()
  };

  EditorSession.prototype.getSurface = function getSurface (surfaceId) {
    return this.surfaceManager.getSurface(surfaceId)
  };

  EditorSession.prototype.getLanguage = function getLanguage () {
    return this._lang
  };

  EditorSession.prototype.getTextDirection = function getTextDirection () {
    return this._dir
  };

  EditorSession.prototype.canUndo = function canUndo () {
    return this._history.canUndo()
  };

  EditorSession.prototype.canRedo = function canRedo () {
    return this._history.canRedo()
  };

  EditorSession.prototype.executeCommand = function executeCommand () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    (ref = this.commandManager).executeCommand.apply(ref, args);
    var ref;
  };

  EditorSession.prototype.setSelection = function setSelection (sel) {
    // console.log('EditorSession.setSelection()', sel)
    if (sel && isPlainObject(sel)) {
      sel = this.getDocument().createSelection(sel);
    }
    if (sel && !sel.isNull() && !sel.surfaceId) {
      var fs = this.getFocusedSurface();
      if (fs) {
        sel.surfaceId = fs.id;
      }
    }
    if (this._setSelection(sel)) {
      this.startFlow();
    }
    return sel
  };

  EditorSession.prototype.selectNode = function selectNode (nodeId) {
    var surface = this.getFocusedSurface();
    this.setSelection({
      type: 'node',
      nodeId: nodeId,
      containerId: surface.getContainerId(),
      surfaceId: surface.id
    });
  };

  EditorSession.prototype.setCommandStates = function setCommandStates (commandStates) {
    this._commandStates = commandStates;
    this._setDirty('commandStates');
  };

  EditorSession.prototype.setLanguage = function setLanguage (lang) {
    if (this._lang !== lang) {
      this._lang = lang;
      this._setDirty('lang');
      this.startFlow();
    }
  };

  EditorSession.prototype.setTextDirection = function setTextDirection (dir) {
    if (this._dir !== dir) {
      this._dir = dir;
      this._setDirty('dir');
      this.startFlow();
    }
  };

  EditorSession.prototype.createSelection = function createSelection () {
    var doc = this.getDocument();
    return doc.createSelection.apply(doc, arguments)
  };

  EditorSession.prototype.getCollaborators = function getCollaborators () {
    return null
  };

  /*
    Set saveHandler via API

    E.g. if saveHandler not available at construction
  */
  EditorSession.prototype.setSaveHandler = function setSaveHandler (saveHandler) {
    this.saveHandler = saveHandler;
  };

  /**
    Start a transaction to manipulate the document

    @param {function} transformation a function(tx) that performs actions on the transaction document tx

    @example

    ```js
    doc.transaction(function(tx, args) {
      tx.update(...)
      ...
      tx.setSelection(newSelection)
    })
    ```
  */
  EditorSession.prototype.transaction = function transaction (transformation, info) {
    info = info || {};
    var change = this._transaction._recordChange(transformation, this.getSelection(), this.getFocusedSurface());
    if (change) {
      this._commit(change, info);
    } else {
      // if no changes, at least update the selection
      this._setSelection(this._transaction.getSelection());
      this.startFlow();
    }
    return change
  };

  EditorSession.prototype.undo = function undo () {
    this._undoRedo('undo');
  };

  EditorSession.prototype.redo = function redo () {
    this._undoRedo('redo');
  };

  /**
    Registers a hook for the `update` phase.

    During `update` data should be derived necessary for rendering.

    This is mainly used by extensions of the EditorSession to
    derive extra state information.

    @param {string} [resource] the name of the resource
    @param {Function} handler the function handler
    @param {Object} context owner of the handler
    @param {Object} [options] options for the resource handler

  */
  EditorSession.prototype.onUpdate = function onUpdate () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return this._registerObserver('update', args)
  };

  EditorSession.prototype.onPreRender = function onPreRender () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return this._registerObserver('pre-render', args)
  };

  /**
    Registers a hook for the 'render' phase.

    During `render`, components should be rerendered.

    @param {string} [resource] the name of the resource
    @param {Function} handler the function handler
    @param {Object} context owner of the handler
    @param {Object} [options] options for the resource handler

    @example

    This typically used by components that render node content.

    ```js
    class ImageComponent extends Component {
      didMount() {
        this.context.editorSession.onRender('document', this.rerender, this, {
          path: [this.props.node.id, 'src']
        })
      }
      dispose() {
        this.context.editorSession.off(this)
      }
      render($$) {
        ...
      }
    }
    ```
  */
  EditorSession.prototype.onRender = function onRender () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return this._registerObserver('render', args)
  };

  /**
    Registers a hook for the 'post-render' phase.

    ATM, this phase is used internally only, for recovering the DOM selection
    which typically gets destroyed due to rerendering

    @internal

    @param {string} [resource] the name of the resource
    @param {Function} handler the function handler
    @param {Object} context owner of the handler
    @param {Object} [options] options for the resource handler
  */
  EditorSession.prototype.onPostRender = function onPostRender () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return this._registerObserver('post-render', args)
  };

  /**
    Registers a hook for the 'position' phase.

    During `position`, components such as Overlays, for instance, should be positioned.
    At this stage, it is guaranteed that all content is rendered, and the DOM selection
    is set.

    @param {string} [resource] the name of the resource
    @param {Function} handler the function handler
    @param {Object} context owner of the handler
    @param {Object} [options] options for the resource handler

  */
  EditorSession.prototype.onPosition = function onPosition () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return this._registerObserver('position', args)
  };

  EditorSession.prototype.onFinalize = function onFinalize () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return this._registerObserver('finalize', args)
  };

  EditorSession.prototype.off = function off (observer) {
    EventEmitter$$1.prototype.off.call(this, observer);
    this._deregisterObserver(observer);
  };

  EditorSession.prototype._setSelection = function _setSelection (sel) {
    var hasChanged = this.getSelectionState().setSelection(sel);
    if (hasChanged) { this._setDirty('selection'); }
    return hasChanged
  };

  EditorSession.prototype._undoRedo = function _undoRedo (which) {
    var doc = this.getDocument();
    var from, to;
    if (which === 'redo') {
      from = this._history.undoneChanges;
      to = this._history.doneChanges;
    } else {
      from = this._history.doneChanges;
      to = this._history.undoneChanges;
    }
    var change = from.pop();
    if (change) {
      this._applyChange(change, {});
      // keep tx in sync
      this._transaction._apply(change);
      // move change to the opposite change list (undo <-> redo)
      to.push(change.invert());
      // use selection from change
      var sel = change.after.selection;
      if (sel) { sel.attach(doc); }
      this._setSelection(sel);
      // finally trigger the flow
      this.startFlow();
    } else {
      console.warn('No change can be %s.', (which === 'undo'? 'undone':'redone'));
    }
  };

  EditorSession.prototype._transformLocalChangeHistory = function _transformLocalChangeHistory (externalChange) {
    // Transform the change history
    // Note: using a clone as the transform is done inplace
    // which is ok for the changes in the undo history, but not
    // for the external change
    var clone = {
      ops: externalChange.ops.map(function(op) { return op.clone(); })
    };
    DocumentChange.transformInplace(clone, this._history.doneChanges);
    DocumentChange.transformInplace(clone, this._history.undoneChanges);
  };

  EditorSession.prototype._transformSelection = function _transformSelection (change) {
    var oldSelection = this.getSelection();
    var newSelection = DocumentChange.transformSelection(oldSelection, change);
    // console.log('Transformed selection', change, oldSelection.toString(), newSelection.toString())
    return newSelection
  };

  EditorSession.prototype._commit = function _commit (change, info) {
    this._commitChange(change, info);
    // TODO: Not sure this is the best place to mark the session dirty
    this._hasUnsavedChanges = true;
    this.startFlow();
  };

  EditorSession.prototype._commitChange = function _commitChange (change, info) {
    change.timestamp = Date.now();
    this._applyChange(change, info);
    if (info['history'] !== false && !info['hidden']) {
      this._history.push(change.invert());
    }
    var newSelection = change.after.selection || Selection.nullSelection;
    // HACK injecting the surfaceId here...
    // TODO: we should find out where the best place is to do this
    if (!newSelection.isNull() && !newSelection.surfaceId) {
      newSelection.surfaceId = change.after.surfaceId;
    }
    this._setSelection(newSelection);
  };

  EditorSession.prototype._applyChange = function _applyChange (change, info) {
    if (!change) {
      console.error('FIXME: change is null.');
      return
    }
    this.getDocument()._apply(change);
    this._setDirty('document');
    this._change = change;
    this._info = info;
  };

  /*
    Are there unsaved changes?
  */
  EditorSession.prototype.hasUnsavedChanges = function hasUnsavedChanges () {
    return this._hasUnsavedChanges
  };

  /*
    Save session / document
  */
  EditorSession.prototype.save = function save () {
    var this$1 = this;

    var saveHandler = this.saveHandler;

    if (this._hasUnsavedChanges && !this._isSaving) {
      this._isSaving = true;
      // Pass saving logic to the user defined callback if available
      if (saveHandler) {
        var saveParams = {
          editorSession: this,
          fileManager: this.fileManager
        };
        return saveHandler.saveDocument(saveParams)
        .then(function () {
          this$1._hasUnsavedChanges = false;
          // We update the selection, just so a selection update flow is
          // triggered (which will update the save tool)
          // TODO: model this kind of update more explicitly. It could be an 'update' to the
          // document resource (hasChanges was modified)
          this$1.setSelection(this$1.getSelection());
        })
        .catch(function (err) {
          console.error('Error during save', err);
        }).then(function () { // finally
          this$1._isSaving = false;
        })
      } else {
        console.error('Document saving is not handled at the moment. Make sure saveHandler instance provided to editorSession');
        return Promise.reject()
      }
    }
  };

  /*
    Starts the flow.

    This is necessary when changing resources managed by the session.
    To be able to change multiple resources at the same time,
    this is not done automatically, but needs to be called
    by the implementation.

    @internal
  */
  EditorSession.prototype.startFlow = function startFlow () {
    if (this._flowing) { return }
    this._flowing = true;
    try {
      this.performFlow();
    } finally {
      this._resetFlow();
      this._flowing = false;
    }
    // Note: postponing is ATM used only by Macros
    // HACK: to avoid having multiple flows at the same time
    // we are running this deferred
    var postponed = this._postponed;
    var self = this;
    this._postponed = [];
    setTimeout(function() {
      postponed.forEach(function(fn) {
        fn(self);
      });
    }, 0);
  };

  /*
    Emits the phases in the correct order.

    @internal
  */
  EditorSession.prototype.performFlow = function performFlow () {
    var this$1 = this;

    this._flowStages.forEach(function (stage) {
      this$1._notifyObservers(stage);
    });
  };

  EditorSession.prototype.postpone = function postpone (fn) {
    this._postponed.push(fn);
  };

  EditorSession.prototype._parseObserverArgs = function _parseObserverArgs (args) {
    var params = { resource: null, handler: null, context: null, options: {} };
    // first can be a string
    var idx = 0;
    var arg = args[idx];
    if (isString(arg)) {
      params.resource = arg;
      idx++;
      arg = args[idx];
    }
    if (!arg) {
      throw new Error('Provided handler function was nil.')
    }
    if (!isFunction$2(arg)) {
      throw new Error('Expecting a handler Function.')
    }
    params.handler = arg;
    idx++;
    arg = args[idx];
    if (arg) {
      params.context = arg;
      idx++;
      arg = args[idx];
    }
    if (arg) {
      params.options = arg;
    }
    return params
  };

  EditorSession.prototype._registerObserver = function _registerObserver (stage, args) {
    var observer = this._parseObserverArgs(args);
    var observers = this._observers[stage];
    if (!observers) {
      observers = this._observers[stage] = [];
    }
    observers.push(observer);
  };

  EditorSession.prototype._deregisterObserver = function _deregisterObserver (observer) {
    // TODO: we should optimize this, as ATM this needs to traverse
    // a lot of registered listeners
    forEach(this._observers, function (observers) {
      for (var i = 0; i < observers.length; i++) {
        var entry = observers[i];
        if (entry.context === observer) {
          // console.log('## removing observer')
          observers.splice(i, 1);
          i--;
        }
      }
    });
    // add this flag so that we can skip when a listener has deregistered
    // during notification iteration
    observer._deregistered = true;
  };

  EditorSession.prototype._notifyObservers = function _notifyObservers (stage) {
    var this$1 = this;

    // TODO: this is not hierarchical anymore
    // i.e. probably we have to expect degradation of performance
    // with huuuge documents, as the number of listeners is
    // We could optimize this by 'compiling' a list of observers for
    // each configuration, maybe lazily
    // for now we accept this circumstance
    var _observers = this._observers[stage];
    if (!_observers) { return }
    // Make a copy so that iteration does not get confused, when listeners deregister
    // TODO: we could improve this by using a custom data structure that allows
    // manipulation during iteration
    var observers = _observers.slice();
    for (var i = 0; i < observers.length; i++) {
      var o = observers[i];
      // an observer might have been deregistered while this iteration was going on
      if (o._deregistered) { continue }
      if (!o.resource) {
        o.handler.call(o.context, this$1);
      } else if (o.resource === 'document') {
        if (!this$1.hasDocumentChanged()) { continue }
        var change = this$1.getChange();
        var info = this$1.getChangeInfo();
        var path = o.options.path;
        if (!path) {
          o.handler.call(o.context, change, info, this$1);
        } else if (change.isAffected(path)) {
          o.handler.call(o.context, change, info, this$1);
        }
      } else {
        if (!this$1.hasChanged(o.resource)) { continue }
        var resource = this$1.get(o.resource);
        o.handler.call(o.context, resource, this$1);
      }
    }
  };

  EditorSession.prototype._setDirty = function _setDirty (resource) {
    this._dirtyFlags[resource] = true;
  };

  EditorSession.prototype._resetFlow = function _resetFlow () {
    var this$1 = this;

    Object.keys(this._dirtyFlags).forEach(function (resource) {
      this$1._dirtyFlags[resource] = false;
    });
    this._change = null;
    this._info = null;
  };

  return EditorSession;
}(EventEmitter));

/**
  Performs an asynchronous HTTP request.

  @param {String} method HTTP method to use for the request
  @param {String} url url to which the request is sent
  @param {Object} data json to be sent to the server
  @param {Function} cb callback that takes error and response data

  @example

  ```js
  request('GET', './data.json', null, function(err, data) {
    if (err) return cb(err);
    cb(null, data);
  });
  ```
*/
function request(method, url, data, cb) {
  var request = new XMLHttpRequest();
  request.open(method, url, true);
  request.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
  request.onload = function() {
    if (request.status >= 200 && request.status < 400) {
      var res = request.responseText;
      if(isJson(res)) { res = JSON.parse(res); }
      cb(null, res);
    } else {
      return cb(new Error('Request failed. Returned status: ' + request.status))
    }
  };

  if (data) {
    request.send(JSON.stringify(data));
  } else {
    request.send();
  }
}

function isJson(str) {
  try {
    JSON.parse(str);
  } catch (e) {
    return false
  }
  return true
}

/*
  HTTP client for talking with DocumentServer
*/
var DocumentClient = function DocumentClient(config) {
  this.config = config;
};

/*
  Create a new document on the server

  ```js
  @example
  ```

  documentClient.createDocument({
    schemaName: 'prose-article',
    info: {
      userId: 'userx'
    }
  });
*/
DocumentClient.prototype.createDocument = function createDocument (newDocument, cb) {
  request('POST', this.config.httpUrl, newDocument, cb);
};

/*
  Get a document from the server

  @example

  ```js
  documentClient.getDocument('mydoc-id');
  ```
*/

DocumentClient.prototype.getDocument = function getDocument (documentId, cb) {
  request('GET', this.config.httpUrl+documentId, null, cb);
};

/*
  Remove a document from the server

  @example

  ```js
  documentClient.deleteDocument('mydoc-id');
  ```
*/

DocumentClient.prototype.deleteDocument = function deleteDocument (documentId, cb) {
  request('DELETE', this.config.httpUrl+documentId, null, cb);
};

/** Used as references for various `Number` constants. */
var NAN$1 = 0 / 0;

/**
 * The base implementation of `_.toNumber` which doesn't ensure correct
 * conversions of binary, hexadecimal, or octal string values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 */
function baseToNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN$1;
  }
  return +value;
}

/**
 * Creates a function that performs a mathematical operation on two values.
 *
 * @private
 * @param {Function} operator The function to perform the operation.
 * @returns {Function} Returns the new mathematical operation function.
 */
function createMathOperation(operator) {
  return function(value, other) {
    var result;
    if (value === undefined && other === undefined) {
      return 0;
    }
    if (value !== undefined) {
      result = value;
    }
    if (other !== undefined) {
      if (result === undefined) {
        return other;
      }
      if (typeof value == 'string' || typeof other == 'string') {
        value = baseToString(value);
        other = baseToString(other);
      } else {
        value = baseToNumber(value);
        other = baseToNumber(other);
      }
      result = operator(value, other);
    }
    return result;
  };
}

/**
 * Adds two numbers.
 *
 * @static
 * @memberOf _
 * @since 3.4.0
 * @category Math
 * @param {number} augend The first number in an addition.
 * @param {number} addend The second number in an addition.
 * @returns {number} Returns the total.
 * @example
 *
 * _.add(6, 4);
 * // => 10
 */
var add = createMathOperation(function(augend, addend) {
  return augend + addend;
});

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$2 = 'Expected a function';

/**
 * The opposite of `_.before`; this method creates a function that invokes
 * `func` once it's called `n` or more times.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {number} n The number of calls before `func` is invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var saves = ['profile', 'settings'];
 *
 * var done = _.after(saves.length, function() {
 *   console.log('done saving!');
 * });
 *
 * _.forEach(saves, function(type) {
 *   asyncSave({ 'type': type, 'complete': done });
 * });
 * // => Logs 'done saving!' after the two async saves have completed.
 */
function after(n, func) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  n = toInteger(n);
  return function() {
    if (--n < 1) {
      return func.apply(this, arguments);
    }
  };
}

/**
 * This method returns the first argument given to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/* Built-in method references that are verified to be native. */
var WeakMap$1 = getNative(root, 'WeakMap');

/** Used to store function metadata. */
var metaMap = WeakMap$1 && new WeakMap$1;

/**
 * The base implementation of `setData` without support for hot loop detection.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var baseSetData = !metaMap ? identity : function(func, data) {
  metaMap.set(func, data);
  return func;
};

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject$1(proto) ? objectCreate(proto) : {};
}

/**
 * Creates a function that produces an instance of `Ctor` regardless of
 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
 *
 * @private
 * @param {Function} Ctor The constructor to wrap.
 * @returns {Function} Returns the new wrapped function.
 */
function createCtorWrapper(Ctor) {
  return function() {
    // Use a `switch` statement to work with class constructors. See
    // http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    // for more details.
    var args = arguments;
    switch (args.length) {
      case 0: return new Ctor;
      case 1: return new Ctor(args[0]);
      case 2: return new Ctor(args[0], args[1]);
      case 3: return new Ctor(args[0], args[1], args[2]);
      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate(Ctor.prototype),
        result = Ctor.apply(thisBinding, args);

    // Mimic the constructor's `return` behavior.
    // See https://es5.github.io/#x13.2.2 for more details.
    return isObject$1(result) ? result : thisBinding;
  };
}

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG$1 = 1;

/**
 * Creates a function that wraps `func` to invoke it with the optional `this`
 * binding of `thisArg`.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createBaseWrapper(func, bitmask, thisArg) {
  var isBind = bitmask & BIND_FLAG$1,
      Ctor = createCtorWrapper(func);

  function wrapper() {
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$2 = Math.max;

/**
 * Creates an array that is the composition of partially applied arguments,
 * placeholders, and provided arguments into a single array of arguments.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to prepend to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersLength = holders.length,
      leftIndex = -1,
      leftLength = partials.length,
      rangeLength = nativeMax$2(argsLength - holdersLength, 0),
      result = Array(leftLength + rangeLength),
      isUncurried = !isCurried;

  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$3 = Math.max;

/**
 * This function is like `composeArgs` except that the arguments composition
 * is tailored for `_.partialRight`.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to append to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersIndex = -1,
      holdersLength = holders.length,
      rightIndex = -1,
      rightLength = partials.length,
      rangeLength = nativeMax$3(argsLength - holdersLength, 0),
      result = Array(rangeLength + rightLength),
      isUncurried = !isCurried;

  while (++argsIndex < rangeLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result;
}

/**
 * Gets the number of `placeholder` occurrences in `array`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} placeholder The placeholder to search for.
 * @returns {number} Returns the placeholder count.
 */
function countHolders(array, placeholder) {
  var length = array.length,
      result = 0;

  while (length--) {
    if (array[length] === placeholder) {
      result++;
    }
  }
  return result;
}

/**
 * The function whose prototype chain sequence wrappers inherit from.
 *
 * @private
 */
function baseLodash() {
  // No operation performed.
}

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/**
 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
 *
 * @private
 * @constructor
 * @param {*} value The value to wrap.
 */
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}

// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype = baseCreate(baseLodash.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;

/**
 * A method that returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

/**
 * Gets metadata for `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {*} Returns the metadata for `func`.
 */
var getData = !metaMap ? noop : function(func) {
  return metaMap.get(func);
};

/** Used to lookup unminified function names. */
var realNames = {};

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

/**
 * Gets the name of `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {string} Returns the function name.
 */
function getFuncName(func) {
  var result = (func.name + ''),
      array = realNames[result],
      length = hasOwnProperty$5.call(realNames, result) ? array.length : 0;

  while (length--) {
    var data = array[length],
        otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result;
}

/**
 * The base constructor for creating `lodash` wrapper objects.
 *
 * @private
 * @param {*} value The value to wrap.
 * @param {boolean} [chainAll] Enable explicit method chain sequences.
 */
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = undefined;
}

LodashWrapper.prototype = baseCreate(baseLodash.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Creates a clone of `wrapper`.
 *
 * @private
 * @param {Object} wrapper The wrapper to clone.
 * @returns {Object} Returns the cloned wrapper.
 */
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper) {
    return wrapper.clone();
  }
  var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = copyArray(wrapper.__actions__);
  result.__index__  = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

/**
 * Creates a `lodash` object which wraps `value` to enable implicit method
 * chain sequences. Methods that operate on and return arrays, collections,
 * and functions can be chained together. Methods that retrieve a single value
 * or may return a primitive value will automatically end the chain sequence
 * and return the unwrapped value. Otherwise, the value must be unwrapped
 * with `_#value`.
 *
 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
 * enabled using `_.chain`.
 *
 * The execution of chained methods is lazy, that is, it's deferred until
 * `_#value` is implicitly or explicitly called.
 *
 * Lazy evaluation allows several methods to support shortcut fusion.
 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
 * the creation of intermediate arrays and can greatly reduce the number of
 * iteratee executions. Sections of a chain sequence qualify for shortcut
 * fusion if the section is applied to an array of at least `200` elements
 * and any iteratees accept only one argument. The heuristic for whether a
 * section qualifies for shortcut fusion is subject to change.
 *
 * Chaining is supported in custom builds as long as the `_#value` method is
 * directly or indirectly included in the build.
 *
 * In addition to lodash methods, wrappers have `Array` and `String` methods.
 *
 * The wrapper `Array` methods are:
 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
 *
 * The wrapper `String` methods are:
 * `replace` and `split`
 *
 * The wrapper methods that support shortcut fusion are:
 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
 *
 * The chainable wrapper methods are:
 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
 * `zipObject`, `zipObjectDeep`, and `zipWith`
 *
 * The wrapper methods that are **not** chainable by default are:
 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `deburr`, `divide`, `each`,
 * `eachRight`, `endsWith`, `eq`, `escape`, `escapeRegExp`, `every`, `find`,
 * `findIndex`, `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `first`,
 * `floor`, `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`,
 * `forOwnRight`, `get`, `gt`, `gte`, `has`, `hasIn`, `head`, `identity`,
 * `includes`, `indexOf`, `inRange`, `invoke`, `isArguments`, `isArray`,
 * `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`, `isBoolean`,
 * `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isEqualWith`,
 * `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`, `isMap`,
 * `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
 * `upperFirst`, `value`, and `words`
 *
 * @name _
 * @constructor
 * @category Seq
 * @param {*} value The value to wrap in a `lodash` instance.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var wrapped = _([1, 2, 3]);
 *
 * // Returns an unwrapped value.
 * wrapped.reduce(_.add);
 * // => 6
 *
 * // Returns a wrapped value.
 * var squares = wrapped.map(square);
 *
 * _.isArray(squares);
 * // => false
 *
 * _.isArray(squares.value());
 * // => true
 */
function lodash(value) {
  if (isObjectLike(value) && !isArray$1(value) && !(value instanceof LazyWrapper)) {
    if (value instanceof LodashWrapper) {
      return value;
    }
    if (hasOwnProperty$6.call(value, '__wrapped__')) {
      return wrapperClone(value);
    }
  }
  return new LodashWrapper(value);
}

// Ensure wrappers are instances of `baseLodash`.
lodash.prototype = baseLodash.prototype;
lodash.prototype.constructor = lodash;

/**
 * Checks if `func` has a lazy counterpart.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
 *  else `false`.
 */
function isLaziable(func) {
  var funcName = getFuncName(func),
      other = lodash[funcName];

  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData(other);
  return !!data && func === data[0];
}

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
function now() {
  return Date.now();
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 150;
var HOT_SPAN = 16;

/**
 * Sets metadata for `func`.
 *
 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
 * period of time, it will trip its breaker and transition to an identity
 * function to avoid garbage collection pauses in V8. See
 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
 * for more details.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var setData = (function() {
  var count = 0,
      lastCalled = 0;

  return function(key, value) {
    var stamp = now(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return key;
      }
    } else {
      count = 0;
    }
    return baseSetData(key, value);
  };
}());

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG$3 = 1;
var BIND_KEY_FLAG$2 = 2;
var CURRY_BOUND_FLAG = 4;
var CURRY_FLAG$2 = 8;
var PARTIAL_FLAG$1 = 32;
var PARTIAL_RIGHT_FLAG$1 = 64;

/**
 * Creates a function that wraps `func` to continue currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {Function} wrapFunc The function to create the `func` wrapper.
 * @param {*} placeholder The placeholder value.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  var isCurry = bitmask & CURRY_FLAG$2,
      newHolders = isCurry ? holders : undefined,
      newHoldersRight = isCurry ? undefined : holders,
      newPartials = isCurry ? partials : undefined,
      newPartialsRight = isCurry ? undefined : partials;

  bitmask |= (isCurry ? PARTIAL_FLAG$1 : PARTIAL_RIGHT_FLAG$1);
  bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG$1 : PARTIAL_FLAG$1);

  if (!(bitmask & CURRY_BOUND_FLAG)) {
    bitmask &= ~(BIND_FLAG$3 | BIND_KEY_FLAG$2);
  }
  var newData = [
    func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
    newHoldersRight, argPos, ary, arity
  ];

  var result = wrapFunc.apply(undefined, newData);
  if (isLaziable(func)) {
    setData(result, newData);
  }
  result.placeholder = placeholder;
  return result;
}

/**
 * Gets the argument placeholder value for `func`.
 *
 * @private
 * @param {Function} func The function to inspect.
 * @returns {*} Returns the placeholder value.
 */
function getHolder(func) {
  var object = func;
  return object.placeholder;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Reorder `array` according to the specified indexes where the element at
 * the first index is assigned as the first element, the element at
 * the second index is assigned as the second element, and so on.
 *
 * @private
 * @param {Array} array The array to reorder.
 * @param {Array} indexes The arranged array indexes.
 * @returns {Array} Returns `array`.
 */
function reorder(array, indexes) {
  var arrLength = array.length,
      length = nativeMin(indexes.length, arrLength),
      oldArray = copyArray(array);

  while (length--) {
    var index = indexes[length];
    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
  }
  return array;
}

/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/**
 * Replaces all `placeholder` elements in `array` with an internal placeholder
 * and returns an array of their indexes.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {*} placeholder The placeholder to replace.
 * @returns {Array} Returns the new array of placeholder indexes.
 */
function replaceHolders(array, placeholder) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value === placeholder || value === PLACEHOLDER) {
      array[index] = PLACEHOLDER;
      result[resIndex++] = index;
    }
  }
  return result;
}

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG$2 = 1;
var BIND_KEY_FLAG$1 = 2;
var CURRY_FLAG$1 = 8;
var CURRY_RIGHT_FLAG$1 = 16;
var ARY_FLAG$1 = 128;
var FLIP_FLAG = 512;

/**
 * Creates a function that wraps `func` to invoke it with optional `this`
 * binding of `thisArg`, partial application, and currying.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [partialsRight] The arguments to append to those provided
 *  to the new function.
 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & ARY_FLAG$1,
      isBind = bitmask & BIND_FLAG$2,
      isBindKey = bitmask & BIND_KEY_FLAG$1,
      isCurried = bitmask & (CURRY_FLAG$1 | CURRY_RIGHT_FLAG$1),
      isFlip = bitmask & FLIP_FLAG,
      Ctor = isBindKey ? undefined : createCtorWrapper(func);

  function wrapper() {
    var arguments$1 = arguments;

    var length = arguments.length,
        args = Array(length),
        index = length;

    while (index--) {
      args[index] = arguments$1[index];
    }
    if (isCurried) {
      var placeholder = getHolder(wrapper),
          holdersCount = countHolders(args, placeholder);
    }
    if (partials) {
      args = composeArgs(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders(args, placeholder);
      return createRecurryWrapper(
        func, bitmask, createHybridWrapper, wrapper.placeholder, thisArg,
        args, newHolders, argPos, ary, arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this,
        fn = isBindKey ? thisBinding[func] : func;

    length = args.length;
    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary < length) {
      args.length = ary;
    }
    if (this && this !== root && this instanceof wrapper) {
      fn = Ctor || createCtorWrapper(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}

/**
 * Creates a function that wraps `func` to enable currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {number} arity The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createCurryWrapper(func, bitmask, arity) {
  var Ctor = createCtorWrapper(func);

  function wrapper() {
    var arguments$1 = arguments;

    var length = arguments.length,
        args = Array(length),
        index = length,
        placeholder = getHolder(wrapper);

    while (index--) {
      args[index] = arguments$1[index];
    }
    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
      ? []
      : replaceHolders(args, placeholder);

    length -= holders.length;
    if (length < arity) {
      return createRecurryWrapper(
        func, bitmask, createHybridWrapper, wrapper.placeholder, undefined,
        args, holders, undefined, undefined, arity - length);
    }
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return apply(fn, this, args);
  }
  return wrapper;
}

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG$4 = 1;

/**
 * Creates a function that wraps `func` to invoke it with the `this` binding
 * of `thisArg` and `partials` prepended to the arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} partials The arguments to prepend to those provided to
 *  the new function.
 * @returns {Function} Returns the new wrapped function.
 */
function createPartialWrapper(func, bitmask, thisArg, partials) {
  var isBind = bitmask & BIND_FLAG$4,
      Ctor = createCtorWrapper(func);

  function wrapper() {
    var arguments$1 = arguments;

    var argsIndex = -1,
        argsLength = arguments.length,
        leftIndex = -1,
        leftLength = partials.length,
        args = Array(leftLength + argsLength),
        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments$1[++argsIndex];
    }
    return apply(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}

/** Used as the internal argument placeholder. */
var PLACEHOLDER$1 = '__lodash_placeholder__';

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG$5 = 1;
var BIND_KEY_FLAG$3 = 2;
var CURRY_BOUND_FLAG$1 = 4;
var CURRY_FLAG$3 = 8;
var ARY_FLAG$2 = 128;
var REARG_FLAG = 256;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$1 = Math.min;

/**
 * Merges the function metadata of `source` into `data`.
 *
 * Merging metadata reduces the number of wrappers used to invoke a function.
 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
 * may be applied regardless of execution order. Methods like `_.ary` and
 * `_.rearg` modify function arguments, making the order in which they are
 * executed important, preventing the merging of metadata. However, we make
 * an exception for a safe combined case where curried functions have `_.ary`
 * and or `_.rearg` applied.
 *
 * @private
 * @param {Array} data The destination metadata.
 * @param {Array} source The source metadata.
 * @returns {Array} Returns `data`.
 */
function mergeData(data, source) {
  var bitmask = data[1],
      srcBitmask = source[1],
      newBitmask = bitmask | srcBitmask,
      isCommon = newBitmask < (BIND_FLAG$5 | BIND_KEY_FLAG$3 | ARY_FLAG$2);

  var isCombo =
    ((srcBitmask == ARY_FLAG$2) && (bitmask == CURRY_FLAG$3)) ||
    ((srcBitmask == ARY_FLAG$2) && (bitmask == REARG_FLAG) && (data[7].length <= source[8])) ||
    ((srcBitmask == (ARY_FLAG$2 | REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == CURRY_FLAG$3));

  // Exit early if metadata can't be merged.
  if (!(isCommon || isCombo)) {
    return data;
  }
  // Use source `thisArg` if available.
  if (srcBitmask & BIND_FLAG$5) {
    data[2] = source[2];
    // Set when currying a bound function.
    newBitmask |= bitmask & BIND_FLAG$5 ? 0 : CURRY_BOUND_FLAG$1;
  }
  // Compose partial arguments.
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER$1) : source[4];
  }
  // Compose partial right arguments.
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER$1) : source[6];
  }
  // Use source `argPos` if available.
  value = source[7];
  if (value) {
    data[7] = value;
  }
  // Use source `ary` if it's smaller.
  if (srcBitmask & ARY_FLAG$2) {
    data[8] = data[8] == null ? source[8] : nativeMin$1(data[8], source[8]);
  }
  // Use source `arity` if one is not provided.
  if (data[9] == null) {
    data[9] = source[9];
  }
  // Use source `func` and merge bitmasks.
  data[0] = source[0];
  data[1] = newBitmask;

  return data;
}

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$3 = 'Expected a function';

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1;
var BIND_KEY_FLAG = 2;
var CURRY_FLAG = 8;
var CURRY_RIGHT_FLAG = 16;
var PARTIAL_FLAG = 32;
var PARTIAL_RIGHT_FLAG = 64;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$1 = Math.max;

/**
 * Creates a function that either curries or invokes `func` with optional
 * `this` binding and partially applied arguments.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask of wrapper flags.
 *  The bitmask may be composed of the following flags:
 *     1 - `_.bind`
 *     2 - `_.bindKey`
 *     4 - `_.curry` or `_.curryRight` of a bound function
 *     8 - `_.curry`
 *    16 - `_.curryRight`
 *    32 - `_.partial`
 *    64 - `_.partialRight`
 *   128 - `_.rearg`
 *   256 - `_.ary`
 *   512 - `_.flip`
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to be partially applied.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & BIND_KEY_FLAG;
  if (!isBindKey && typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$3);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
    partials = holders = undefined;
  }
  ary = ary === undefined ? ary : nativeMax$1(toInteger(ary), 0);
  arity = arity === undefined ? arity : toInteger(arity);
  length -= holders ? holders.length : 0;

  if (bitmask & PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials,
        holdersRight = holders;

    partials = holders = undefined;
  }
  var data = isBindKey ? undefined : getData(func);

  var newData = [
    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
    argPos, ary, arity
  ];

  if (data) {
    mergeData(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] == null
    ? (isBindKey ? 0 : func.length)
    : nativeMax$1(newData[9] - length, 0);

  if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
    bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
  }
  if (!bitmask || bitmask == BIND_FLAG) {
    var result = createBaseWrapper(func, bitmask, thisArg);
  } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
    result = createCurryWrapper(func, bitmask, arity);
  } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
    result = createPartialWrapper(func, bitmask, thisArg, partials);
  } else {
    result = createHybridWrapper.apply(undefined, newData);
  }
  var setter = data ? baseSetData : setData;
  return setter(result, newData);
}

/** Used to compose bitmasks for wrapper metadata. */
var ARY_FLAG = 128;

/**
 * Creates a function that invokes `func`, with up to `n` arguments,
 * ignoring any additional arguments.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} func The function to cap arguments for.
 * @param {number} [n=func.length] The arity cap.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the new capped function.
 * @example
 *
 * _.map(['6', '8', '10'], _.ary(parseInt, 1));
 * // => [6, 8, 10]
 */
function ary(func, n, guard) {
  n = guard ? undefined : n;
  n = (func && n == null) ? func.length : n;
  return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : source[key];

    assignValue(object, key, newValue);
  }
  return object;
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject$1(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return rest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/** Used for built-in method references. */
var objectProto$10 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$10;

  return value === proto;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = Object.keys;

/**
 * The base implementation of `_.keys` which doesn't skip the constructor
 * property of prototypes or treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  return nativeKeys(Object(object));
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/** Used for built-in method references. */
var objectProto$11 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$11.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$2 = objectProto$11.toString;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$11.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty$8.call(value, 'callee') &&
    (!propertyIsEnumerable$1.call(value, 'callee') || objectToString$2.call(value) == argsTag);
}

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for built-in method references. */
var objectProto$12 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$3 = objectProto$12.toString;

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString$1(value) {
  return typeof value == 'string' ||
    (!isArray$1(value) && isObjectLike(value) && objectToString$3.call(value) == stringTag);
}

/**
 * Creates an array of index keys for `object` values of arrays,
 * `arguments` objects, and strings, otherwise `null` is returned.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array|null} Returns index keys, else `null`.
 */
function indexKeys(object) {
  var length = object ? object.length : undefined;
  if (isLength(length) &&
      (isArray$1(object) || isString$1(object) || isArguments(object))) {
    return baseTimes(length, String);
  }
  return null;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys$1(object) {
  var isProto = isPrototype(object);
  if (!(isProto || isArrayLike(object))) {
    return baseKeys(object);
  }
  var indexes = indexKeys(object),
      skipIndexes = !!indexes,
      result = indexes || [],
      length = result.length;

  for (var key in object) {
    if (baseHas(object, key) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
        !(isProto && key == 'constructor')) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$9.propertyIsEnumerable;

/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.c = 3;
 * }
 *
 * function Bar() {
 *   this.e = 5;
 * }
 *
 * Foo.prototype.d = 4;
 * Bar.prototype.f = 6;
 *
 * _.assign({ 'a': 1 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3, 'e': 5 }
 */
var assign = createAssigner(function(object, source) {
  if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys$1(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty$7.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

/** Built-in value references. */
var Reflect = root.Reflect;

/**
 * Converts `iterator` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */
function iteratorToArray(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$15 = Object.prototype;

/** Built-in value references. */
var enumerate = Reflect ? Reflect.enumerate : undefined;
var propertyIsEnumerable$3 = objectProto$15.propertyIsEnumerable;

/**
 * The base implementation of `_.keysIn` which doesn't skip the constructor
 * property of prototypes or treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  object = object == null ? object : Object(object);

  var result = [];
  for (var key in object) {
    result.push(key);
  }
  return result;
}

// Fallback for IE < 9 with es6-shim.
if (enumerate && !propertyIsEnumerable$3.call({ 'valueOf': 1 }, 'valueOf')) {
  baseKeysIn = function(object) {
    return iteratorToArray(enumerate(object));
  };
}

var baseKeysIn$1 = baseKeysIn;

/** Used for built-in method references. */
var objectProto$14 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$14.hasOwnProperty;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  var index = -1,
      isProto = isPrototype(object),
      props = baseKeysIn$1(object),
      propsLength = props.length,
      indexes = indexKeys(object),
      skipIndexes = !!indexes,
      result = indexes || [],
      length = result.length;

  while (++index < propsLength) {
    var key = props[index];
    if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty$9.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$13 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable$2 = objectProto$13.propertyIsEnumerable;

/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
var nonEnumShadows$1 = !propertyIsEnumerable$2.call({ 'valueOf': 1 }, 'valueOf');

/**
 * This method is like `_.assign` except that it iterates over own and
 * inherited source properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assign
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * function Bar() {
 *   this.d = 4;
 * }
 *
 * Foo.prototype.c = 3;
 * Bar.prototype.e = 5;
 *
 * _.assignIn({ 'a': 1 }, new Foo, new Bar);
 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }
 */
var assignIn = createAssigner(function(object, source) {
  if (nonEnumShadows$1 || isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keysIn(source), object);
    return;
  }
  for (var key in source) {
    assignValue(object, key, source[key]);
  }
});

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

/**
 * This method is like `_.assign` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignInWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keys$1(source), object, customizer);
});

/**
 * The base implementation of `_.at` without support for individual paths.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {string[]} paths The property paths of elements to pick.
 * @returns {Array} Returns the picked elements.
 */
function baseAt(object, paths) {
  var index = -1,
      isNil = object == null,
      length = paths.length,
      result = Array(length);

  while (++index < length) {
    result[index] = isNil ? undefined : get(object, paths[index]);
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray$1(value) || isArguments(value);
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * Creates an array of values corresponding to `paths` of `object`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {...(string|string[])} [paths] The property paths of elements to pick.
 * @returns {Array} Returns the picked values.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
 *
 * _.at(object, ['a[0].b.c', 'a[1]']);
 * // => [3, 4]
 */
var at = rest(function(object, paths) {
  return baseAt(object, baseFlatten(paths, 1));
});

/** `Object#toString` result references. */
var errorTag = '[object Error]';

/** Used for built-in method references. */
var objectProto$16 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$4 = objectProto$16.toString;

/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object,
 *  else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  return (objectToString$4.call(value) == errorTag) ||
    (typeof value.message == 'string' && typeof value.name == 'string');
}

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt = rest(function(func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$4 = 'Expected a function';

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => allows adding up to 4 contacts to the list
 */
function before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$4);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG$6 = 1;
var PARTIAL_FLAG$2 = 32;

/**
 * Creates a function that invokes `func` with the `this` binding of `thisArg`
 * and `partials` prepended to the arguments it receives.
 *
 * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
 * may be used as a placeholder for partially applied arguments.
 *
 * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
 * property of bound functions.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new bound function.
 * @example
 *
 * var greet = function(greeting, punctuation) {
 *   return greeting + ' ' + this.user + punctuation;
 * };
 *
 * var object = { 'user': 'fred' };
 *
 * var bound = _.bind(greet, object, 'hi');
 * bound('!');
 * // => 'hi fred!'
 *
 * // Bound with placeholders.
 * var bound = _.bind(greet, object, _, '!');
 * bound('hi');
 * // => 'hi fred!'
 */
var bind = rest(function(func, thisArg, partials) {
  var bitmask = BIND_FLAG$6;
  if (partials.length) {
    var holders = replaceHolders(partials, getHolder(bind));
    bitmask |= PARTIAL_FLAG$2;
  }
  return createWrapper(func, bitmask, thisArg, partials, holders);
});

// Assign default placeholders.
bind.placeholder = {};

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Binds methods of an object to the object itself, overwriting the existing
 * method.
 *
 * **Note:** This method doesn't set the "length" property of bound functions.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {Object} object The object to bind and assign the bound methods to.
 * @param {...(string|string[])} methodNames The object method names to bind.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var view = {
 *   'label': 'docs',
 *   'onClick': function() {
 *     console.log('clicked ' + this.label);
 *   }
 * };
 *
 * _.bindAll(view, ['onClick']);
 * jQuery(element).on('click', view.onClick);
 * // => Logs 'clicked docs' when clicked.
 */
var bindAll = rest(function(object, methodNames) {
  arrayEach(baseFlatten(methodNames, 1), function(key) {
    key = toKey(key);
    object[key] = bind(object[key], object);
  });
  return object;
});

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG$7 = 1;
var BIND_KEY_FLAG$4 = 2;
var PARTIAL_FLAG$3 = 32;

/**
 * Creates a function that invokes the method at `object[key]` with `partials`
 * prepended to the arguments it receives.
 *
 * This method differs from `_.bind` by allowing bound functions to reference
 * methods that may be redefined or don't yet exist. See
 * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
 * for more details.
 *
 * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
 * builds, may be used as a placeholder for partially applied arguments.
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Function
 * @param {Object} object The object to invoke the method on.
 * @param {string} key The key of the method.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new bound function.
 * @example
 *
 * var object = {
 *   'user': 'fred',
 *   'greet': function(greeting, punctuation) {
 *     return greeting + ' ' + this.user + punctuation;
 *   }
 * };
 *
 * var bound = _.bindKey(object, 'greet', 'hi');
 * bound('!');
 * // => 'hi fred!'
 *
 * object.greet = function(greeting, punctuation) {
 *   return greeting + 'ya ' + this.user + punctuation;
 * };
 *
 * bound('!');
 * // => 'hiya fred!'
 *
 * // Bound with placeholders.
 * var bound = _.bindKey(object, 'greet', _, '!');
 * bound('hi');
 * // => 'hiya fred!'
 */
var bindKey = rest(function(object, key, partials) {
  var bitmask = BIND_FLAG$7 | BIND_KEY_FLAG$4;
  if (partials.length) {
    var holders = replaceHolders(partials, getHolder(bindKey));
    bitmask |= PARTIAL_FLAG$3;
  }
  return createWrapper(key, bitmask, object, partials, holders);
});

// Assign default placeholders.
bindKey.placeholder = {};

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff';
var rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23';
var rsComboSymbolsRange = '\\u20d0-\\u20f0';
var rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

/** Used to compose unicode character classes. */
var rsAstralRange$1 = '\\ud800-\\udfff';
var rsComboMarksRange$1 = '\\u0300-\\u036f\\ufe20-\\ufe23';
var rsComboSymbolsRange$1 = '\\u20d0-\\u20f0';
var rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange$1 + ']';
var rsCombo = '[' + rsComboMarksRange$1 + rsComboSymbolsRange$1 + ']';
var rsFitz = '\\ud83c[\\udffb-\\udfff]';
var rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';
var rsNonAstral = '[^' + rsAstralRange$1 + ']';
var rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}';
var rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]';
var rsZWJ$1 = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?';
var rsOptVar = '[' + rsVarRange$1 + ']?';
var rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return string.match(reComplexSymbol);
}

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = reHasComplexSymbol.test(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/** Used to map latin-1 supplementary letters to basic latin letters. */
var deburredLetters = {
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss'
};

/**
 * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
function deburrLetter(letter) {
  return deburredLetters[letter];
}

/** Used to match latin-1 supplementary letters (excluding mathematical operators). */
var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange$2 = '\\u0300-\\u036f\\ufe20-\\ufe23';
var rsComboSymbolsRange$2 = '\\u20d0-\\u20f0';

/** Used to compose unicode capture groups. */
var rsCombo$1 = '[' + rsComboMarksRange$2 + rsComboSymbolsRange$2 + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo$1, 'g');

/**
 * Deburrs `string` by converting
 * [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * to basic latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
}

/** Used to match non-compound words composed of alphanumeric characters. */
var reBasicWord = /[a-zA-Z0-9]+/g;

/** Used to compose unicode character classes. */
var rsAstralRange$2 = '\\ud800-\\udfff';
var rsComboMarksRange$3 = '\\u0300-\\u036f\\ufe20-\\ufe23';
var rsComboSymbolsRange$3 = '\\u20d0-\\u20f0';
var rsDingbatRange = '\\u2700-\\u27bf';
var rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff';
var rsMathOpRange = '\\xac\\xb1\\xd7\\xf7';
var rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf';
var rsPunctuationRange = '\\u2000-\\u206f';
var rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000';
var rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde';
var rsVarRange$2 = '\\ufe0e\\ufe0f';
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos$1 = "['\u2019]";
var rsBreak = '[' + rsBreakRange + ']';
var rsCombo$2 = '[' + rsComboMarksRange$3 + rsComboSymbolsRange$3 + ']';
var rsDigits = '\\d+';
var rsDingbat = '[' + rsDingbatRange + ']';
var rsLower = '[' + rsLowerRange + ']';
var rsMisc = '[^' + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']';
var rsFitz$1 = '\\ud83c[\\udffb-\\udfff]';
var rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')';
var rsNonAstral$1 = '[^' + rsAstralRange$2 + ']';
var rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}';
var rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]';
var rsUpper = '[' + rsUpperRange + ']';
var rsZWJ$2 = '\\u200d';

/** Used to compose unicode regexes. */
var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')';
var rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')';
var rsOptLowerContr = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?';
var rsOptUpperContr = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?';
var reOptMod$1 = rsModifier$1 + '?';
var rsOptVar$1 = '[' + rsVarRange$2 + ']?';
var rsOptJoin$1 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*';
var rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1;
var rsEmoji = '(?:' + [rsDingbat, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsSeq$1;

/** Used to match complex or compound words. */
var reComplexWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
  rsUpper + '+' + rsOptUpperContr,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/** Used to detect strings that need a more robust regexp to match words. */
var reHasComplexWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;
  }
  return string.match(pattern) || [];
}

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

/**
 * Casts `value` as an array if it's not one.
 *
 * @static
 * @memberOf _
 * @since 4.4.0
 * @category Lang
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast array.
 * @example
 *
 * _.castArray(1);
 * // => [1]
 *
 * _.castArray({ 'a': 1 });
 * // => [{ 'a': 1 }]
 *
 * _.castArray('abc');
 * // => ['abc']
 *
 * _.castArray(null);
 * // => [null]
 *
 * _.castArray(undefined);
 * // => [undefined]
 *
 * _.castArray();
 * // => []
 *
 * var array = [1, 2, 3];
 * console.log(_.castArray(array) === array);
 * // => true
 */
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray$1(value) ? value : [value];
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$2 = Math.min;

/**
 * Creates a function like `_.round`.
 *
 * @private
 * @param {string} methodName The name of the `Math` method to use when rounding.
 * @returns {Function} Returns the new round function.
 */
function createRound(methodName) {
  var func = Math[methodName];
  return function(number, precision) {
    number = toNumber(number);
    precision = nativeMin$2(toInteger(precision), 292);
    if (precision) {
      // Shift with exponential notation to avoid floating-point issues.
      // See [MDN](https://mdn.io/round#Examples) for more details.
      var pair = (toString(number) + 'e').split('e'),
          value = func(pair[0] + 'e' + (+pair[1] + precision));

      pair = (toString(value) + 'e').split('e');
      return +(pair[0] + 'e' + (+pair[1] - precision));
    }
    return func(number);
  };
}

/**
 * Computes `number` rounded up to `precision`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round up.
 * @param {number} [precision=0] The precision to round up to.
 * @returns {number} Returns the rounded up number.
 * @example
 *
 * _.ceil(4.006);
 * // => 5
 *
 * _.ceil(6.004, 2);
 * // => 6.01
 *
 * _.ceil(6040, -2);
 * // => 6100
 */
var ceil = createRound('ceil');

/**
 * Creates a `lodash` wrapper instance that wraps `value` with explicit method
 * chain sequences enabled. The result of such sequences must be unwrapped
 * with `_#value`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Seq
 * @param {*} value The value to wrap.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36 },
 *   { 'user': 'fred',    'age': 40 },
 *   { 'user': 'pebbles', 'age': 1 }
 * ];
 *
 * var youngest = _
 *   .chain(users)
 *   .sortBy('age')
 *   .map(function(o) {
 *     return o.user + ' is ' + o.age;
 *   })
 *   .head()
 *   .value();
 * // => 'pebbles is 1'
 */
function chain(value) {
  var result = lodash(value);
  result.__chain__ = true;
  return result;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil;
var nativeMax$4 = Math.max;

/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */
function chunk(array, size, guard) {
  if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
    size = 1;
  } else {
    size = nativeMax$4(toInteger(size), 0);
  }
  var length = array ? array.length : 0;
  if (!length || size < 1) {
    return [];
  }
  var index = 0,
      resIndex = 0,
      result = Array(nativeCeil(length / size));

  while (index < length) {
    result[resIndex++] = baseSlice(array, index, (index += size));
  }
  return result;
}

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments to numbers.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

/**
 * Clamps `number` within the inclusive `lower` and `upper` bounds.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * _.clamp(-10, -5, 5);
 * // => -5
 *
 * _.clamp(10, -5, 5);
 * // => 5
 */
function clamp(number, lower, upper) {
  if (upper === undefined) {
    upper = lower;
    lower = undefined;
  }
  if (upper !== undefined) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== undefined) {
    lower = toNumber(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp(toNumber(number), lower, upper);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$1 = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE$1) {
    cache = this.__data__ = new MapCache(cache.__data__);
  }
  cache.set(key, value);
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys$1(source), object);
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * A method that returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Built-in value references. */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
function getSymbols(object) {
  // Coerce `object` to an object to avoid non-object errors in V8.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=3443 for more details.
  return getOwnPropertySymbols(Object(object));
}

// Fallback for IE < 11.
if (!getOwnPropertySymbols) {
  getSymbols = stubArray;
}

var getSymbols$1 = getSymbols;

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols$1(source), object);
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys$1, getSymbols$1);
}

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

/* Built-in method references that are verified to be native. */
var Promise$1 = getNative(root, 'Promise');

/* Built-in method references that are verified to be native. */
var Set$1 = getNative(root, 'Set');

/** `Object#toString` result references. */
var mapTag$1 = '[object Map]';
var objectTag$1 = '[object Object]';
var promiseTag = '[object Promise]';
var setTag$1 = '[object Set]';
var weakMapTag$1 = '[object WeakMap]';

var dataViewTag$1 = '[object DataView]';

/** Used for built-in method references. */
var objectProto$17 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$5 = objectProto$17.toString;

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map$1);
var promiseCtorString = toSource(Promise$1);
var setCtorString = toSource(Set$1);
var weakMapCtorString = toSource(WeakMap$1);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function getTag(value) {
  return objectToString$5.call(value);
}

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1) ||
    (Map$1 && getTag(new Map$1) != mapTag$1) ||
    (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
    (Set$1 && getTag(new Set$1) != setTag$1) ||
    (WeakMap$1 && getTag(new WeakMap$1) != weakMapTag$1)) {
  getTag = function(value) {
    var result = objectToString$5.call(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$1;
        case mapCtorString: return mapTag$1;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$1;
        case weakMapCtorString: return weakMapTag$1;
      }
    }
    return result;
  };
}

var getTag$1 = getTag;

/** Used for built-in method references. */
var objectProto$18 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$10 = objectProto$18.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty$10.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `Map#set` because it doesn't return the map instance in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  set.add(value);
  return set;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = Symbol ? Symbol.prototype : undefined;
var symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/** `Object#toString` result references. */
var boolTag$1 = '[object Boolean]';
var dateTag$1 = '[object Date]';
var mapTag$2 = '[object Map]';
var numberTag$1 = '[object Number]';
var regexpTag$1 = '[object RegExp]';
var setTag$2 = '[object Set]';
var stringTag$2 = '[object String]';
var symbolTag$2 = '[object Symbol]';

var arrayBufferTag$1 = '[object ArrayBuffer]';
var dataViewTag$2 = '[object DataView]';
var float32Tag$1 = '[object Float32Array]';
var float64Tag$1 = '[object Float64Array]';
var int8Tag$1 = '[object Int8Array]';
var int16Tag$1 = '[object Int16Array]';
var int32Tag$1 = '[object Int32Array]';
var uint8Tag$1 = '[object Uint8Array]';
var uint8ClampedTag$1 = '[object Uint8ClampedArray]';
var uint16Tag$1 = '[object Uint16Array]';
var uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);

    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);

    case dataViewTag$2:
      return cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return cloneTypedArray(object, isDeep);

    case mapTag$2:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag$1:
    case stringTag$2:
      return new Ctor(object);

    case regexpTag$1:
      return cloneRegExp(object);

    case setTag$2:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag$2:
      return cloneSymbol(object);
  }
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * A method that returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = !Buffer ? stubFalse : function(value) {
  return value instanceof Buffer;
};

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]';
var arrayTag = '[object Array]';
var boolTag = '[object Boolean]';
var dateTag = '[object Date]';
var errorTag$1 = '[object Error]';
var funcTag$1 = '[object Function]';
var genTag$1 = '[object GeneratorFunction]';
var mapTag = '[object Map]';
var numberTag = '[object Number]';
var objectTag = '[object Object]';
var regexpTag = '[object RegExp]';
var setTag = '[object Set]';
var stringTag$1 = '[object String]';
var symbolTag$1 = '[object Symbol]';
var weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]';
var dataViewTag = '[object DataView]';
var float32Tag = '[object Float32Array]';
var float64Tag = '[object Float64Array]';
var int8Tag = '[object Int8Array]';
var int16Tag = '[object Int16Array]';
var int32Tag = '[object Int32Array]';
var uint8Tag = '[object Uint8Array]';
var uint8ClampedTag = '[object Uint8ClampedArray]';
var uint16Tag = '[object Uint16Array]';
var uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag$1] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject$1(value)) {
    return value;
  }
  var isArr = isArray$1(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value),
        isFunc = tag == funcTag$1 || tag == genTag$1;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag$1 || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys$1(value);
  }
  // Recursively populate clone (susceptible to call stack limits).
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone$2(value) {
  return baseClone(value, false, true);
}

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep$2(value) {
  return baseClone(value, true, true);
}

/**
 * This method is like `_.cloneWith` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @param {Function} [customizer] The function to customize cloning.
 * @returns {*} Returns the deep cloned value.
 * @see _.cloneWith
 * @example
 *
 * function customizer(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(true);
 *   }
 * }
 *
 * var el = _.cloneDeepWith(document.body, customizer);
 *
 * console.log(el === document.body);
 * // => false
 * console.log(el.nodeName);
 * // => 'BODY'
 * console.log(el.childNodes.length);
 * // => 20
 */
function cloneDeepWith(value, customizer) {
  return baseClone(value, true, true, customizer);
}

/**
 * This method is like `_.clone` except that it accepts `customizer` which
 * is invoked to produce the cloned value. If `customizer` returns `undefined`,
 * cloning is handled by the method instead. The `customizer` is invoked with
 * up to four arguments; (value [, index|key, object, stack]).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to clone.
 * @param {Function} [customizer] The function to customize cloning.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeepWith
 * @example
 *
 * function customizer(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(false);
 *   }
 * }
 *
 * var el = _.cloneWith(document.body, customizer);
 *
 * console.log(el === document.body);
 * // => false
 * console.log(el.nodeName);
 * // => 'BODY'
 * console.log(el.childNodes.length);
 * // => 0
 */
function cloneWith(value, customizer) {
  return baseClone(value, false, true, customizer);
}

/**
 * Executes the chain sequence and returns the wrapped result.
 *
 * @name commit
 * @memberOf _
 * @since 3.2.0
 * @category Seq
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * var array = [1, 2];
 * var wrapped = _(array).push(3);
 *
 * console.log(array);
 * // => [1, 2]
 *
 * wrapped = wrapped.commit();
 * console.log(array);
 * // => [1, 2, 3]
 *
 * wrapped.last();
 * // => 3
 *
 * console.log(array);
 * // => [1, 2, 3]
 */
function wrapperCommit() {
  return new LodashWrapper(this.value(), this.__chain__);
}

/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */
function compact(array) {
  var index = -1,
      length = array ? array.length : 0,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * Creates a new array concatenating `array` with any additional arrays
 * and/or values.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to concatenate.
 * @param {...*} [values] The values to concatenate.
 * @returns {Array} Returns the new concatenated array.
 * @example
 *
 * var array = [1];
 * var other = _.concat(array, 2, [3], [[4]]);
 *
 * console.log(other);
 * // => [1, 2, 3, [4]]
 *
 * console.log(array);
 * // => [1]
 */
function concat() {
  var arguments$1 = arguments;

  var length = arguments.length,
      args = Array(length ? length - 1 : 0),
      array = arguments[0],
      index = length;

  while (index--) {
    args[index - 1] = arguments$1[index];
  }
  return length
    ? arrayPush(isArray$1(array) ? copyArray(array) : [array], baseFlatten(args, 1))
    : [];
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG$1 = 1;
var PARTIAL_COMPARE_FLAG$2 = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG$2,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG$1) ? new SetCache : undefined;

  stack.set(array, other);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  return result;
}

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG$2 = 1;
var PARTIAL_COMPARE_FLAG$3 = 2;

/** `Object#toString` result references. */
var boolTag$2 = '[object Boolean]';
var dateTag$2 = '[object Date]';
var errorTag$2 = '[object Error]';
var mapTag$3 = '[object Map]';
var numberTag$2 = '[object Number]';
var regexpTag$2 = '[object RegExp]';
var setTag$3 = '[object Set]';
var stringTag$3 = '[object String]';
var symbolTag$3 = '[object Symbol]';

var arrayBufferTag$2 = '[object ArrayBuffer]';
var dataViewTag$3 = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto$2 = Symbol ? Symbol.prototype : undefined;
var symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag$3:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$2:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag$2:
    case dateTag$2:
      // Coerce dates and booleans to numbers, dates to milliseconds and
      // booleans to `1` or `0` treating invalid dates coerced to `NaN` as
      // not equal.
      return +object == +other;

    case errorTag$2:
      return object.name == other.name && object.message == other.message;

    case numberTag$2:
      // Treat `NaN` vs. `NaN` as equal.
      return (object != +object) ? other != +other : object == +other;

    case regexpTag$2:
    case stringTag$3:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag$3:
      var convert = mapToArray;

    case setTag$3:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG$3;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG$2;
      stack.set(object, other);

      // Recursively compare objects (susceptible to call stack limits).
      return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);

    case symbolTag$3:
      if (symbolValueOf$1) {
        return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
      }
  }
  return false;
}

/** Used to compose bitmasks for comparison styles. */
var PARTIAL_COMPARE_FLAG$4 = 2;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG$4,
      objProps = keys$1(object),
      objLength = objProps.length,
      othProps = keys$1(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : baseHas(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  return result;
}

/** `Object#toString` result references. */
var argsTag$3 = '[object Arguments]';
var arrayTag$2 = '[object Array]';
var boolTag$3 = '[object Boolean]';
var dateTag$3 = '[object Date]';
var errorTag$3 = '[object Error]';
var funcTag$2 = '[object Function]';
var mapTag$4 = '[object Map]';
var numberTag$3 = '[object Number]';
var objectTag$3 = '[object Object]';
var regexpTag$3 = '[object RegExp]';
var setTag$4 = '[object Set]';
var stringTag$4 = '[object String]';
var weakMapTag$2 = '[object WeakMap]';

var arrayBufferTag$3 = '[object ArrayBuffer]';
var dataViewTag$4 = '[object DataView]';
var float32Tag$2 = '[object Float32Array]';
var float64Tag$2 = '[object Float64Array]';
var int8Tag$2 = '[object Int8Array]';
var int16Tag$2 = '[object Int16Array]';
var int32Tag$2 = '[object Int32Array]';
var uint8Tag$2 = '[object Uint8Array]';
var uint8ClampedTag$2 = '[object Uint8ClampedArray]';
var uint16Tag$2 = '[object Uint16Array]';
var uint32Tag$2 = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$3] = typedArrayTags[arrayTag$2] =
typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] =
typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] =
typedArrayTags[errorTag$3] = typedArrayTags[funcTag$2] =
typedArrayTags[mapTag$4] = typedArrayTags[numberTag$3] =
typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] =
typedArrayTags[setTag$4] = typedArrayTags[stringTag$4] =
typedArrayTags[weakMapTag$2] = false;

/** Used for built-in method references. */
var objectProto$20 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$6 = objectProto$20.toString;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString$6.call(value)];
}

/** Used to compose bitmasks for comparison styles. */
var PARTIAL_COMPARE_FLAG$1 = 2;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]';
var arrayTag$1 = '[object Array]';
var objectTag$2 = '[object Object]';

/** Used for built-in method references. */
var objectProto$19 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$11 = objectProto$19.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray$1(object),
      othIsArr = isArray$1(other),
      objTag = arrayTag$1,
      othTag = arrayTag$1;

  if (!objIsArr) {
    objTag = getTag$1(object);
    objTag = objTag == argsTag$2 ? objectTag$2 : objTag;
  }
  if (!othIsArr) {
    othTag = getTag$1(other);
    othTag = othTag == argsTag$2 ? objectTag$2 : othTag;
  }
  var objIsObj = objTag == objectTag$2 && !isHostObject(object),
      othIsObj = othTag == objectTag$2 && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG$1)) {
    var objIsWrapped = objIsObj && hasOwnProperty$11.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$11.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject$1(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1;
var PARTIAL_COMPARE_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject$1(value);
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys$1(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = isKey(path, object) ? [path] : castPath(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray$1(object) || isString$1(object) || isArguments(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG$3 = 1;
var PARTIAL_COMPARE_FLAG$5 = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG$3 | PARTIAL_COMPARE_FLAG$5);
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray$1(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$5 = 'Expected a function';

/**
 * Creates a function that iterates over `pairs` and invokes the corresponding
 * function of the first predicate to return truthy. The predicate-function
 * pairs are invoked with the `this` binding and arguments of the created
 * function.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {Array} pairs The predicate-function pairs.
 * @returns {Function} Returns the new composite function.
 * @example
 *
 * var func = _.cond([
 *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
 *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
 *   [_.constant(true),                _.constant('no match')]
 * ]);
 *
 * func({ 'a': 1, 'b': 2 });
 * // => 'matches A'
 *
 * func({ 'a': 0, 'b': 1 });
 * // => 'matches B'
 *
 * func({ 'a': '1', 'b': '2' });
 * // => 'no match'
 */
function cond(pairs) {
  var length = pairs ? pairs.length : 0,
      toIteratee = baseIteratee;

  pairs = !length ? [] : arrayMap(pairs, function(pair) {
    if (typeof pair[1] != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$5);
    }
    return [toIteratee(pair[0]), pair[1]];
  });

  return rest(function(args) {
    var this$1 = this;

    var index = -1;
    while (++index < length) {
      var pair = pairs[index];
      if (apply(pair[0], this$1, args)) {
        return apply(pair[1], this$1, args);
      }
    }
  });
}

/**
 * The base implementation of `_.conforms` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property predicates to conform to.
 * @returns {Function} Returns the new spec function.
 */
function baseConforms(source) {
  var props = keys$1(source),
      length = props.length;

  return function(object) {
    if (object == null) {
      return !length;
    }
    var index = length;
    while (index--) {
      var key = props[index],
          predicate = source[key],
          value = object[key];

      if ((value === undefined &&
          !(key in Object(object))) || !predicate(value)) {
        return false;
      }
    }
    return true;
  };
}

/**
 * Creates a function that invokes the predicate properties of `source` with
 * the corresponding property values of a given object, returning `true` if
 * all predicates return truthy, else `false`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {Object} source The object of property predicates to conform to.
 * @returns {Function} Returns the new spec function.
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 }
 * ];
 *
 * _.filter(users, _.conforms({ 'age': function(n) { return n > 38; } }));
 * // => [{ 'user': 'fred', 'age': 40 }]
 */
function conforms(source) {
  return baseConforms(baseClone(source, true));
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys$1);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach(collection, function(value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray$1(collection) ? arrayAggregator : baseAggregator,
        accumulator = initializer ? initializer() : {};

    return func(collection, setter, baseIteratee(iteratee), accumulator);
  };
}

/** Used for built-in method references. */
var objectProto$21 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$12 = objectProto$21.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The corresponding value of
 * each key is the number of times the key was returned by `iteratee`. The
 * iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.countBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': 1, '6': 2 }
 *
 * // The `_.property` iteratee shorthand.
 * _.countBy(['one', 'two', 'three'], 'length');
 * // => { '3': 2, '5': 1 }
 */
var countBy = createAggregator(function(result, value, key) {
  hasOwnProperty$12.call(result, key) ? ++result[key] : (result[key] = 1);
});

/**
 * Creates an object that inherits from the `prototype` object. If a
 * `properties` object is given, its own enumerable string keyed properties
 * are assigned to the created object.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Object
 * @param {Object} prototype The object to inherit from.
 * @param {Object} [properties] The properties to assign to the object.
 * @returns {Object} Returns the new object.
 * @example
 *
 * function Shape() {
 *   this.x = 0;
 *   this.y = 0;
 * }
 *
 * function Circle() {
 *   Shape.call(this);
 * }
 *
 * Circle.prototype = _.create(Shape.prototype, {
 *   'constructor': Circle
 * });
 *
 * var circle = new Circle;
 * circle instanceof Circle;
 * // => true
 *
 * circle instanceof Shape;
 * // => true
 */
function create(prototype, properties) {
  var result = baseCreate(prototype);
  return properties ? baseAssign(result, properties) : result;
}

/** Used to compose bitmasks for wrapper metadata. */
var CURRY_FLAG$4 = 8;

/**
 * Creates a function that accepts arguments of `func` and either invokes
 * `func` returning its result, if at least `arity` number of arguments have
 * been provided, or returns a function that accepts the remaining `func`
 * arguments, and so on. The arity of `func` may be specified if `func.length`
 * is not sufficient.
 *
 * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
 * may be used as a placeholder for provided arguments.
 *
 * **Note:** This method doesn't set the "length" property of curried functions.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Function
 * @param {Function} func The function to curry.
 * @param {number} [arity=func.length] The arity of `func`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the new curried function.
 * @example
 *
 * var abc = function(a, b, c) {
 *   return [a, b, c];
 * };
 *
 * var curried = _.curry(abc);
 *
 * curried(1)(2)(3);
 * // => [1, 2, 3]
 *
 * curried(1, 2)(3);
 * // => [1, 2, 3]
 *
 * curried(1, 2, 3);
 * // => [1, 2, 3]
 *
 * // Curried with placeholders.
 * curried(1)(_, 3)(2);
 * // => [1, 2, 3]
 */
function curry(func, arity, guard) {
  arity = guard ? undefined : arity;
  var result = createWrapper(func, CURRY_FLAG$4, undefined, undefined, undefined, undefined, undefined, arity);
  result.placeholder = curry.placeholder;
  return result;
}

// Assign default placeholders.
curry.placeholder = {};

/** Used to compose bitmasks for wrapper metadata. */
var CURRY_RIGHT_FLAG$2 = 16;

/**
 * This method is like `_.curry` except that arguments are applied to `func`
 * in the manner of `_.partialRight` instead of `_.partial`.
 *
 * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
 * builds, may be used as a placeholder for provided arguments.
 *
 * **Note:** This method doesn't set the "length" property of curried functions.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} func The function to curry.
 * @param {number} [arity=func.length] The arity of `func`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the new curried function.
 * @example
 *
 * var abc = function(a, b, c) {
 *   return [a, b, c];
 * };
 *
 * var curried = _.curryRight(abc);
 *
 * curried(3)(2)(1);
 * // => [1, 2, 3]
 *
 * curried(2, 3)(1);
 * // => [1, 2, 3]
 *
 * curried(1, 2, 3);
 * // => [1, 2, 3]
 *
 * // Curried with placeholders.
 * curried(3)(1, _)(2);
 * // => [1, 2, 3]
 */
function curryRight(func, arity, guard) {
  arity = guard ? undefined : arity;
  var result = createWrapper(func, CURRY_RIGHT_FLAG$2, undefined, undefined, undefined, undefined, undefined, arity);
  result.placeholder = curryRight.placeholder;
  return result;
}

// Assign default placeholders.
curryRight.placeholder = {};

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$6 = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$5 = Math.max;
var nativeMin$3 = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide an options object to indicate whether `func` should be invoked on
 * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent calls
 * to the debounced function return the result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
 * on the trailing edge of the timeout only if the debounced function is
 * invoked more than once during the `wait` timeout.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$6);
  }
  wait = toNumber(wait) || 0;
  if (isObject$1(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax$5(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin$3(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/** Used for built-in method references. */
var objectProto$22 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$13 = objectProto$22.hasOwnProperty;

/**
 * Used by `_.defaults` to customize its `_.assignIn` use.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function assignInDefaults(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto$22[key]) && !hasOwnProperty$13.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
var defaults = rest(function(args) {
  args.push(undefined, assignInDefaults);
  return apply(assignInWith, undefined, args);
});

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (typeof key == 'number' && value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/** `Object#toString` result references. */
var objectTag$4 = '[object Object]';

/** Used for built-in method references. */
var objectProto$23 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$14 = objectProto$23.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString$2.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$7 = objectProto$23.toString;

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object,
 *  else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject$1(value) {
  if (!isObjectLike(value) ||
      objectToString$7.call(value) != objectTag$4 || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$14.call(proto, 'constructor') && proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString);
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    newValue = srcValue;
    if (isArray$1(srcValue) || isTypedArray(srcValue)) {
      if (isArray$1(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else {
        isCommon = false;
        newValue = baseClone(srcValue, true);
      }
    }
    else if (isPlainObject$1(srcValue) || isArguments(srcValue)) {
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject$1(objValue) || (srcIndex && isFunction(objValue))) {
        isCommon = false;
        newValue = baseClone(srcValue, true);
      }
      else {
        newValue = objValue;
      }
    }
    else {
      isCommon = false;
    }
  }
  stack.set(srcValue, newValue);

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
  }
  stack['delete'](srcValue);
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  if (!(isArray$1(source) || isTypedArray(source))) {
    var props = keysIn(source);
  }
  arrayEach(props || source, function(srcValue, key) {
    if (props) {
      key = srcValue;
      srcValue = source[key];
    }
    if (isObject$1(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  });
}

/**
 * Used by `_.defaultsDeep` to customize its `_.merge` use.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to merge.
 * @param {Object} object The parent object of `objValue`.
 * @param {Object} source The parent object of `srcValue`.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 * @returns {*} Returns the value to assign.
 */
function mergeDefaults(objValue, srcValue, key, object, source, stack) {
  if (isObject$1(objValue) && isObject$1(srcValue)) {
    baseMerge(objValue, srcValue, undefined, mergeDefaults, stack.set(srcValue, objValue));
  }
  return objValue;
}

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with seven arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = {
 *   'fruits': ['apple'],
 *   'vegetables': ['beet']
 * };
 *
 * var other = {
 *   'fruits': ['banana'],
 *   'vegetables': ['carrot']
 * };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

/**
 * This method is like `_.defaults` except that it recursively assigns
 * default properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaults
 * @example
 *
 * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
 * // => { 'user': { 'name': 'barney', 'age': 36 } }
 *
 */
var defaultsDeep = rest(function(args) {
  args.push(undefined, mergeDefaults);
  return apply(mergeWith, undefined, args);
});

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$7 = 'Expected a function';

/**
 * The base implementation of `_.delay` and `_.defer` which accepts an array
 * of `func` arguments.
 *
 * @private
 * @param {Function} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {Object} args The arguments to provide to `func`.
 * @returns {number} Returns the timer id.
 */
function baseDelay(func, wait, args) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$7);
  }
  return setTimeout(function() { func.apply(undefined, args); }, wait);
}

/**
 * Defers invoking the `func` until the current call stack has cleared. Any
 * additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to defer.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {number} Returns the timer id.
 * @example
 *
 * _.defer(function(text) {
 *   console.log(text);
 * }, 'deferred');
 * // => Logs 'deferred' after one or more milliseconds.
 */
var defer = rest(function(func, args) {
  return baseDelay(func, 1, args);
});

/**
 * Invokes `func` after `wait` milliseconds. Any additional arguments are
 * provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {number} Returns the timer id.
 * @example
 *
 * _.delay(function(text) {
 *   console.log(text);
 * }, 1000, 'later');
 * // => Logs 'later' after one second.
 */
var delay = rest(function(func, wait, args) {
  return baseDelay(func, toNumber(wait) || 0, args);
});

/**
 * Creates an array of unique `array` values not included in the other given
 * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons. The order of result values is determined by the
 * order they occur in the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = rest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
    : [];
});

/**
 * This method is like `_.difference` except that it accepts `iteratee` which
 * is invoked for each element of `array` and `values` to generate the criterion
 * by which they're compared. Result values are chosen from the first array.
 * The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
 * // => [1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
 * // => [{ 'x': 2 }]
 */
var differenceBy = rest(function(array, values) {
  var iteratee = last(values);
  if (isArrayLikeObject(iteratee)) {
    iteratee = undefined;
  }
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), baseIteratee(iteratee))
    : [];
});

/**
 * This method is like `_.difference` except that it accepts `comparator`
 * which is invoked to compare elements of `array` to `values`. Result values
 * are chosen from the first array. The comparator is invoked with two arguments:
 * (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 *
 * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
 * // => [{ 'x': 2, 'y': 1 }]
 */
var differenceWith = rest(function(array, values) {
  var comparator = last(values);
  if (isArrayLikeObject(comparator)) {
    comparator = undefined;
  }
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
    : [];
});

/**
 * Divide two numbers.
 *
 * @static
 * @memberOf _
 * @since 4.7.0
 * @category Math
 * @param {number} dividend The first number in a division.
 * @param {number} divisor The second number in a division.
 * @returns {number} Returns the quotient.
 * @example
 *
 * _.divide(6, 4);
 * // => 1.5
 */
var divide$1$1 = createMathOperation(function(dividend, divisor) {
  return dividend / divisor;
});

/**
 * Creates a slice of `array` with `n` elements dropped from the beginning.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.drop([1, 2, 3]);
 * // => [2, 3]
 *
 * _.drop([1, 2, 3], 2);
 * // => [3]
 *
 * _.drop([1, 2, 3], 5);
 * // => []
 *
 * _.drop([1, 2, 3], 0);
 * // => [1, 2, 3]
 */
function drop(array, n, guard) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : toInteger(n);
  return baseSlice(array, n < 0 ? 0 : n, length);
}

/**
 * Creates a slice of `array` with `n` elements dropped from the end.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.dropRight([1, 2, 3]);
 * // => [1, 2]
 *
 * _.dropRight([1, 2, 3], 2);
 * // => [1]
 *
 * _.dropRight([1, 2, 3], 5);
 * // => []
 *
 * _.dropRight([1, 2, 3], 0);
 * // => [1, 2, 3]
 */
function dropRight(array, n, guard) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : toInteger(n);
  n = length - n;
  return baseSlice(array, 0, n < 0 ? 0 : n);
}

/**
 * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
 * without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {Function} predicate The function invoked per iteration.
 * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the slice of `array`.
 */
function baseWhile(array, predicate, isDrop, fromRight) {
  var length = array.length,
      index = fromRight ? length : -1;

  while ((fromRight ? index-- : ++index < length) &&
    predicate(array[index], index, array)) {}

  return isDrop
    ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
    : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
}

/**
 * Creates a slice of `array` excluding elements dropped from the end.
 * Elements are dropped until `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.dropRightWhile(users, function(o) { return !o.active; });
 * // => objects for ['barney']
 *
 * // The `_.matches` iteratee shorthand.
 * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
 * // => objects for ['barney', 'fred']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.dropRightWhile(users, ['active', false]);
 * // => objects for ['barney']
 *
 * // The `_.property` iteratee shorthand.
 * _.dropRightWhile(users, 'active');
 * // => objects for ['barney', 'fred', 'pebbles']
 */
function dropRightWhile(array, predicate) {
  return (array && array.length)
    ? baseWhile(array, baseIteratee(predicate, 3), true, true)
    : [];
}

/**
 * Creates a slice of `array` excluding elements dropped from the beginning.
 * Elements are dropped until `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.dropWhile(users, function(o) { return !o.active; });
 * // => objects for ['pebbles']
 *
 * // The `_.matches` iteratee shorthand.
 * _.dropWhile(users, { 'user': 'barney', 'active': false });
 * // => objects for ['fred', 'pebbles']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.dropWhile(users, ['active', false]);
 * // => objects for ['pebbles']
 *
 * // The `_.property` iteratee shorthand.
 * _.dropWhile(users, 'active');
 * // => objects for ['barney', 'fred', 'pebbles']
 */
function dropWhile(array, predicate) {
  return (array && array.length)
    ? baseWhile(array, baseIteratee(predicate, 3), true)
    : [];
}

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _([1, 2]).forEach(function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach$1(collection, iteratee) {
  var func = isArray$1(collection) ? arrayEach : baseEach;
  return func(collection, baseIteratee(iteratee, 3));
}

/**
 * A specialized version of `_.forEachRight` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEachRight(array, iteratee) {
  var length = array ? array.length : 0;

  while (length--) {
    if (iteratee(array[length], length, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * This function is like `baseFor` except that it iterates over properties
 * in the opposite order.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseForRight = createBaseFor(true);

/**
 * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwnRight(object, iteratee) {
  return object && baseForRight(object, iteratee, keys$1);
}

/**
 * The base implementation of `_.forEachRight` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEachRight = createBaseEach(baseForOwnRight, true);

/**
 * This method is like `_.forEach` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @alias eachRight
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEach
 * @example
 *
 * _.forEachRight([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `2` then `1`.
 */
function forEachRight(collection, iteratee) {
  var func = isArray$1(collection) ? arrayEachRight : baseEachRight;
  return func(collection, baseIteratee(iteratee, 3));
}

/**
 * Checks if `string` ends with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to search.
 * @param {string} [target] The string to search for.
 * @param {number} [position=string.length] The position to search up to.
 * @returns {boolean} Returns `true` if `string` ends with `target`,
 *  else `false`.
 * @example
 *
 * _.endsWith('abc', 'c');
 * // => true
 *
 * _.endsWith('abc', 'b');
 * // => false
 *
 * _.endsWith('abc', 'b', 2);
 * // => true
 */
function endsWith(string, target, position) {
  string = toString(string);
  target = baseToString(target);

  var length = string.length;
  position = position === undefined
    ? length
    : baseClamp(toInteger(position), 0, length);

  position -= target.length;
  return position >= 0 && string.indexOf(target, position) == position;
}

/**
 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
 * of key-value pairs for `object` corresponding to the property names of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the key-value pairs.
 */
function baseToPairs(object, props) {
  return arrayMap(props, function(key) {
    return [key, object[key]];
  });
}

/**
 * Converts `set` to its value-value pairs.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the value-value pairs.
 */
function setToPairs(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = [value, value];
  });
  return result;
}

/** `Object#toString` result references. */
var mapTag$5 = '[object Map]';
var setTag$5 = '[object Set]';

/**
 * Creates a `_.toPairs` or `_.toPairsIn` function.
 *
 * @private
 * @param {Function} keysFunc The function to get the keys of a given object.
 * @returns {Function} Returns the new pairs function.
 */
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag$1(object);
    if (tag == mapTag$5) {
      return mapToArray(object);
    }
    if (tag == setTag$5) {
      return setToPairs(object);
    }
    return baseToPairs(object, keysFunc(object));
  };
}

/**
 * Creates an array of own enumerable string keyed-value pairs for `object`
 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
 * entries are returned.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias entries
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the key-value pairs.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.toPairs(new Foo);
 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
 */
var toPairs = createToPairs(keys$1);

/**
 * Creates an array of own and inherited enumerable string keyed-value pairs
 * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
 * or set, its entries are returned.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias entriesIn
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the key-value pairs.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.toPairsIn(new Foo);
 * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
 */
var toPairsIn = createToPairs(keysIn);

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '`': '&#96;'
};

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeHtmlChar(chr) {
  return htmlEscapes[chr];
}

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"'`]/g;
var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/**
 * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
 * their corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * Backticks are escaped because in IE < 9, they can break out of
 * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
 * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
 * [#133](https://html5sec.org/#133) of the
 * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
 */
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reHasRegExpChar = RegExp(reRegExpChar$1.source);

/**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */
function escapeRegExp(string) {
  string = toString(string);
  return (string && reHasRegExpChar.test(string))
    ? string.replace(reRegExpChar$1, '\\$&')
    : string;
}

/**
 * A specialized version of `_.every` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 */
function arrayEvery(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (!predicate(array[index], index, array)) {
      return false;
    }
  }
  return true;
}

/**
 * The base implementation of `_.every` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`
 */
function baseEvery(collection, predicate) {
  var result = true;
  baseEach(collection, function(value, index, collection) {
    result = !!predicate(value, index, collection);
    return result;
  });
  return result;
}

/**
 * Checks if `predicate` returns truthy for **all** elements of `collection`.
 * Iteration is stopped once `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 * @example
 *
 * _.every([true, 1, null, 'yes'], Boolean);
 * // => false
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.every(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.every(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.every(users, 'active');
 * // => false
 */
function every(collection, predicate, guard) {
  var func = isArray$1(collection) ? arrayEvery : baseEvery;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = undefined;
  }
  return func(collection, baseIteratee(predicate, 3));
}

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$1 = 4294967295;

/**
 * Converts `value` to an integer suitable for use as the length of an
 * array-like object.
 *
 * **Note:** This method is based on
 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toLength(3.2);
 * // => 3
 *
 * _.toLength(Number.MIN_VALUE);
 * // => 0
 *
 * _.toLength(Infinity);
 * // => 4294967295
 *
 * _.toLength('3.2');
 * // => 3
 */
function toLength(value) {
  return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH$1) : 0;
}

/**
 * The base implementation of `_.fill` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to fill.
 * @param {*} value The value to fill `array` with.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns `array`.
 */
function baseFill(array, value, start, end) {
  var length = array.length;

  start = toInteger(start);
  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = (end === undefined || end > length) ? length : toInteger(end);
  if (end < 0) {
    end += length;
  }
  end = start > end ? 0 : toLength(end);
  while (start < end) {
    array[start++] = value;
  }
  return array;
}

/**
 * Fills elements of `array` with `value` from `start` up to, but not
 * including, `end`.
 *
 * **Note:** This method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 3.2.0
 * @category Array
 * @param {Array} array The array to fill.
 * @param {*} value The value to fill `array` with.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [1, 2, 3];
 *
 * _.fill(array, 'a');
 * console.log(array);
 * // => ['a', 'a', 'a']
 *
 * _.fill(Array(3), 2);
 * // => [2, 2, 2]
 *
 * _.fill([4, 6, 8, 10], '*', 1, 3);
 * // => [4, '*', '*', 10]
 */
function fill(array, value, start, end) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
    start = 0;
    end = length;
  }
  return baseFill(array, value, start, end);
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array ? array.length : 0,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 */
function filter$2(collection, predicate) {
  var func = isArray$1(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    predicate = baseIteratee(predicate, 3);
    if (!isArrayLike(collection)) {
      var props = keys$1(collection);
    }
    var index = findIndexFunc(props || collection, function(value, key) {
      if (props) {
        key = value;
        value = iterable[key];
      }
      return predicate(value, key, iterable);
    }, fromIndex);
    return index > -1 ? collection[props ? props[index] : index] : undefined;
  };
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$6 = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex$1(array, predicate, fromIndex) {
  var length = array ? array.length : 0;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax$6(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to search.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find$1 = createFind(findIndex$1);

/**
 * The base implementation of methods like `_.findKey` and `_.findLastKey`,
 * without support for iteratee shorthands, which iterates over `collection`
 * using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to search.
 * @param {Function} predicate The function invoked per iteration.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the found element or its key, else `undefined`.
 */
function baseFindKey(collection, predicate, eachFunc) {
  var result;
  eachFunc(collection, function(value, key, collection) {
    if (predicate(value, key, collection)) {
      result = key;
      return false;
    }
  });
  return result;
}

/**
 * This method is like `_.find` except that it returns the key of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Object
 * @param {Object} object The object to search.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {string|undefined} Returns the key of the matched element,
 *  else `undefined`.
 * @example
 *
 * var users = {
 *   'barney':  { 'age': 36, 'active': true },
 *   'fred':    { 'age': 40, 'active': false },
 *   'pebbles': { 'age': 1,  'active': true }
 * };
 *
 * _.findKey(users, function(o) { return o.age < 40; });
 * // => 'barney' (iteration order is not guaranteed)
 *
 * // The `_.matches` iteratee shorthand.
 * _.findKey(users, { 'age': 1, 'active': true });
 * // => 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findKey(users, ['active', false]);
 * // => 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.findKey(users, 'active');
 * // => 'barney'
 */
function findKey(object, predicate) {
  return baseFindKey(object, baseIteratee(predicate, 3), baseForOwn);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$7 = Math.max;
var nativeMin$4 = Math.min;

/**
 * This method is like `_.findIndex` except that it iterates over elements
 * of `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
 * // => 2
 *
 * // The `_.matches` iteratee shorthand.
 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
 * // => 0
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findLastIndex(users, ['active', false]);
 * // => 2
 *
 * // The `_.property` iteratee shorthand.
 * _.findLastIndex(users, 'active');
 * // => 0
 */
function findLastIndex(array, predicate, fromIndex) {
  var length = array ? array.length : 0;
  if (!length) {
    return -1;
  }
  var index = length - 1;
  if (fromIndex !== undefined) {
    index = toInteger(fromIndex);
    index = fromIndex < 0
      ? nativeMax$7(length + index, 0)
      : nativeMin$4(index, length - 1);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index, true);
}

/**
 * This method is like `_.find` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to search.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param {number} [fromIndex=collection.length-1] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * _.findLast([1, 2, 3, 4], function(n) {
 *   return n % 2 == 1;
 * });
 * // => 3
 */
var findLast = createFind(findLastIndex);

/**
 * This method is like `_.findKey` except that it iterates over elements of
 * a collection in the opposite order.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Object
 * @param {Object} object The object to search.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {string|undefined} Returns the key of the matched element,
 *  else `undefined`.
 * @example
 *
 * var users = {
 *   'barney':  { 'age': 36, 'active': true },
 *   'fred':    { 'age': 40, 'active': false },
 *   'pebbles': { 'age': 1,  'active': true }
 * };
 *
 * _.findLastKey(users, function(o) { return o.age < 40; });
 * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.findLastKey(users, { 'age': 36, 'active': true });
 * // => 'barney'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findLastKey(users, ['active', false]);
 * // => 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.findLastKey(users, 'active');
 * // => 'pebbles'
 */
function findLastKey(object, predicate) {
  return baseFindKey(object, baseIteratee(predicate, 3), baseForOwnRight);
}

/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */
function head(array) {
  return (array && array.length) ? array[0] : undefined;
}

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map$2(collection, iteratee) {
  var func = isArray$1(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

/**
 * Creates a flattened array of values by running each element in `collection`
 * thru `iteratee` and flattening the mapped results. The iteratee is invoked
 * with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * function duplicate(n) {
 *   return [n, n];
 * }
 *
 * _.flatMap([1, 2], duplicate);
 * // => [1, 1, 2, 2]
 */
function flatMap(collection, iteratee) {
  return baseFlatten(map$2(collection, iteratee), 1);
}

/** Used as references for various `Number` constants. */
var INFINITY$3 = 1 / 0;

/**
 * This method is like `_.flatMap` except that it recursively flattens the
 * mapped results.
 *
 * @static
 * @memberOf _
 * @since 4.7.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * function duplicate(n) {
 *   return [[[n, n]]];
 * }
 *
 * _.flatMapDeep([1, 2], duplicate);
 * // => [1, 1, 2, 2]
 */
function flatMapDeep(collection, iteratee) {
  return baseFlatten(map$2(collection, iteratee), INFINITY$3);
}

/**
 * This method is like `_.flatMap` except that it recursively flattens the
 * mapped results up to `depth` times.
 *
 * @static
 * @memberOf _
 * @since 4.7.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The function invoked per iteration.
 * @param {number} [depth=1] The maximum recursion depth.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * function duplicate(n) {
 *   return [[[n, n]]];
 * }
 *
 * _.flatMapDepth([1, 2], duplicate, 2);
 * // => [[1, 1], [2, 2]]
 */
function flatMapDepth(collection, iteratee, depth) {
  depth = depth === undefined ? 1 : toInteger(depth);
  return baseFlatten(map$2(collection, iteratee), depth);
}

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten$1(array) {
  var length = array ? array.length : 0;
  return length ? baseFlatten(array, 1) : [];
}

/** Used as references for various `Number` constants. */
var INFINITY$4 = 1 / 0;

/**
 * Recursively flattens `array`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flattenDeep([1, [2, [3, [4]], 5]]);
 * // => [1, 2, 3, 4, 5]
 */
function flattenDeep(array) {
  var length = array ? array.length : 0;
  return length ? baseFlatten(array, INFINITY$4) : [];
}

/**
 * Recursively flatten `array` up to `depth` times.
 *
 * @static
 * @memberOf _
 * @since 4.4.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @param {number} [depth=1] The maximum recursion depth.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * var array = [1, [2, [3, [4]], 5]];
 *
 * _.flattenDepth(array, 1);
 * // => [1, 2, [3, [4]], 5]
 *
 * _.flattenDepth(array, 2);
 * // => [1, 2, 3, [4], 5]
 */
function flattenDepth(array, depth) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  depth = depth === undefined ? 1 : toInteger(depth);
  return baseFlatten(array, depth);
}

/** Used to compose bitmasks for wrapper metadata. */
var FLIP_FLAG$1 = 512;

/**
 * Creates a function that invokes `func` with arguments reversed.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to flip arguments for.
 * @returns {Function} Returns the new flipped function.
 * @example
 *
 * var flipped = _.flip(function() {
 *   return _.toArray(arguments);
 * });
 *
 * flipped('a', 'b', 'c', 'd');
 * // => ['d', 'c', 'b', 'a']
 */
function flip(func) {
  return createWrapper(func, FLIP_FLAG$1);
}

/**
 * Computes `number` rounded down to `precision`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round down.
 * @param {number} [precision=0] The precision to round down to.
 * @returns {number} Returns the rounded down number.
 * @example
 *
 * _.floor(4.006);
 * // => 4
 *
 * _.floor(0.046, 2);
 * // => 0.04
 *
 * _.floor(4060, -2);
 * // => 4000
 */
var floor = createRound('floor');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$2 = 200;

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$8 = 'Expected a function';

/** Used to compose bitmasks for wrapper metadata. */
var CURRY_FLAG$5 = 8;
var PARTIAL_FLAG$4 = 32;
var ARY_FLAG$3 = 128;
var REARG_FLAG$1 = 256;

/**
 * Creates a `_.flow` or `_.flowRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new flow function.
 */
function createFlow(fromRight) {
  return rest(function(funcs) {
    funcs = baseFlatten(funcs, 1);

    var length = funcs.length,
        index = length,
        prereq = LodashWrapper.prototype.thru;

    if (fromRight) {
      funcs.reverse();
    }
    while (index--) {
      var func = funcs[index];
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$8);
      }
      if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
        var wrapper = new LodashWrapper([], true);
      }
    }
    index = wrapper ? index : length;
    while (++index < length) {
      func = funcs[index];

      var funcName = getFuncName(func),
          data = funcName == 'wrapper' ? getData(func) : undefined;

      if (data && isLaziable(data[0]) &&
            data[1] == (ARY_FLAG$3 | CURRY_FLAG$5 | PARTIAL_FLAG$4 | REARG_FLAG$1) &&
            !data[4].length && data[9] == 1
          ) {
        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = (func.length == 1 && isLaziable(func))
          ? wrapper[funcName]()
          : wrapper.thru(func);
      }
    }
    return function() {
      var this$1 = this;

      var args = arguments,
          value = args[0];

      if (wrapper && args.length == 1 &&
          isArray$1(value) && value.length >= LARGE_ARRAY_SIZE$2) {
        return wrapper.plant(value).value();
      }
      var index = 0,
          result = length ? funcs[index].apply(this, args) : value;

      while (++index < length) {
        result = funcs[index].call(this$1, result);
      }
      return result;
    };
  });
}

/**
 * Creates a function that returns the result of invoking the given functions
 * with the `this` binding of the created function, where each successive
 * invocation is supplied the return value of the previous.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {...(Function|Function[])} [funcs] Functions to invoke.
 * @returns {Function} Returns the new composite function.
 * @see _.flowRight
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var addSquare = _.flow([_.add, square]);
 * addSquare(1, 2);
 * // => 9
 */
var flow = createFlow();

/**
 * This method is like `_.flow` except that it creates a function that
 * invokes the given functions from right to left.
 *
 * @static
 * @since 3.0.0
 * @memberOf _
 * @category Util
 * @param {...(Function|Function[])} [funcs] Functions to invoke.
 * @returns {Function} Returns the new composite function.
 * @see _.flow
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var addSquare = _.flowRight([square, _.add]);
 * addSquare(1, 2);
 * // => 9
 */
var flowRight = createFlow(true);

/**
 * Iterates over own and inherited enumerable string keyed properties of an
 * object and invokes `iteratee` for each property. The iteratee is invoked
 * with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forInRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forIn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
 */
function forIn(object, iteratee) {
  return object == null
    ? object
    : baseFor(object, baseIteratee(iteratee, 3), keysIn);
}

/**
 * This method is like `_.forIn` except that it iterates over properties of
 * `object` in the opposite order.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forInRight(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
 */
function forInRight(object, iteratee) {
  return object == null
    ? object
    : baseForRight(object, baseIteratee(iteratee, 3), keysIn);
}

/**
 * Iterates over own enumerable string keyed properties of an object and
 * invokes `iteratee` for each property. The iteratee is invoked with three
 * arguments: (value, key, object). Iteratee functions may exit iteration
 * early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forOwnRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forOwn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forOwn(object, iteratee) {
  return object && baseForOwn(object, baseIteratee(iteratee, 3));
}

/**
 * This method is like `_.forOwn` except that it iterates over properties of
 * `object` in the opposite order.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forOwn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forOwnRight(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
 */
function forOwnRight(object, iteratee) {
  return object && baseForOwnRight(object, baseIteratee(iteratee, 3));
}

/**
 * The inverse of `_.toPairs`; this method returns an object composed
 * from key-value `pairs`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} pairs The key-value pairs.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.fromPairs([['fred', 30], ['barney', 40]]);
 * // => { 'fred': 30, 'barney': 40 }
 */
function fromPairs(pairs) {
  var index = -1,
      length = pairs ? pairs.length : 0,
      result = {};

  while (++index < length) {
    var pair = pairs[index];
    result[pair[0]] = pair[1];
  }
  return result;
}

/**
 * The base implementation of `_.functions` which creates an array of
 * `object` function property names filtered from `props`.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Array} props The property names to filter.
 * @returns {Array} Returns the function names.
 */
function baseFunctions(object, props) {
  return arrayFilter(props, function(key) {
    return isFunction(object[key]);
  });
}

/**
 * Creates an array of function property names from own enumerable properties
 * of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the function names.
 * @see _.functionsIn
 * @example
 *
 * function Foo() {
 *   this.a = _.constant('a');
 *   this.b = _.constant('b');
 * }
 *
 * Foo.prototype.c = _.constant('c');
 *
 * _.functions(new Foo);
 * // => ['a', 'b']
 */
function functions(object) {
  return object == null ? [] : baseFunctions(object, keys$1(object));
}

/**
 * Creates an array of function property names from own and inherited
 * enumerable properties of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the function names.
 * @see _.functions
 * @example
 *
 * function Foo() {
 *   this.a = _.constant('a');
 *   this.b = _.constant('b');
 * }
 *
 * Foo.prototype.c = _.constant('c');
 *
 * _.functionsIn(new Foo);
 * // => ['a', 'b', 'c']
 */
function functionsIn(object) {
  return object == null ? [] : baseFunctions(object, keysIn(object));
}

/** Used for built-in method references. */
var objectProto$24 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$15 = objectProto$24.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 *
 * // The `_.property` iteratee shorthand.
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */
var groupBy = createAggregator(function(result, value, key) {
  if (hasOwnProperty$15.call(result, key)) {
    result[key].push(value);
  } else {
    result[key] = [value];
  }
});

/**
 * The base implementation of `_.gt` which doesn't coerce arguments to numbers.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */
function baseGt(value, other) {
  return value > other;
}

/**
 * Creates a function that performs a relational operation on two values.
 *
 * @private
 * @param {Function} operator The function to perform the operation.
 * @returns {Function} Returns the new relational operation function.
 */
function createRelationalOperation(operator) {
  return function(value, other) {
    if (!(typeof value == 'string' && typeof other == 'string')) {
      value = toNumber(value);
      other = toNumber(other);
    }
    return operator(value, other);
  };
}

/**
 * Checks if `value` is greater than `other`.
 *
 * @static
 * @memberOf _
 * @since 3.9.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 * @see _.lt
 * @example
 *
 * _.gt(3, 1);
 * // => true
 *
 * _.gt(3, 3);
 * // => false
 *
 * _.gt(1, 3);
 * // => false
 */
var gt$1$1 = createRelationalOperation(baseGt);

/**
 * Checks if `value` is greater than or equal to `other`.
 *
 * @static
 * @memberOf _
 * @since 3.9.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than or equal to
 *  `other`, else `false`.
 * @see _.lte
 * @example
 *
 * _.gte(3, 1);
 * // => true
 *
 * _.gte(3, 3);
 * // => true
 *
 * _.gte(1, 3);
 * // => false
 */
var gte = createRelationalOperation(function(value, other) {
  return value >= other;
});

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$8 = Math.max;
var nativeMin$5 = Math.min;

/**
 * The base implementation of `_.inRange` which doesn't coerce arguments to numbers.
 *
 * @private
 * @param {number} number The number to check.
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
 */
function baseInRange(number, start, end) {
  return number >= nativeMin$5(start, end) && number < nativeMax$8(start, end);
}

/**
 * Checks if `n` is between `start` and up to, but not including, `end`. If
 * `end` is not specified, it's set to `start` with `start` then set to `0`.
 * If `start` is greater than `end` the params are swapped to support
 * negative ranges.
 *
 * @static
 * @memberOf _
 * @since 3.3.0
 * @category Number
 * @param {number} number The number to check.
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
 * @see _.range, _.rangeRight
 * @example
 *
 * _.inRange(3, 2, 4);
 * // => true
 *
 * _.inRange(4, 8);
 * // => true
 *
 * _.inRange(4, 2);
 * // => false
 *
 * _.inRange(2, 2);
 * // => false
 *
 * _.inRange(1.2, 2);
 * // => true
 *
 * _.inRange(5.2, 4);
 * // => false
 *
 * _.inRange(-3, -2, -6);
 * // => true
 */
function inRange(number, start, end) {
  start = toNumber(start) || 0;
  if (end === undefined) {
    end = start;
    start = 0;
  } else {
    end = toNumber(end) || 0;
  }
  number = toNumber(number);
  return baseInRange(number, start, end);
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object ? baseValues(object, keys$1(object)) : [];
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$9 = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to search.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
 * // => true
 *
 * _.includes('pebbles', 'eb');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax$9(length + fromIndex, 0);
  }
  return isString$1(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$10 = Math.max;

/**
 * Gets the index at which the first occurrence of `value` is found in `array`
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the
 * offset from the end of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.indexOf([1, 2, 1, 2], 2);
 * // => 1
 *
 * // Search from the `fromIndex`.
 * _.indexOf([1, 2, 1, 2], 2, 2);
 * // => 3
 */
function indexOf(array, value, fromIndex) {
  var length = array ? array.length : 0;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax$10(length + index, 0);
  }
  return baseIndexOf(array, value, index);
}

/**
 * Gets all but the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.initial([1, 2, 3]);
 * // => [1, 2]
 */
function initial(array) {
  return dropRight(array, 1);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$6 = Math.min;

/**
 * The base implementation of methods like `_.intersection`, without support
 * for iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */
function baseIntersection(arrays, iteratee, comparator) {
  var includes = comparator ? arrayIncludesWith : arrayIncludes,
      length = arrays[0].length,
      othLength = arrays.length,
      othIndex = othLength,
      caches = Array(othLength),
      maxLength = Infinity,
      result = [];

  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee) {
      array = arrayMap(array, baseUnary(iteratee));
    }
    maxLength = nativeMin$6(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
      ? new SetCache(othIndex && array)
      : undefined;
  }
  array = arrays[0];

  var index = -1,
      seen = caches[0];

  outer:
  while (++index < length && result.length < maxLength) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (!(seen
          ? cacheHas(seen, computed)
          : includes(result, computed, comparator)
        )) {
      othIndex = othLength;
      while (--othIndex) {
        var cache = caches[othIndex];
        if (!(cache
              ? cacheHas(cache, computed)
              : includes(arrays[othIndex], computed, comparator))
            ) {
          continue outer;
        }
      }
      if (seen) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Casts `value` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */
function castArrayLikeObject(value) {
  return isArrayLikeObject(value) ? value : [];
}

/**
 * Creates an array of unique values that are included in all given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons. The order of result values is determined by the
 * order they occur in the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersection([2, 1], [2, 3]);
 * // => [2]
 */
var intersection = rest(function(arrays) {
  var mapped = arrayMap(arrays, castArrayLikeObject);
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped)
    : [];
});

/**
 * This method is like `_.intersection` except that it accepts `iteratee`
 * which is invoked for each element of each `arrays` to generate the criterion
 * by which they're compared. Result values are chosen from the first array.
 * The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
 * // => [2.1]
 *
 * // The `_.property` iteratee shorthand.
 * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }]
 */
var intersectionBy = rest(function(arrays) {
  var iteratee = last(arrays),
      mapped = arrayMap(arrays, castArrayLikeObject);

  if (iteratee === last(mapped)) {
    iteratee = undefined;
  } else {
    mapped.pop();
  }
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped, baseIteratee(iteratee))
    : [];
});

/**
 * This method is like `_.intersection` except that it accepts `comparator`
 * which is invoked to compare elements of `arrays`. Result values are chosen
 * from the first array. The comparator is invoked with two arguments:
 * (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.intersectionWith(objects, others, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }]
 */
var intersectionWith = rest(function(arrays) {
  var comparator = last(arrays),
      mapped = arrayMap(arrays, castArrayLikeObject);

  if (comparator === last(mapped)) {
    comparator = undefined;
  } else {
    mapped.pop();
  }
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped, undefined, comparator)
    : [];
});

/**
 * The base implementation of `_.invert` and `_.invertBy` which inverts
 * `object` with values transformed by `iteratee` and set by `setter`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform values.
 * @param {Object} accumulator The initial inverted object.
 * @returns {Function} Returns `accumulator`.
 */
function baseInverter(object, setter, iteratee, accumulator) {
  baseForOwn(object, function(value, key, object) {
    setter(accumulator, iteratee(value), key, object);
  });
  return accumulator;
}

/**
 * Creates a function like `_.invertBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} toIteratee The function to resolve iteratees.
 * @returns {Function} Returns the new inverter function.
 */
function createInverter(setter, toIteratee) {
  return function(object, iteratee) {
    return baseInverter(object, setter, toIteratee(iteratee), {});
  };
}

/**
 * Creates an object composed of the inverted keys and values of `object`.
 * If `object` contains duplicate values, subsequent values overwrite
 * property assignments of previous values.
 *
 * @static
 * @memberOf _
 * @since 0.7.0
 * @category Object
 * @param {Object} object The object to invert.
 * @returns {Object} Returns the new inverted object.
 * @example
 *
 * var object = { 'a': 1, 'b': 2, 'c': 1 };
 *
 * _.invert(object);
 * // => { '1': 'c', '2': 'b' }
 */
var invert = createInverter(function(result, value, key) {
  result[value] = key;
}, constant(identity));

/** Used for built-in method references. */
var objectProto$25 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$16 = objectProto$25.hasOwnProperty;

/**
 * This method is like `_.invert` except that the inverted object is generated
 * from the results of running each element of `object` thru `iteratee`. The
 * corresponding inverted value of each inverted key is an array of keys
 * responsible for generating the inverted value. The iteratee is invoked
 * with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.1.0
 * @category Object
 * @param {Object} object The object to invert.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Object} Returns the new inverted object.
 * @example
 *
 * var object = { 'a': 1, 'b': 2, 'c': 1 };
 *
 * _.invertBy(object);
 * // => { '1': ['a', 'c'], '2': ['b'] }
 *
 * _.invertBy(object, function(value) {
 *   return 'group' + value;
 * });
 * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
 */
var invertBy = createInverter(function(result, value, key) {
  if (hasOwnProperty$16.call(result, value)) {
    result[value].push(key);
  } else {
    result[value] = [key];
  }
}, baseIteratee);

/**
 * The base implementation of `_.invoke` without support for individual
 * method arguments.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {Array} args The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 */
function baseInvoke(object, path, args) {
  if (!isKey(path, object)) {
    path = castPath(path);
    object = parent(object, path);
    path = last(path);
  }
  var func = object == null ? object : object[toKey(path)];
  return func == null ? undefined : apply(func, object, args);
}

/**
 * Invokes the method at `path` of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {...*} [args] The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
 *
 * _.invoke(object, 'a[0].b.c.slice', 1, 3);
 * // => [2, 3]
 */
var invoke = rest(baseInvoke);

/**
 * Invokes the method at `path` of each element in `collection`, returning
 * an array of the results of each invoked method. Any additional arguments
 * are provided to each invoked method. If `methodName` is a function, it's
 * invoked for and `this` bound to, each element in `collection`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|string} path The path of the method to invoke or
 *  the function invoked per iteration.
 * @param {...*} [args] The arguments to invoke each method with.
 * @returns {Array} Returns the array of results.
 * @example
 *
 * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
 * // => [[1, 5, 7], [1, 2, 3]]
 *
 * _.invokeMap([123, 456], String.prototype.split, '');
 * // => [['1', '2', '3'], ['4', '5', '6']]
 */
var invokeMap = rest(function(collection, path, args) {
  var index = -1,
      isFunc = typeof path == 'function',
      isProp = isKey(path),
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value) {
    var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
    result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);
  });
  return result;
});

var arrayBufferTag$4 = '[object ArrayBuffer]';

/** Used for built-in method references. */
var objectProto$26 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$8 = objectProto$26.toString;

/**
 * Checks if `value` is classified as an `ArrayBuffer` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArrayBuffer(new ArrayBuffer(2));
 * // => true
 *
 * _.isArrayBuffer(new Array(2));
 * // => false
 */
function isArrayBuffer(value) {
  return isObjectLike(value) && objectToString$8.call(value) == arrayBufferTag$4;
}

/** `Object#toString` result references. */
var boolTag$4 = '[object Boolean]';

/** Used for built-in method references. */
var objectProto$27 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$9 = objectProto$27.toString;

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function isBoolean(value) {
  return value === true || value === false ||
    (isObjectLike(value) && objectToString$9.call(value) == boolTag$4);
}

/** `Object#toString` result references. */
var dateTag$4 = '[object Date]';

/** Used for built-in method references. */
var objectProto$28 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$10 = objectProto$28.toString;

/**
 * Checks if `value` is classified as a `Date` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isDate(new Date);
 * // => true
 *
 * _.isDate('Mon April 23 2012');
 * // => false
 */
function isDate(value) {
  return isObjectLike(value) && objectToString$10.call(value) == dateTag$4;
}

/**
 * Checks if `value` is likely a DOM element.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a DOM element,
 *  else `false`.
 * @example
 *
 * _.isElement(document.body);
 * // => true
 *
 * _.isElement('<body>');
 * // => false
 */
function isElement(value) {
  return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject$1(value);
}

/** `Object#toString` result references. */
var mapTag$6 = '[object Map]';
var setTag$6 = '[object Set]';

/** Used for built-in method references. */
var objectProto$29 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$17 = objectProto$29.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$4 = objectProto$29.propertyIsEnumerable;

/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
var nonEnumShadows$2 = !propertyIsEnumerable$4.call({ 'valueOf': 1 }, 'valueOf');

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (isArrayLike(value) &&
      (isArray$1(value) || isString$1(value) || isFunction(value.splice) ||
        isArguments(value) || isBuffer(value))) {
    return !value.length;
  }
  if (isObjectLike(value)) {
    var tag = getTag$1(value);
    if (tag == mapTag$6 || tag == setTag$6) {
      return !value.size;
    }
  }
  for (var key in value) {
    if (hasOwnProperty$17.call(value, key)) {
      return false;
    }
  }
  return !(nonEnumShadows$2 && keys$1(value).length);
}

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are **not** supported.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent,
 *  else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual$1(value, other) {
  return baseIsEqual(value, other);
}

/**
 * This method is like `_.isEqual` except that it accepts `customizer` which
 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
 * are handled by the method instead. The `customizer` is invoked with up to
 * six arguments: (objValue, othValue [, index|key, object, other, stack]).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if the values are equivalent,
 *  else `false`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 *
 * function customizer(objValue, othValue) {
 *   if (isGreeting(objValue) && isGreeting(othValue)) {
 *     return true;
 *   }
 * }
 *
 * var array = ['hello', 'goodbye'];
 * var other = ['hi', 'goodbye'];
 *
 * _.isEqualWith(array, other, customizer);
 * // => true
 */
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  var result = customizer ? customizer(value, other) : undefined;
  return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsFinite = root.isFinite;

/**
 * Checks if `value` is a finite primitive number.
 *
 * **Note:** This method is based on
 * [`Number.isFinite`](https://mdn.io/Number/isFinite).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a finite number,
 *  else `false`.
 * @example
 *
 * _.isFinite(3);
 * // => true
 *
 * _.isFinite(Number.MIN_VALUE);
 * // => true
 *
 * _.isFinite(Infinity);
 * // => false
 *
 * _.isFinite('3');
 * // => false
 */
function isFinite$1(value) {
  return typeof value == 'number' && nativeIsFinite(value);
}

/**
 * Checks if `value` is an integer.
 *
 * **Note:** This method is based on
 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
 * @example
 *
 * _.isInteger(3);
 * // => true
 *
 * _.isInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isInteger(Infinity);
 * // => false
 *
 * _.isInteger('3');
 * // => false
 */
function isInteger(value) {
  return typeof value == 'number' && value == toInteger(value);
}

/** `Object#toString` result references. */
var mapTag$7 = '[object Map]';

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
function isMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$7;
}

/**
 * Performs a partial deep comparison between `object` and `source` to
 * determine if `object` contains equivalent property values. This method is
 * equivalent to a `_.matches` function when `source` is partially applied.
 *
 * **Note:** This method supports comparing the same values as `_.isEqual`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 * @example
 *
 * var object = { 'user': 'fred', 'age': 40 };
 *
 * _.isMatch(object, { 'age': 40 });
 * // => true
 *
 * _.isMatch(object, { 'age': 36 });
 * // => false
 */
function isMatch(object, source) {
  return object === source || baseIsMatch(object, source, getMatchData(source));
}

/**
 * This method is like `_.isMatch` except that it accepts `customizer` which
 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
 * are handled by the method instead. The `customizer` is invoked with five
 * arguments: (objValue, srcValue, index|key, object, source).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 *
 * function customizer(objValue, srcValue) {
 *   if (isGreeting(objValue) && isGreeting(srcValue)) {
 *     return true;
 *   }
 * }
 *
 * var object = { 'greeting': 'hello' };
 * var source = { 'greeting': 'hi' };
 *
 * _.isMatchWith(object, source, customizer);
 * // => true
 */
function isMatchWith(object, source, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  return baseIsMatch(object, source, getMatchData(source), customizer);
}

/** `Object#toString` result references. */
var numberTag$4 = '[object Number]';

/** Used for built-in method references. */
var objectProto$30 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$11 = objectProto$30.toString;

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber$1(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && objectToString$11.call(value) == numberTag$4);
}

/**
 * Checks if `value` is `NaN`.
 *
 * **Note:** This method is based on
 * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
 * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
 * `undefined` and other non-number values.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 * @example
 *
 * _.isNaN(NaN);
 * // => true
 *
 * _.isNaN(new Number(NaN));
 * // => true
 *
 * isNaN(undefined);
 * // => true
 *
 * _.isNaN(undefined);
 * // => false
 */
function isNaN$1(value) {
  // An `NaN` primitive is the only value that is not equal to itself.
  // Perform the `toStringTag` check first to avoid errors with some
  // ActiveX objects in IE.
  return isNumber$1(value) && value != +value;
}

/**
 * Checks if `func` is capable of being masked.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
 */
var isMaskable = coreJsData ? isFunction : stubFalse;

/**
 * Checks if `value` is a pristine native function.
 *
 * **Note:** This method can't reliably detect native functions in the
 * presence of the `core-js` package because `core-js` circumvents this kind
 * of detection. Despite multiple requests, the `core-js` maintainer has made
 * it clear: any attempt to fix the detection will be obstructed. As a result,
 * we're left with little choice but to throw an error. Unfortunately, this
 * also affects packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
 * which rely on `core-js`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (isMaskable(value)) {
    throw new Error('This method is not supported with `core-js`. Try https://github.com/es-shims.');
  }
  return baseIsNative(value);
}

/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */
function isNil$1(value) {
  return value == null;
}

/**
 * Checks if `value` is `null`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
 * @example
 *
 * _.isNull(null);
 * // => true
 *
 * _.isNull(void 0);
 * // => false
 */
function isNull(value) {
  return value === null;
}

/** `Object#toString` result references. */
var regexpTag$4 = '[object RegExp]';

/** Used for built-in method references. */
var objectProto$31 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$12 = objectProto$31.toString;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
function isRegExp(value) {
  return isObject$1(value) && objectToString$12.call(value) == regexpTag$4;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$2 = 9007199254740991;

/**
 * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
 * double precision number which isn't the result of a rounded unsafe integer.
 *
 * **Note:** This method is based on
 * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a safe integer,
 *  else `false`.
 * @example
 *
 * _.isSafeInteger(3);
 * // => true
 *
 * _.isSafeInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isSafeInteger(Infinity);
 * // => false
 *
 * _.isSafeInteger('3');
 * // => false
 */
function isSafeInteger(value) {
  return isInteger(value) && value >= -MAX_SAFE_INTEGER$2 && value <= MAX_SAFE_INTEGER$2;
}

/** `Object#toString` result references. */
var setTag$7 = '[object Set]';

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
function isSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$7;
}

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

/** `Object#toString` result references. */
var weakMapTag$3 = '[object WeakMap]';

/**
 * Checks if `value` is classified as a `WeakMap` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isWeakMap(new WeakMap);
 * // => true
 *
 * _.isWeakMap(new Map);
 * // => false
 */
function isWeakMap(value) {
  return isObjectLike(value) && getTag$1(value) == weakMapTag$3;
}

/** `Object#toString` result references. */
var weakSetTag = '[object WeakSet]';

/** Used for built-in method references. */
var objectProto$32 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$13 = objectProto$32.toString;

/**
 * Checks if `value` is classified as a `WeakSet` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isWeakSet(new WeakSet);
 * // => true
 *
 * _.isWeakSet(new Set);
 * // => false
 */
function isWeakSet(value) {
  return isObjectLike(value) && objectToString$13.call(value) == weakSetTag;
}

/**
 * Creates a function that invokes `func` with the arguments of the created
 * function. If `func` is a property name, the created function returns the
 * property value for a given element. If `func` is an array or object, the
 * created function returns `true` for elements that contain the equivalent
 * source properties, otherwise it returns `false`.
 *
 * @static
 * @since 4.0.0
 * @memberOf _
 * @category Util
 * @param {*} [func=_.identity] The value to convert to a callback.
 * @returns {Function} Returns the callback.
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
 * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, _.iteratee(['user', 'fred']));
 * // => [{ 'user': 'fred', 'age': 40 }]
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, _.iteratee('user'));
 * // => ['barney', 'fred']
 *
 * // Create custom iteratee shorthands.
 * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
 *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
 *     return func.test(string);
 *   };
 * });
 *
 * _.filter(['abc', 'def'], /ef/);
 * // => ['def']
 */
function iteratee(func) {
  return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));
}

/** Used for built-in method references. */
var arrayProto$1 = Array.prototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeJoin = arrayProto$1.join;

/**
 * Converts all elements in `array` into a string separated by `separator`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to convert.
 * @param {string} [separator=','] The element separator.
 * @returns {string} Returns the joined string.
 * @example
 *
 * _.join(['a', 'b', 'c'], '~');
 * // => 'a~b~c'
 */
function join(array, separator) {
  return array ? nativeJoin.call(array, separator) : '';
}

/**
 * Converts `string` to
 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the kebab cased string.
 * @example
 *
 * _.kebabCase('Foo Bar');
 * // => 'foo-bar'
 *
 * _.kebabCase('fooBar');
 * // => 'foo-bar'
 *
 * _.kebabCase('__FOO_BAR__');
 * // => 'foo-bar'
 */
var kebabCase = createCompounder(function(result, word, index) {
  return result + (index ? '-' : '') + word.toLowerCase();
});

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The corresponding value of
 * each key is the last element responsible for generating the key. The
 * iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * var array = [
 *   { 'dir': 'left', 'code': 97 },
 *   { 'dir': 'right', 'code': 100 }
 * ];
 *
 * _.keyBy(array, function(o) {
 *   return String.fromCharCode(o.code);
 * });
 * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
 *
 * _.keyBy(array, 'dir');
 * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
 */
var keyBy = createAggregator(function(result, value, key) {
  result[key] = value;
});

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$11 = Math.max;
var nativeMin$7 = Math.min;

/**
 * This method is like `_.indexOf` except that it iterates over elements of
 * `array` from right to left.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.lastIndexOf([1, 2, 1, 2], 2);
 * // => 3
 *
 * // Search from the `fromIndex`.
 * _.lastIndexOf([1, 2, 1, 2], 2, 2);
 * // => 1
 */
function lastIndexOf(array, value, fromIndex) {
  var length = array ? array.length : 0;
  if (!length) {
    return -1;
  }
  var index = length;
  if (fromIndex !== undefined) {
    index = toInteger(fromIndex);
    index = (
      index < 0
        ? nativeMax$11(length + index, 0)
        : nativeMin$7(index, length - 1)
    ) + 1;
  }
  if (value !== value) {
    return indexOfNaN(array, index - 1, true);
  }
  while (index--) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * Converts `string`, as space separated words, to lower case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the lower cased string.
 * @example
 *
 * _.lowerCase('--Foo-Bar--');
 * // => 'foo bar'
 *
 * _.lowerCase('fooBar');
 * // => 'foo bar'
 *
 * _.lowerCase('__FOO_BAR__');
 * // => 'foo bar'
 */
var lowerCase = createCompounder(function(result, word, index) {
  return result + (index ? ' ' : '') + word.toLowerCase();
});

/**
 * Converts the first character of `string` to lower case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.lowerFirst('Fred');
 * // => 'fred'
 *
 * _.lowerFirst('FRED');
 * // => 'fRED'
 */
var lowerFirst = createCaseFirst('toLowerCase');

/**
 * The base implementation of `_.lt` which doesn't coerce arguments to numbers.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than `other`,
 *  else `false`.
 */
function baseLt(value, other) {
  return value < other;
}

/**
 * Checks if `value` is less than `other`.
 *
 * @static
 * @memberOf _
 * @since 3.9.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than `other`,
 *  else `false`.
 * @see _.gt
 * @example
 *
 * _.lt(1, 3);
 * // => true
 *
 * _.lt(3, 3);
 * // => false
 *
 * _.lt(3, 1);
 * // => false
 */
var lt$1$1 = createRelationalOperation(baseLt);

/**
 * Checks if `value` is less than or equal to `other`.
 *
 * @static
 * @memberOf _
 * @since 3.9.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than or equal to
 *  `other`, else `false`.
 * @see _.gte
 * @example
 *
 * _.lte(1, 3);
 * // => true
 *
 * _.lte(3, 3);
 * // => true
 *
 * _.lte(3, 1);
 * // => false
 */
var lte = createRelationalOperation(function(value, other) {
  return value <= other;
});

/**
 * The opposite of `_.mapValues`; this method creates an object with the
 * same values as `object` and keys generated by running each own enumerable
 * string keyed property of `object` thru `iteratee`. The iteratee is invoked
 * with three arguments: (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapValues
 * @example
 *
 * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
 *   return key + value;
 * });
 * // => { 'a1': 1, 'b2': 2 }
 */
function mapKeys(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    result[iteratee(value, key, object)] = value;
  });
  return result;
}

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    result[key] = iteratee(value, key, object);
  });
  return result;
}

/**
 * Creates a function that performs a partial deep comparison between a given
 * object and `source`, returning `true` if the given object has equivalent
 * property values, else `false`. The created function is equivalent to
 * `_.isMatch` with a `source` partially applied.
 *
 * **Note:** This method supports comparing the same values as `_.isEqual`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, _.matches({ 'age': 40, 'active': false }));
 * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
 */
function matches$1(source) {
  return baseMatches(baseClone(source, true));
}

/**
 * Creates a function that performs a partial deep comparison between the
 * value at `path` of a given object to `srcValue`, returning `true` if the
 * object value is equivalent, else `false`.
 *
 * **Note:** This method supports comparing the same values as `_.isEqual`.
 *
 * @static
 * @memberOf _
 * @since 3.2.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 * @example
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * _.find(users, _.matchesProperty('user', 'fred'));
 * // => { 'user': 'fred' }
 */
function matchesProperty(path, srcValue) {
  return baseMatchesProperty(path, baseClone(srcValue, true));
}

/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */
function baseExtremum(array, iteratee, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index],
        current = iteratee(value);

    if (current != null && (computed === undefined
          ? (current === current && !isSymbol(current))
          : comparator(current, computed)
        )) {
      var computed = current,
          result = value;
    }
  }
  return result;
}

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseGt)
    : undefined;
}

/**
 * This method is like `_.max` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * _.maxBy(objects, function(o) { return o.n; });
 * // => { 'n': 2 }
 *
 * // The `_.property` iteratee shorthand.
 * _.maxBy(objects, 'n');
 * // => { 'n': 2 }
 */
function maxBy(array, iteratee) {
  return (array && array.length)
    ? baseExtremum(array, baseIteratee(iteratee), baseGt)
    : undefined;
}

/**
 * The base implementation of `_.sum` and `_.sumBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */
function baseSum(array, iteratee) {
  var result,
      index = -1,
      length = array.length;

  while (++index < length) {
    var current = iteratee(array[index]);
    if (current !== undefined) {
      result = result === undefined ? current : (result + current);
    }
  }
  return result;
}

/** Used as references for various `Number` constants. */
var NAN$2 = 0 / 0;

/**
 * The base implementation of `_.mean` and `_.meanBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the mean.
 */
function baseMean(array, iteratee) {
  var length = array ? array.length : 0;
  return length ? (baseSum(array, iteratee) / length) : NAN$2;
}

/**
 * Computes the mean of the values in `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the mean.
 * @example
 *
 * _.mean([4, 2, 8, 6]);
 * // => 5
 */
function mean(array) {
  return baseMean(array, identity);
}

/**
 * This method is like `_.mean` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the value to be averaged.
 * The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.7.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {number} Returns the mean.
 * @example
 *
 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
 *
 * _.meanBy(objects, function(o) { return o.n; });
 * // => 5
 *
 * // The `_.property` iteratee shorthand.
 * _.meanBy(objects, 'n');
 * // => 5
 */
function meanBy(array, iteratee) {
  return baseMean(array, baseIteratee(iteratee));
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var users = {
 *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
 * };
 *
 * var ages = {
 *   'data': [{ 'age': 36 }, { 'age': 40 }]
 * };
 *
 * _.merge(users, ages);
 * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * Creates a function that invokes the method at `path` of a given object.
 * Any additional arguments are provided to the invoked method.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Util
 * @param {Array|string} path The path of the method to invoke.
 * @param {...*} [args] The arguments to invoke the method with.
 * @returns {Function} Returns the new invoker function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': _.constant(2) } },
 *   { 'a': { 'b': _.constant(1) } }
 * ];
 *
 * _.map(objects, _.method('a.b'));
 * // => [2, 1]
 *
 * _.map(objects, _.method(['a', 'b']));
 * // => [2, 1]
 */
var method = rest(function(path, args) {
  return function(object) {
    return baseInvoke(object, path, args);
  };
});

/**
 * The opposite of `_.method`; this method creates a function that invokes
 * the method at a given path of `object`. Any additional arguments are
 * provided to the invoked method.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Util
 * @param {Object} object The object to query.
 * @param {...*} [args] The arguments to invoke the method with.
 * @returns {Function} Returns the new invoker function.
 * @example
 *
 * var array = _.times(3, _.constant),
 *     object = { 'a': array, 'b': array, 'c': array };
 *
 * _.map(['a[2]', 'c[0]'], _.methodOf(object));
 * // => [2, 0]
 *
 * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
 * // => [2, 0]
 */
var methodOf = rest(function(object, args) {
  return function(path) {
    return baseInvoke(object, path, args);
  };
});

/**
 * Computes the minimum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * _.min([4, 2, 8, 6]);
 * // => 2
 *
 * _.min([]);
 * // => undefined
 */
function min(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseLt)
    : undefined;
}

/**
 * This method is like `_.min` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * _.minBy(objects, function(o) { return o.n; });
 * // => { 'n': 1 }
 *
 * // The `_.property` iteratee shorthand.
 * _.minBy(objects, 'n');
 * // => { 'n': 1 }
 */
function minBy(array, iteratee) {
  return (array && array.length)
    ? baseExtremum(array, baseIteratee(iteratee), baseLt)
    : undefined;
}

/**
 * Adds all own enumerable string keyed function properties of a source
 * object to the destination object. If `object` is a function, then methods
 * are added to its prototype as well.
 *
 * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
 * avoid conflicts caused by modifying the original.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {Function|Object} [object=lodash] The destination object.
 * @param {Object} source The object of functions to add.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
 * @returns {Function|Object} Returns `object`.
 * @example
 *
 * function vowels(string) {
 *   return _.filter(string, function(v) {
 *     return /[aeiou]/i.test(v);
 *   });
 * }
 *
 * _.mixin({ 'vowels': vowels });
 * _.vowels('fred');
 * // => ['e']
 *
 * _('fred').vowels().value();
 * // => ['e']
 *
 * _.mixin({ 'vowels': vowels }, { 'chain': false });
 * _('fred').vowels();
 * // => ['e']
 */
function mixin(object, source, options) {
  var props = keys$1(source),
      methodNames = baseFunctions(source, props);

  var chain = !(isObject$1(options) && 'chain' in options) || !!options.chain,
      isFunc = isFunction(object);

  arrayEach(methodNames, function(methodName) {
    var func = source[methodName];
    object[methodName] = func;
    if (isFunc) {
      object.prototype[methodName] = function() {
        var chainAll = this.__chain__;
        if (chain || chainAll) {
          var result = object(this.__wrapped__),
              actions = result.__actions__ = copyArray(this.__actions__);

          actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
          result.__chain__ = chainAll;
          return result;
        }
        return func.apply(object, arrayPush([this.value()], arguments));
      };
    }
  });

  return object;
}

/**
 * Multiply two numbers.
 *
 * @static
 * @memberOf _
 * @since 4.7.0
 * @category Math
 * @param {number} multiplier The first number in a multiplication.
 * @param {number} multiplicand The second number in a multiplication.
 * @returns {number} Returns the product.
 * @example
 *
 * _.multiply(6, 4);
 * // => 24
 */
var multiply = createMathOperation(function(multiplier, multiplicand) {
  return multiplier * multiplicand;
});

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$9 = 'Expected a function';

/**
 * Creates a function that negates the result of the predicate `func`. The
 * `func` predicate is invoked with the `this` binding and arguments of the
 * created function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} predicate The predicate to negate.
 * @returns {Function} Returns the new negated function.
 * @example
 *
 * function isEven(n) {
 *   return n % 2 == 0;
 * }
 *
 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
 * // => [1, 3, 5]
 */
function negate(predicate) {
  if (typeof predicate != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$9);
  }
  return function() {
    return !predicate.apply(this, arguments);
  };
}

/** `Object#toString` result references. */
var mapTag$8 = '[object Map]';
var setTag$8 = '[object Set]';

/** Built-in value references. */
var iteratorSymbol = typeof (iteratorSymbol = Symbol && Symbol.iterator) == 'symbol' ? iteratorSymbol : undefined;

/**
 * Converts `value` to an array.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Array} Returns the converted array.
 * @example
 *
 * _.toArray({ 'a': 1, 'b': 2 });
 * // => [1, 2]
 *
 * _.toArray('abc');
 * // => ['a', 'b', 'c']
 *
 * _.toArray(1);
 * // => []
 *
 * _.toArray(null);
 * // => []
 */
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike(value)) {
    return isString$1(value) ? stringToArray(value) : copyArray(value);
  }
  if (iteratorSymbol && value[iteratorSymbol]) {
    return iteratorToArray(value[iteratorSymbol]());
  }
  var tag = getTag$1(value),
      func = tag == mapTag$8 ? mapToArray : (tag == setTag$8 ? setToArray : values);

  return func(value);
}

/**
 * Gets the next value on a wrapped object following the
 * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
 *
 * @name next
 * @memberOf _
 * @since 4.0.0
 * @category Seq
 * @returns {Object} Returns the next iterator value.
 * @example
 *
 * var wrapped = _([1, 2]);
 *
 * wrapped.next();
 * // => { 'done': false, 'value': 1 }
 *
 * wrapped.next();
 * // => { 'done': false, 'value': 2 }
 *
 * wrapped.next();
 * // => { 'done': true, 'value': undefined }
 */
function wrapperNext() {
  if (this.__values__ === undefined) {
    this.__values__ = toArray(this.value());
  }
  var done = this.__index__ >= this.__values__.length,
      value = done ? undefined : this.__values__[this.__index__++];

  return { 'done': done, 'value': value };
}

/**
 * The base implementation of `_.nth` which doesn't coerce `n` to an integer.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {number} n The index of the element to return.
 * @returns {*} Returns the nth element of `array`.
 */
function baseNth(array, n) {
  var length = array.length;
  if (!length) {
    return;
  }
  n += n < 0 ? length : 0;
  return isIndex(n, length) ? array[n] : undefined;
}

/**
 * Gets the element at index `n` of `array`. If `n` is negative, the nth
 * element from the end is returned.
 *
 * @static
 * @memberOf _
 * @since 4.11.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=0] The index of the element to return.
 * @returns {*} Returns the nth element of `array`.
 * @example
 *
 * var array = ['a', 'b', 'c', 'd'];
 *
 * _.nth(array, 1);
 * // => 'b'
 *
 * _.nth(array, -2);
 * // => 'c';
 */
function nth(array, n) {
  return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
}

/**
 * Creates a function that gets the argument at index `n`. If `n` is negative,
 * the nth argument from the end is returned.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {number} [n=0] The index of the argument to return.
 * @returns {Function} Returns the new pass-thru function.
 * @example
 *
 * var func = _.nthArg(1);
 * func('a', 'b', 'c', 'd');
 * // => 'b'
 *
 * var func = _.nthArg(-2);
 * func('a', 'b', 'c', 'd');
 * // => 'c'
 */
function nthArg(n) {
  n = toInteger(n);
  return rest(function(args) {
    return baseNth(args, n);
  });
}

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, props) {
  object = Object(object);
  return arrayReduce(props, function(result, key) {
    if (key in object) {
      result[key] = object[key];
    }
    return result;
  }, {});
}

/** Built-in value references. */
var getOwnPropertySymbols$1 = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbol properties
 * of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !getOwnPropertySymbols$1 ? getSymbols$1 : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols$1(object));
    object = getPrototype(object);
  }
  return result;
};

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable string keyed properties of `object` that are
 * not omitted.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = rest(function(object, props) {
  if (object == null) {
    return {};
  }
  props = arrayMap(baseFlatten(props, 1), toKey);
  return basePick(object, baseDifference(getAllKeysIn(object), props));
});

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, predicate) {
  var index = -1,
      props = getAllKeysIn(object),
      length = props.length,
      result = {};

  while (++index < length) {
    var key = props[index],
        value = object[key];

    if (predicate(value, key)) {
      result[key] = value;
    }
  }
  return result;
}

/**
 * The opposite of `_.pickBy`; this method creates an object composed of
 * the own and inherited enumerable string keyed properties of `object` that
 * `predicate` doesn't return truthy for. The predicate is invoked with two
 * arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omitBy(object, _.isNumber);
 * // => { 'b': '2' }
 */
function omitBy(object, predicate) {
  predicate = baseIteratee(predicate);
  return basePickBy(object, function(value, key) {
    return !predicate(value, key);
  });
}

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // `initialize` invokes `createApplication` once
 */
function once(func) {
  return before(2, func);
}

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

/**
 * This method is like `_.sortBy` except that it allows specifying the sort
 * orders of the iteratees to sort by. If `orders` is unspecified, all values
 * are sorted in ascending order. Otherwise, specify an order of "desc" for
 * descending or "asc" for ascending sort order of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @param {string[]} [orders] The sort orders of `iteratees`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 34 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 36 }
 * ];
 *
 * // Sort by `user` in ascending order and by `age` in descending order.
 * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 */
function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }
  if (!isArray$1(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = guard ? undefined : orders;
  if (!isArray$1(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return baseOrderBy(collection, iteratees, orders);
}

/**
 * Checks if `value` is a flattenable array and not a `_.matchesProperty`
 * iteratee shorthand.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenableIteratee(value) {
  return isArray$1(value) && !(value.length == 2 && !isFunction(value[0]));
}

/**
 * Creates a function like `_.over`.
 *
 * @private
 * @param {Function} arrayFunc The function to iterate over iteratees.
 * @returns {Function} Returns the new over function.
 */
function createOver(arrayFunc) {
  return rest(function(iteratees) {
    iteratees = (iteratees.length == 1 && isArray$1(iteratees[0]))
      ? arrayMap(iteratees[0], baseUnary(baseIteratee))
      : arrayMap(baseFlatten(iteratees, 1, isFlattenableIteratee), baseUnary(baseIteratee));

    return rest(function(args) {
      var thisArg = this;
      return arrayFunc(iteratees, function(iteratee) {
        return apply(iteratee, thisArg, args);
      });
    });
  });
}

/**
 * Creates a function that invokes `iteratees` with the arguments it receives
 * and returns their results.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
 *  [iteratees=[_.identity]] The iteratees to invoke.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var func = _.over([Math.max, Math.min]);
 *
 * func(1, 2, 3, 4);
 * // => [4, 1]
 */
var over = createOver(arrayMap);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$8 = Math.min;

/**
 * Creates a function that invokes `func` with arguments transformed by
 * corresponding `transforms`.
 *
 * @static
 * @since 4.0.0
 * @memberOf _
 * @category Function
 * @param {Function} func The function to wrap.
 * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
 *  [transforms[_.identity]] The functions to transform.
 * @returns {Function} Returns the new function.
 * @example
 *
 * function doubled(n) {
 *   return n * 2;
 * }
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var func = _.overArgs(function(x, y) {
 *   return [x, y];
 * }, [square, doubled]);
 *
 * func(9, 3);
 * // => [81, 6]
 *
 * func(10, 5);
 * // => [100, 10]
 */
var overArgs = rest(function(func, transforms) {
  transforms = (transforms.length == 1 && isArray$1(transforms[0]))
    ? arrayMap(transforms[0], baseUnary(baseIteratee))
    : arrayMap(baseFlatten(transforms, 1, isFlattenableIteratee), baseUnary(baseIteratee));

  var funcsLength = transforms.length;
  return rest(function(args) {
    var this$1 = this;

    var index = -1,
        length = nativeMin$8(args.length, funcsLength);

    while (++index < length) {
      args[index] = transforms[index].call(this$1, args[index]);
    }
    return apply(func, this, args);
  });
});

/**
 * Creates a function that checks if **all** of the `predicates` return
 * truthy when invoked with the arguments it receives.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
 *  [predicates=[_.identity]] The predicates to check.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var func = _.overEvery([Boolean, isFinite]);
 *
 * func('1');
 * // => true
 *
 * func(null);
 * // => false
 *
 * func(NaN);
 * // => false
 */
var overEvery = createOver(arrayEvery);

/**
 * Creates a function that checks if **any** of the `predicates` return
 * truthy when invoked with the arguments it receives.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
 *  [predicates=[_.identity]] The predicates to check.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var func = _.overSome([Boolean, isFinite]);
 *
 * func('1');
 * // => true
 *
 * func(null);
 * // => true
 *
 * func(NaN);
 * // => false
 */
var overSome = createOver(arraySome);

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$3 = 9007199254740991;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor$1 = Math.floor;

/**
 * The base implementation of `_.repeat` which doesn't coerce arguments.
 *
 * @private
 * @param {string} string The string to repeat.
 * @param {number} n The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 */
function baseRepeat(string, n) {
  var result = '';
  if (!string || n < 1 || n > MAX_SAFE_INTEGER$3) {
    return result;
  }
  // Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do {
    if (n % 2) {
      result += string;
    }
    n = nativeFloor$1(n / 2);
    if (n) {
      string += string;
    }
  } while (n);

  return result;
}

/** Used to compose unicode character classes. */
var rsAstralRange$3 = '\\ud800-\\udfff';
var rsComboMarksRange$4 = '\\u0300-\\u036f\\ufe20-\\ufe23';
var rsComboSymbolsRange$4 = '\\u20d0-\\u20f0';
var rsVarRange$3 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral$1 = '[' + rsAstralRange$3 + ']';
var rsCombo$3 = '[' + rsComboMarksRange$4 + rsComboSymbolsRange$4 + ']';
var rsFitz$2 = '\\ud83c[\\udffb-\\udfff]';
var rsModifier$2 = '(?:' + rsCombo$3 + '|' + rsFitz$2 + ')';
var rsNonAstral$2 = '[^' + rsAstralRange$3 + ']';
var rsRegional$2 = '(?:\\ud83c[\\udde6-\\uddff]){2}';
var rsSurrPair$2 = '[\\ud800-\\udbff][\\udc00-\\udfff]';
var rsZWJ$3 = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod$2 = rsModifier$2 + '?';
var rsOptVar$2 = '[' + rsVarRange$3 + ']?';
var rsOptJoin$2 = '(?:' + rsZWJ$3 + '(?:' + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsOptVar$2 + reOptMod$2 + ')*';
var rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2;
var rsSymbol$1 = '(?:' + [rsNonAstral$2 + rsCombo$3 + '?', rsCombo$3, rsRegional$2, rsSurrPair$2, rsAstral$1].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reComplexSymbol$1 = RegExp(rsFitz$2 + '(?=' + rsFitz$2 + ')|' + rsSymbol$1 + rsSeq$2, 'g');

/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */
function stringSize(string) {
  if (!(string && reHasComplexSymbol.test(string))) {
    return string.length;
  }
  var result = reComplexSymbol$1.lastIndex = 0;
  while (reComplexSymbol$1.test(string)) {
    result++;
  }
  return result;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil$2 = Math.ceil;

/**
 * Creates the padding for `string` based on `length`. The `chars` string
 * is truncated if the number of characters exceeds `length`.
 *
 * @private
 * @param {number} length The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padding for `string`.
 */
function createPadding(length, chars) {
  chars = chars === undefined ? ' ' : baseToString(chars);

  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat(chars, length) : chars;
  }
  var result = baseRepeat(chars, nativeCeil$2(length / stringSize(chars)));
  return reHasComplexSymbol.test(chars)
    ? castSlice(stringToArray(result), 0, length).join('')
    : result.slice(0, length);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil$1 = Math.ceil;
var nativeFloor = Math.floor;

/**
 * Pads `string` on the left and right sides if it's shorter than `length`.
 * Padding characters are truncated if they can't be evenly divided by `length`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.pad('abc', 8);
 * // => '  abc   '
 *
 * _.pad('abc', 8, '_-');
 * // => '_-abc_-_'
 *
 * _.pad('abc', 3);
 * // => 'abc'
 */
function pad(string, length, chars) {
  string = toString(string);
  length = toInteger(length);

  var strLength = length ? stringSize(string) : 0;
  if (!length || strLength >= length) {
    return string;
  }
  var mid = (length - strLength) / 2;
  return (
    createPadding(nativeFloor(mid), chars) +
    string +
    createPadding(nativeCeil$1(mid), chars)
  );
}

/**
 * Pads `string` on the right side if it's shorter than `length`. Padding
 * characters are truncated if they exceed `length`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.padEnd('abc', 6);
 * // => 'abc   '
 *
 * _.padEnd('abc', 6, '_-');
 * // => 'abc_-_'
 *
 * _.padEnd('abc', 3);
 * // => 'abc'
 */
function padEnd(string, length, chars) {
  string = toString(string);
  length = toInteger(length);

  var strLength = length ? stringSize(string) : 0;
  return (length && strLength < length)
    ? (string + createPadding(length - strLength, chars))
    : string;
}

/**
 * Pads `string` on the left side if it's shorter than `length`. Padding
 * characters are truncated if they exceed `length`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.padStart('abc', 6);
 * // => '   abc'
 *
 * _.padStart('abc', 6, '_-');
 * // => '_-_abc'
 *
 * _.padStart('abc', 3);
 * // => 'abc'
 */
function padStart(string, length, chars) {
  string = toString(string);
  length = toInteger(length);

  var strLength = length ? stringSize(string) : 0;
  return (length && strLength < length)
    ? (createPadding(length - strLength, chars) + string)
    : string;
}

/** Used to match leading and trailing whitespace. */
var reTrim$1 = /^\s+|\s+$/g;

/** Used to detect hexadecimal string values. */
var reHasHexPrefix = /^0x/i;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeParseInt = root.parseInt;

/**
 * Converts `string` to an integer of the specified radix. If `radix` is
 * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
 * hexadecimal, in which case a `radix` of `16` is used.
 *
 * **Note:** This method aligns with the
 * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category String
 * @param {string} string The string to convert.
 * @param {number} [radix=10] The radix to interpret `value` by.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.parseInt('08');
 * // => 8
 *
 * _.map(['6', '08', '10'], _.parseInt);
 * // => [6, 8, 10]
 */
function parseInt$1(string, radix, guard) {
  // Chrome fails to trim leading <BOM> whitespace characters.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=3109 for more details.
  if (guard || radix == null) {
    radix = 0;
  } else if (radix) {
    radix = +radix;
  }
  string = toString(string).replace(reTrim$1, '');
  return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
}

/** Used to compose bitmasks for wrapper metadata. */
var PARTIAL_FLAG$5 = 32;

/**
 * Creates a function that invokes `func` with `partials` prepended to the
 * arguments it receives. This method is like `_.bind` except it does **not**
 * alter the `this` binding.
 *
 * The `_.partial.placeholder` value, which defaults to `_` in monolithic
 * builds, may be used as a placeholder for partially applied arguments.
 *
 * **Note:** This method doesn't set the "length" property of partially
 * applied functions.
 *
 * @static
 * @memberOf _
 * @since 0.2.0
 * @category Function
 * @param {Function} func The function to partially apply arguments to.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new partially applied function.
 * @example
 *
 * var greet = function(greeting, name) {
 *   return greeting + ' ' + name;
 * };
 *
 * var sayHelloTo = _.partial(greet, 'hello');
 * sayHelloTo('fred');
 * // => 'hello fred'
 *
 * // Partially applied with placeholders.
 * var greetFred = _.partial(greet, _, 'fred');
 * greetFred('hi');
 * // => 'hi fred'
 */
var partial = rest(function(func, partials) {
  var holders = replaceHolders(partials, getHolder(partial));
  return createWrapper(func, PARTIAL_FLAG$5, undefined, partials, holders);
});

// Assign default placeholders.
partial.placeholder = {};

/** Used to compose bitmasks for wrapper metadata. */
var PARTIAL_RIGHT_FLAG$2 = 64;

/**
 * This method is like `_.partial` except that partially applied arguments
 * are appended to the arguments it receives.
 *
 * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
 * builds, may be used as a placeholder for partially applied arguments.
 *
 * **Note:** This method doesn't set the "length" property of partially
 * applied functions.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Function
 * @param {Function} func The function to partially apply arguments to.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new partially applied function.
 * @example
 *
 * var greet = function(greeting, name) {
 *   return greeting + ' ' + name;
 * };
 *
 * var greetFred = _.partialRight(greet, 'fred');
 * greetFred('hi');
 * // => 'hi fred'
 *
 * // Partially applied with placeholders.
 * var sayHelloTo = _.partialRight(greet, 'hello', _);
 * sayHelloTo('fred');
 * // => 'hello fred'
 */
var partialRight = rest(function(func, partials) {
  var holders = replaceHolders(partials, getHolder(partialRight));
  return createWrapper(func, PARTIAL_RIGHT_FLAG$2, undefined, partials, holders);
});

// Assign default placeholders.
partialRight.placeholder = {};

/**
 * Creates an array of elements split into two groups, the first of which
 * contains elements `predicate` returns truthy for, the second of which
 * contains elements `predicate` returns falsey for. The predicate is
 * invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the array of grouped elements.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': false },
 *   { 'user': 'fred',    'age': 40, 'active': true },
 *   { 'user': 'pebbles', 'age': 1,  'active': false }
 * ];
 *
 * _.partition(users, function(o) { return o.active; });
 * // => objects for [['fred'], ['barney', 'pebbles']]
 *
 * // The `_.matches` iteratee shorthand.
 * _.partition(users, { 'age': 1, 'active': false });
 * // => objects for [['pebbles'], ['barney', 'fred']]
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.partition(users, ['active', false]);
 * // => objects for [['barney', 'pebbles'], ['fred']]
 *
 * // The `_.property` iteratee shorthand.
 * _.partition(users, 'active');
 * // => objects for [['fred'], ['barney', 'pebbles']]
 */
var partition = createAggregator(function(result, value, key) {
  result[key ? 0 : 1].push(value);
}, function() { return [[], []]; });

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = rest(function(object, props) {
  return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
});

/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 */
function pickBy(object, predicate) {
  return object == null ? {} : basePickBy(object, baseIteratee(predicate));
}

/**
 * Creates a clone of the chain sequence planting `value` as the wrapped value.
 *
 * @name plant
 * @memberOf _
 * @since 3.2.0
 * @category Seq
 * @param {*} value The value to plant.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var wrapped = _([1, 2]).map(square);
 * var other = wrapped.plant([3, 4]);
 *
 * other.value();
 * // => [9, 16]
 *
 * wrapped.value();
 * // => [1, 4]
 */
function wrapperPlant(value) {
  var result,
      parent = this;

  while (parent instanceof baseLodash) {
    var clone = wrapperClone(parent);
    clone.__index__ = 0;
    clone.__values__ = undefined;
    if (result) {
      previous.__wrapped__ = clone;
    } else {
      result = clone;
    }
    var previous = clone;
    parent = parent.__wrapped__;
  }
  previous.__wrapped__ = value;
  return result;
}

/**
 * The opposite of `_.property`; this method creates a function that returns
 * the value at a given path of `object`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var array = [0, 1, 2],
 *     object = { 'a': array, 'b': array, 'c': array };
 *
 * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
 * // => [2, 0]
 *
 * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
 * // => [2, 0]
 */
function propertyOf(object) {
  return function(path) {
    return object == null ? undefined : baseGet(object, path);
  };
}

/**
 * This function is like `baseIndexOf` except that it accepts a comparator.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOfWith(array, value, fromIndex, comparator) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (comparator(array[index], value)) {
      return index;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto$2 = Array.prototype;

/** Built-in value references. */
var splice$1 = arrayProto$2.splice;

/**
 * The base implementation of `_.pullAllBy` without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns `array`.
 */
function basePullAll(array, values, iteratee, comparator) {
  var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
      index = -1,
      length = values.length,
      seen = array;

  if (array === values) {
    values = copyArray(values);
  }
  if (iteratee) {
    seen = arrayMap(array, baseUnary(iteratee));
  }
  while (++index < length) {
    var fromIndex = 0,
        value = values[index],
        computed = iteratee ? iteratee(value) : value;

    while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice$1.call(seen, fromIndex, 1);
      }
      splice$1.call(array, fromIndex, 1);
    }
  }
  return array;
}

/**
 * This method is like `_.pull` except that it accepts an array of values to remove.
 *
 * **Note:** Unlike `_.difference`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
 *
 * _.pullAll(array, ['a', 'c']);
 * console.log(array);
 * // => ['b', 'b']
 */
function pullAll(array, values) {
  return (array && array.length && values && values.length)
    ? basePullAll(array, values)
    : array;
}

/**
 * Removes all given values from `array` using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
 * to remove elements from an array by predicate.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {...*} [values] The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
 *
 * _.pull(array, 'a', 'c');
 * console.log(array);
 * // => ['b', 'b']
 */
var pull = rest(pullAll);

/**
 * This method is like `_.pullAll` except that it accepts `iteratee` which is
 * invoked for each element of `array` and `values` to generate the criterion
 * by which they're compared. The iteratee is invoked with one argument: (value).
 *
 * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
 *
 * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
 * console.log(array);
 * // => [{ 'x': 2 }]
 */
function pullAllBy(array, values, iteratee) {
  return (array && array.length && values && values.length)
    ? basePullAll(array, values, baseIteratee(iteratee))
    : array;
}

/**
 * This method is like `_.pullAll` except that it accepts `comparator` which
 * is invoked to compare elements of `array` to `values`. The comparator is
 * invoked with two arguments: (arrVal, othVal).
 *
 * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.6.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
 *
 * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
 * console.log(array);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
 */
function pullAllWith(array, values, comparator) {
  return (array && array.length && values && values.length)
    ? basePullAll(array, values, undefined, comparator)
    : array;
}

/** Used for built-in method references. */
var arrayProto$3 = Array.prototype;

/** Built-in value references. */
var splice$2 = arrayProto$3.splice;

/**
 * The base implementation of `_.pullAt` without support for individual
 * indexes or capturing the removed elements.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {number[]} indexes The indexes of elements to remove.
 * @returns {Array} Returns `array`.
 */
function basePullAt(array, indexes) {
  var length = array ? indexes.length : 0,
      lastIndex = length - 1;

  while (length--) {
    var index = indexes[length];
    if (length == lastIndex || index !== previous) {
      var previous = index;
      if (isIndex(index)) {
        splice$2.call(array, index, 1);
      }
      else if (!isKey(index, array)) {
        var path = castPath(index),
            object = parent(array, path);

        if (object != null) {
          delete object[toKey(last(path))];
        }
      }
      else {
        delete array[toKey(index)];
      }
    }
  }
  return array;
}

/**
 * Removes elements from `array` corresponding to `indexes` and returns an
 * array of removed elements.
 *
 * **Note:** Unlike `_.at`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {...(number|number[])} [indexes] The indexes of elements to remove.
 * @returns {Array} Returns the new array of removed elements.
 * @example
 *
 * var array = ['a', 'b', 'c', 'd'];
 * var pulled = _.pullAt(array, [1, 3]);
 *
 * console.log(array);
 * // => ['a', 'c']
 *
 * console.log(pulled);
 * // => ['b', 'd']
 */
var pullAt = rest(function(array, indexes) {
  indexes = baseFlatten(indexes, 1);

  var length = array ? array.length : 0,
      result = baseAt(array, indexes);

  basePullAt(array, arrayMap(indexes, function(index) {
    return isIndex(index, length) ? +index : index;
  }).sort(compareAscending));

  return result;
});

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor$2 = Math.floor;
var nativeRandom$1 = Math.random;

/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */
function baseRandom(lower, upper) {
  return lower + nativeFloor$2(nativeRandom$1() * (upper - lower + 1));
}

/** Built-in method references without a dependency on `root`. */
var freeParseFloat = parseFloat;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$9 = Math.min;
var nativeRandom = Math.random;

/**
 * Produces a random number between the inclusive `lower` and `upper` bounds.
 * If only one argument is provided a number between `0` and the given number
 * is returned. If `floating` is `true`, or either `lower` or `upper` are
 * floats, a floating-point number is returned instead of an integer.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @memberOf _
 * @since 0.7.0
 * @category Number
 * @param {number} [lower=0] The lower bound.
 * @param {number} [upper=1] The upper bound.
 * @param {boolean} [floating] Specify returning a floating-point number.
 * @returns {number} Returns the random number.
 * @example
 *
 * _.random(0, 5);
 * // => an integer between 0 and 5
 *
 * _.random(5);
 * // => also an integer between 0 and 5
 *
 * _.random(5, true);
 * // => a floating-point number between 0 and 5
 *
 * _.random(1.2, 5.2);
 * // => a floating-point number between 1.2 and 5.2
 */
function random(lower, upper, floating) {
  if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
    upper = floating = undefined;
  }
  if (floating === undefined) {
    if (typeof upper == 'boolean') {
      floating = upper;
      upper = undefined;
    }
    else if (typeof lower == 'boolean') {
      floating = lower;
      lower = undefined;
    }
  }
  if (lower === undefined && upper === undefined) {
    lower = 0;
    upper = 1;
  }
  else {
    lower = toNumber(lower) || 0;
    if (upper === undefined) {
      upper = lower;
      lower = 0;
    } else {
      upper = toNumber(upper) || 0;
    }
  }
  if (lower > upper) {
    var temp = lower;
    lower = upper;
    upper = temp;
  }
  if (floating || lower % 1 || upper % 1) {
    var rand = nativeRandom();
    return nativeMin$9(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
  }
  return baseRandom(lower, upper);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil$3 = Math.ceil;
var nativeMax$12 = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments to numbers.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax$12(nativeCeil$3((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toNumber(start);
    start = start === start ? start : 0;
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toNumber(end) || 0;
    }
    step = step === undefined ? (start < end ? 1 : -1) : (toNumber(step) || 0);
    return baseRange(start, end, step, fromRight);
  };
}

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range$1 = createRange();

/**
 * This method is like `_.range` except that it populates values in
 * descending order.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.range
 * @example
 *
 * _.rangeRight(4);
 * // => [3, 2, 1, 0]
 *
 * _.rangeRight(-4);
 * // => [-3, -2, -1, 0]
 *
 * _.rangeRight(1, 5);
 * // => [4, 3, 2, 1]
 *
 * _.rangeRight(0, 20, 5);
 * // => [15, 10, 5, 0]
 *
 * _.rangeRight(0, -4, -1);
 * // => [-3, -2, -1, 0]
 *
 * _.rangeRight(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.rangeRight(0);
 * // => []
 */
var rangeRight = createRange(true);

/** Used to compose bitmasks for wrapper metadata. */
var REARG_FLAG$2 = 256;

/**
 * Creates a function that invokes `func` with arguments arranged according
 * to the specified `indexes` where the argument value at the first index is
 * provided as the first argument, the argument value at the second index is
 * provided as the second argument, and so on.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} func The function to rearrange arguments for.
 * @param {...(number|number[])} indexes The arranged argument indexes.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var rearged = _.rearg(function(a, b, c) {
 *   return [a, b, c];
 * }, [2, 0, 1]);
 *
 * rearged('b', 'c', 'a')
 * // => ['a', 'b', 'c']
 */
var rearg = rest(function(func, indexes) {
  return createWrapper(func, REARG_FLAG$2, undefined, undefined, undefined, baseFlatten(indexes, 1));
});

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
  var func = isArray$1(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

/**
 * A specialized version of `_.reduceRight` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the last element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduceRight(array, iteratee, accumulator, initAccum) {
  var length = array ? array.length : 0;
  if (initAccum && length) {
    accumulator = array[--length];
  }
  while (length--) {
    accumulator = iteratee(accumulator, array[length], length, array);
  }
  return accumulator;
}

/**
 * This method is like `_.reduce` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduce
 * @example
 *
 * var array = [[0, 1], [2, 3], [4, 5]];
 *
 * _.reduceRight(array, function(flattened, other) {
 *   return flattened.concat(other);
 * }, []);
 * // => [4, 5, 2, 3, 0, 1]
 */
function reduceRight(collection, iteratee, accumulator) {
  var func = isArray$1(collection) ? arrayReduceRight : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
}

/**
 * The opposite of `_.filter`; this method returns the elements of `collection`
 * that `predicate` does **not** return truthy for.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.filter
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': true }
 * ];
 *
 * _.reject(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.reject(users, { 'age': 40, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.reject(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.reject(users, 'active');
 * // => objects for ['barney']
 */
function reject(collection, predicate) {
  var func = isArray$1(collection) ? arrayFilter : baseFilter;
  predicate = baseIteratee(predicate, 3);
  return func(collection, function(value, index, collection) {
    return !predicate(value, index, collection);
  });
}

/**
 * Removes all elements from `array` that `predicate` returns truthy for
 * and returns an array of the removed elements. The predicate is invoked
 * with three arguments: (value, index, array).
 *
 * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
 * to pull elements from an array by value.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the new array of removed elements.
 * @example
 *
 * var array = [1, 2, 3, 4];
 * var evens = _.remove(array, function(n) {
 *   return n % 2 == 0;
 * });
 *
 * console.log(array);
 * // => [1, 3]
 *
 * console.log(evens);
 * // => [2, 4]
 */
function remove(array, predicate) {
  var result = [];
  if (!(array && array.length)) {
    return result;
  }
  var index = -1,
      indexes = [],
      length = array.length;

  predicate = baseIteratee(predicate, 3);
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result.push(value);
      indexes.push(index);
    }
  }
  basePullAt(array, indexes);
  return result;
}

/**
 * Repeats the given string `n` times.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to repeat.
 * @param {number} [n=1] The number of times to repeat the string.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the repeated string.
 * @example
 *
 * _.repeat('*', 3);
 * // => '***'
 *
 * _.repeat('abc', 2);
 * // => 'abcabc'
 *
 * _.repeat('abc', 0);
 * // => ''
 */
function repeat(string, n, guard) {
  if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
    n = 1;
  } else {
    n = toInteger(n);
  }
  return baseRepeat(toString(string), n);
}

/** Used for built-in method references. */
var stringProto = String.prototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeReplace = stringProto.replace;

/**
 * Replaces matches for `pattern` in `string` with `replacement`.
 *
 * **Note:** This method is based on
 * [`String#replace`](https://mdn.io/String/replace).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to modify.
 * @param {RegExp|string} pattern The pattern to replace.
 * @param {Function|string} replacement The match replacement.
 * @returns {string} Returns the modified string.
 * @example
 *
 * _.replace('Hi Fred', 'Fred', 'Barney');
 * // => 'Hi Barney'
 */
function replace() {
  var args = arguments,
      string = toString(args[0]);

  return args.length < 3 ? string : nativeReplace.call(string, args[1], args[2]);
}

/**
 * This method is like `_.get` except that if the resolved value is a
 * function it's invoked with the `this` binding of its parent object and
 * its result is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to resolve.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
 *
 * _.result(object, 'a[0].b.c1');
 * // => 3
 *
 * _.result(object, 'a[0].b.c2');
 * // => 4
 *
 * _.result(object, 'a[0].b.c3', 'default');
 * // => 'default'
 *
 * _.result(object, 'a[0].b.c3', _.constant('default'));
 * // => 'default'
 */
function result(object, path, defaultValue) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = -1,
      length = path.length;

  // Ensure the loop is entered when path is empty.
  if (!length) {
    object = undefined;
    length = 1;
  }
  while (++index < length) {
    var value = object == null ? undefined : object[toKey(path[index])];
    if (value === undefined) {
      index = length;
      value = defaultValue;
    }
    object = isFunction(value) ? value.call(object) : value;
  }
  return object;
}

/** Used for built-in method references. */
var arrayProto$4 = Array.prototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeReverse = arrayProto$4.reverse;

/**
 * Reverses `array` so that the first element becomes the last, the second
 * element becomes the second to last, and so on.
 *
 * **Note:** This method mutates `array` and is based on
 * [`Array#reverse`](https://mdn.io/Array/reverse).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [1, 2, 3];
 *
 * _.reverse(array);
 * // => [3, 2, 1]
 *
 * console.log(array);
 * // => [3, 2, 1]
 */
function reverse(array) {
  return array ? nativeReverse.call(array) : array;
}

/**
 * Computes `number` rounded to `precision`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Math
 * @param {number} number The number to round.
 * @param {number} [precision=0] The precision to round to.
 * @returns {number} Returns the rounded number.
 * @example
 *
 * _.round(4.006);
 * // => 4
 *
 * _.round(4.006, 2);
 * // => 4.01
 *
 * _.round(4060, -2);
 * // => 4100
 */
var round = createRound('round');

/**
 * Gets a random element from `collection`.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to sample.
 * @returns {*} Returns the random element.
 * @example
 *
 * _.sample([1, 2, 3, 4]);
 * // => 2
 */
function sample(collection) {
  var array = isArrayLike(collection) ? collection : values(collection),
      length = array.length;

  return length > 0 ? array[baseRandom(0, length - 1)] : undefined;
}

/**
 * Gets `n` random elements at unique keys from `collection` up to the
 * size of `collection`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to sample.
 * @param {number} [n=1] The number of elements to sample.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the random elements.
 * @example
 *
 * _.sampleSize([1, 2, 3], 2);
 * // => [3, 1]
 *
 * _.sampleSize([1, 2, 3], 4);
 * // => [2, 3, 1]
 */
function sampleSize(collection, n, guard) {
  var index = -1,
      result = toArray(collection),
      length = result.length,
      lastIndex = length - 1;

  if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
    n = 1;
  } else {
    n = baseClamp(toInteger(n), 0, length);
  }
  while (++index < n) {
    var rand = baseRandom(index, lastIndex),
        value = result[rand];

    result[rand] = result[index];
    result[index] = value;
  }
  result.length = n;
  return result;
}

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$2 = 4294967295;

/**
 * Creates an array of shuffled values, using a version of the
 * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to shuffle.
 * @returns {Array} Returns the new shuffled array.
 * @example
 *
 * _.shuffle([1, 2, 3, 4]);
 * // => [4, 1, 3, 2]
 */
function shuffle(collection) {
  return sampleSize(collection, MAX_ARRAY_LENGTH$2);
}

/** `Object#toString` result references. */
var mapTag$9 = '[object Map]';
var setTag$9 = '[object Set]';

/**
 * Gets the size of `collection` by returning its length for array-like
 * values or the number of own enumerable string keyed properties for objects.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @returns {number} Returns the collection size.
 * @example
 *
 * _.size([1, 2, 3]);
 * // => 3
 *
 * _.size({ 'a': 1, 'b': 2 });
 * // => 2
 *
 * _.size('pebbles');
 * // => 7
 */
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike(collection)) {
    var result = collection.length;
    return (result && isString$1(collection)) ? stringSize(collection) : result;
  }
  if (isObjectLike(collection)) {
    var tag = getTag$1(collection);
    if (tag == mapTag$9 || tag == setTag$9) {
      return collection.size;
    }
  }
  return keys$1(collection).length;
}

/**
 * Creates a slice of `array` from `start` up to, but not including, `end`.
 *
 * **Note:** This method is used instead of
 * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
 * returned.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function slice(array, start, end) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
    start = 0;
    end = length;
  }
  else {
    start = start == null ? 0 : toInteger(start);
    end = end === undefined ? length : toInteger(end);
  }
  return baseSlice(array, start, end);
}

/**
 * Converts `string` to
 * [snake case](https://en.wikipedia.org/wiki/Snake_case).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the snake cased string.
 * @example
 *
 * _.snakeCase('Foo Bar');
 * // => 'foo_bar'
 *
 * _.snakeCase('fooBar');
 * // => 'foo_bar'
 *
 * _.snakeCase('--FOO-BAR--');
 * // => 'foo_bar'
 */
var snakeCase = createCompounder(function(result, word, index) {
  return result + (index ? '_' : '') + word.toLowerCase();
});

/**
 * The base implementation of `_.some` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function baseSome(collection, predicate) {
  var result;

  baseEach(collection, function(value, index, collection) {
    result = predicate(value, index, collection);
    return !result;
  });
  return !!result;
}

/**
 * Checks if `predicate` returns truthy for **any** element of `collection`.
 * Iteration is stopped once `predicate` returns truthy. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 * @example
 *
 * _.some([null, 0, 'yes', false], Boolean);
 * // => true
 *
 * var users = [
 *   { 'user': 'barney', 'active': true },
 *   { 'user': 'fred',   'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.some(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.some(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.some(users, 'active');
 * // => true
 */
function some(collection, predicate, guard) {
  var func = isArray$1(collection) ? arraySome : baseSome;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = undefined;
  }
  return func(collection, baseIteratee(predicate, 3));
}

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])}
 *  [iteratees=[_.identity]] The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, function(o) { return o.user; });
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 *
 * _.sortBy(users, 'user', function(o) {
 *   return Math.floor(o.age / 10);
 * });
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 */
var sortBy = rest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  iteratees = (iteratees.length == 1 && isArray$1(iteratees[0]))
    ? iteratees[0]
    : baseFlatten(iteratees, 1, isFlattenableIteratee);

  return baseOrderBy(collection, iteratees, []);
});

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$4 = 4294967295;
var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH$4 - 1;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor$3 = Math.floor;
var nativeMin$10 = Math.min;

/**
 * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
 * which invokes `iteratee` for `value` and each element of `array` to compute
 * their sort ranking. The iteratee is invoked with one argument; (value).
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} iteratee The iteratee invoked per element.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */
function baseSortedIndexBy(array, value, iteratee, retHighest) {
  value = iteratee(value);

  var low = 0,
      high = array ? array.length : 0,
      valIsNaN = value !== value,
      valIsNull = value === null,
      valIsSymbol = isSymbol(value),
      valIsUndefined = value === undefined;

  while (low < high) {
    var mid = nativeFloor$3((low + high) / 2),
        computed = iteratee(array[mid]),
        othIsDefined = computed !== undefined,
        othIsNull = computed === null,
        othIsReflexive = computed === computed,
        othIsSymbol = isSymbol(computed);

    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? (computed <= value) : (computed < value);
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin$10(high, MAX_ARRAY_INDEX);
}

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$3 = 4294967295;
var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH$3 >>> 1;

/**
 * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
 * performs a binary search of `array` to determine the index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */
function baseSortedIndex(array, value, retHighest) {
  var low = 0,
      high = array ? array.length : low;

  if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = (low + high) >>> 1,
          computed = array[mid];

      if (computed !== null && !isSymbol(computed) &&
          (retHighest ? (computed <= value) : (computed < value))) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return baseSortedIndexBy(array, value, identity, retHighest);
}

/**
 * Uses a binary search to determine the lowest index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * _.sortedIndex([30, 50], 40);
 * // => 1
 */
function sortedIndex(array, value) {
  return baseSortedIndex(array, value);
}

/**
 * This method is like `_.sortedIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * var objects = [{ 'x': 4 }, { 'x': 5 }];
 *
 * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
 * // => 0
 */
function sortedIndexBy(array, value, iteratee) {
  return baseSortedIndexBy(array, value, baseIteratee(iteratee));
}

/**
 * This method is like `_.indexOf` except that it performs a binary
 * search on a sorted `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
 * // => 1
 */
function sortedIndexOf(array, value) {
  var length = array ? array.length : 0;
  if (length) {
    var index = baseSortedIndex(array, value);
    if (index < length && eq(array[index], value)) {
      return index;
    }
  }
  return -1;
}

/**
 * This method is like `_.sortedIndex` except that it returns the highest
 * index at which `value` should be inserted into `array` in order to
 * maintain its sort order.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
 * // => 4
 */
function sortedLastIndex(array, value) {
  return baseSortedIndex(array, value, true);
}

/**
 * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * var objects = [{ 'x': 4 }, { 'x': 5 }];
 *
 * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
 * // => 1
 *
 * // The `_.property` iteratee shorthand.
 * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
 * // => 1
 */
function sortedLastIndexBy(array, value, iteratee) {
  return baseSortedIndexBy(array, value, baseIteratee(iteratee), true);
}

/**
 * This method is like `_.lastIndexOf` except that it performs a binary
 * search on a sorted `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
 * // => 3
 */
function sortedLastIndexOf(array, value) {
  var length = array ? array.length : 0;
  if (length) {
    var index = baseSortedIndex(array, value, true) - 1;
    if (eq(array[index], value)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseSortedUniq(array, iteratee) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    if (!index || !eq(computed, seen)) {
      var seen = computed;
      result[resIndex++] = value === 0 ? 0 : value;
    }
  }
  return result;
}

/**
 * This method is like `_.uniq` except that it's designed and optimized
 * for sorted arrays.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.sortedUniq([1, 1, 2]);
 * // => [1, 2]
 */
function sortedUniq(array) {
  return (array && array.length)
    ? baseSortedUniq(array)
    : [];
}

/**
 * This method is like `_.uniqBy` except that it's designed and optimized
 * for sorted arrays.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
 * // => [1.1, 2.3]
 */
function sortedUniqBy(array, iteratee) {
  return (array && array.length)
    ? baseSortedUniq(array, baseIteratee(iteratee))
    : [];
}

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$5 = 4294967295;

/** Used for built-in method references. */
var stringProto$1 = String.prototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeSplit = stringProto$1.split;

/**
 * Splits `string` by `separator`.
 *
 * **Note:** This method is based on
 * [`String#split`](https://mdn.io/String/split).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to split.
 * @param {RegExp|string} separator The separator pattern to split by.
 * @param {number} [limit] The length to truncate results to.
 * @returns {Array} Returns the string segments.
 * @example
 *
 * _.split('a-b-c', '-', 2);
 * // => ['a', 'b']
 */
function split(string, separator, limit) {
  if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
    separator = limit = undefined;
  }
  limit = limit === undefined ? MAX_ARRAY_LENGTH$5 : limit >>> 0;
  if (!limit) {
    return [];
  }
  string = toString(string);
  if (string && (
        typeof separator == 'string' ||
        (separator != null && !isRegExp(separator))
      )) {
    separator = baseToString(separator);
    if (separator == '' && reHasComplexSymbol.test(string)) {
      return castSlice(stringToArray(string), 0, limit);
    }
  }
  return nativeSplit.call(string, separator, limit);
}

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$10 = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$13 = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * create function and an array of arguments much like
 * [`Function#apply`](http://www.ecma-international.org/ecma-262/6.0/#sec-function.prototype.apply).
 *
 * **Note:** This method is based on the
 * [spread operator](https://mdn.io/spread_operator).
 *
 * @static
 * @memberOf _
 * @since 3.2.0
 * @category Function
 * @param {Function} func The function to spread arguments over.
 * @param {number} [start=0] The start position of the spread.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.spread(function(who, what) {
 *   return who + ' says ' + what;
 * });
 *
 * say(['fred', 'hello']);
 * // => 'fred says hello'
 *
 * var numbers = Promise.all([
 *   Promise.resolve(40),
 *   Promise.resolve(36)
 * ]);
 *
 * numbers.then(_.spread(function(x, y) {
 *   return x + y;
 * }));
 * // => a Promise of 76
 */
function spread(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$10);
  }
  start = start === undefined ? 0 : nativeMax$13(toInteger(start), 0);
  return rest(function(args) {
    var array = args[start],
        otherArgs = castSlice(args, 0, start);

    if (array) {
      arrayPush(otherArgs, array);
    }
    return apply(func, this, otherArgs);
  });
}

/**
 * Converts `string` to
 * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
 *
 * @static
 * @memberOf _
 * @since 3.1.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the start cased string.
 * @example
 *
 * _.startCase('--foo-bar--');
 * // => 'Foo Bar'
 *
 * _.startCase('fooBar');
 * // => 'Foo Bar'
 *
 * _.startCase('__FOO_BAR__');
 * // => 'FOO BAR'
 */
var startCase = createCompounder(function(result, word, index) {
  return result + (index ? ' ' : '') + upperFirst(word);
});

/**
 * Checks if `string` starts with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to search.
 * @param {string} [target] The string to search for.
 * @param {number} [position=0] The position to search from.
 * @returns {boolean} Returns `true` if `string` starts with `target`,
 *  else `false`.
 * @example
 *
 * _.startsWith('abc', 'a');
 * // => true
 *
 * _.startsWith('abc', 'b');
 * // => false
 *
 * _.startsWith('abc', 'b', 1);
 * // => true
 */
function startsWith(string, target, position) {
  string = toString(string);
  position = baseClamp(toInteger(position), 0, string.length);
  return string.lastIndexOf(baseToString(target), position) == position;
}

/**
 * A method that returns a new empty object.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Object} Returns the new empty object.
 * @example
 *
 * var objects = _.times(2, _.stubObject);
 *
 * console.log(objects);
 * // => [{}, {}]
 *
 * console.log(objects[0] === objects[1]);
 * // => false
 */
function stubObject() {
  return {};
}

/**
 * A method that returns an empty string.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {string} Returns the empty string.
 * @example
 *
 * _.times(2, _.stubString);
 * // => ['', '']
 */
function stubString() {
  return '';
}

/**
 * A method that returns `true`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `true`.
 * @example
 *
 * _.times(2, _.stubTrue);
 * // => [true, true]
 */
function stubTrue() {
  return true;
}

/**
 * Subtract two numbers.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {number} minuend The first number in a subtraction.
 * @param {number} subtrahend The second number in a subtraction.
 * @returns {number} Returns the difference.
 * @example
 *
 * _.subtract(6, 4);
 * // => 2
 */
var subtract = createMathOperation(function(minuend, subtrahend) {
  return minuend - subtrahend;
});

/**
 * Computes the sum of the values in `array`.
 *
 * @static
 * @memberOf _
 * @since 3.4.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the sum.
 * @example
 *
 * _.sum([4, 2, 8, 6]);
 * // => 20
 */
function sum$1(array) {
  return (array && array.length)
    ? baseSum(array, identity)
    : 0;
}

/**
 * This method is like `_.sum` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the value to be summed.
 * The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {number} Returns the sum.
 * @example
 *
 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
 *
 * _.sumBy(objects, function(o) { return o.n; });
 * // => 20
 *
 * // The `_.property` iteratee shorthand.
 * _.sumBy(objects, 'n');
 * // => 20
 */
function sumBy(array, iteratee) {
  return (array && array.length)
    ? baseSum(array, baseIteratee(iteratee))
    : 0;
}

/**
 * Gets all but the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.tail([1, 2, 3]);
 * // => [2, 3]
 */
function tail(array) {
  return drop(array, 1);
}

/**
 * Creates a slice of `array` with `n` elements taken from the beginning.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to take.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.take([1, 2, 3]);
 * // => [1]
 *
 * _.take([1, 2, 3], 2);
 * // => [1, 2]
 *
 * _.take([1, 2, 3], 5);
 * // => [1, 2, 3]
 *
 * _.take([1, 2, 3], 0);
 * // => []
 */
function take(array, n, guard) {
  if (!(array && array.length)) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : toInteger(n);
  return baseSlice(array, 0, n < 0 ? 0 : n);
}

/**
 * Creates a slice of `array` with `n` elements taken from the end.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to take.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.takeRight([1, 2, 3]);
 * // => [3]
 *
 * _.takeRight([1, 2, 3], 2);
 * // => [2, 3]
 *
 * _.takeRight([1, 2, 3], 5);
 * // => [1, 2, 3]
 *
 * _.takeRight([1, 2, 3], 0);
 * // => []
 */
function takeRight(array, n, guard) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : toInteger(n);
  n = length - n;
  return baseSlice(array, n < 0 ? 0 : n, length);
}

/**
 * Creates a slice of `array` with elements taken from the end. Elements are
 * taken until `predicate` returns falsey. The predicate is invoked with
 * three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.takeRightWhile(users, function(o) { return !o.active; });
 * // => objects for ['fred', 'pebbles']
 *
 * // The `_.matches` iteratee shorthand.
 * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
 * // => objects for ['pebbles']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.takeRightWhile(users, ['active', false]);
 * // => objects for ['fred', 'pebbles']
 *
 * // The `_.property` iteratee shorthand.
 * _.takeRightWhile(users, 'active');
 * // => []
 */
function takeRightWhile(array, predicate) {
  return (array && array.length)
    ? baseWhile(array, baseIteratee(predicate, 3), false, true)
    : [];
}

/**
 * Creates a slice of `array` with elements taken from the beginning. Elements
 * are taken until `predicate` returns falsey. The predicate is invoked with
 * three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false},
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.takeWhile(users, function(o) { return !o.active; });
 * // => objects for ['barney', 'fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.takeWhile(users, { 'user': 'barney', 'active': false });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.takeWhile(users, ['active', false]);
 * // => objects for ['barney', 'fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.takeWhile(users, 'active');
 * // => []
 */
function takeWhile(array, predicate) {
  return (array && array.length)
    ? baseWhile(array, baseIteratee(predicate, 3))
    : [];
}

/**
 * This method invokes `interceptor` and returns `value`. The interceptor
 * is invoked with one argument; (value). The purpose of this method is to
 * "tap into" a method chain sequence in order to modify intermediate results.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Seq
 * @param {*} value The value to provide to `interceptor`.
 * @param {Function} interceptor The function to invoke.
 * @returns {*} Returns `value`.
 * @example
 *
 * _([1, 2, 3])
 *  .tap(function(array) {
 *    // Mutate input array.
 *    array.pop();
 *  })
 *  .reverse()
 *  .value();
 * // => [2, 1]
 */
function tap(value, interceptor) {
  interceptor(value);
  return value;
}

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;

/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB). Change the following template settings to use
 * alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */
var templateSettings = {

  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {

    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': { 'escape': escape }
  }
};

/** Used to match empty string literals in compiled template source. */
var reEmptyStringLeading = /\b__p \+= '';/g;
var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components).
 */
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

/** Used to ensure capturing order of template delimiters. */
var reNoMatch = /($^)/;

/** Used to match unescaped characters in compiled string literals. */
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES delimiter as an alternative to the default "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */
function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }
  string = toString(string);
  options = assignInWith({}, options, settings, assignInDefaults);

  var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
      importsKeys = keys$1(imports),
      importsValues = baseValues(imports, importsKeys);

  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '";

  // Compile the regexp to match each delimiter.
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + '|' +
    interpolate.source + '|' +
    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
    (options.evaluate || reNoMatch).source + '|$'
  , 'g');

  // Use a sourceURL for easier debugging.
  var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\n' : '';

  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);

    // Escape characters that can't be included in string literals.
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

    // Replace delimiters with snippets.
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match.length;

    // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.
    return match;
  });

  source += "';\n";

  // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  var variable = options.variable;
  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  }
  // Cleanup code by stripping empty strings.
  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
    .replace(reEmptyStringMiddle, '$1')
    .replace(reEmptyStringTrailing, '$1;');

  // Frame code as the function body.
  source = 'function(' + (variable || 'obj') + ') {\n' +
    (variable
      ? ''
      : 'obj || (obj = {});\n'
    ) +
    "var __t, __p = ''" +
    (isEscaping
       ? ', __e = _.escape'
       : ''
    ) +
    (isEvaluating
      ? ', __j = Array.prototype.join;\n' +
        "function print() { __p += __j.call(arguments, '') }\n"
      : ';\n'
    ) +
    source +
    'return __p\n}';

  var result = attempt(function() {
    return Function(importsKeys, sourceURL + 'return ' + source)
      .apply(undefined, importsValues);
  });

  // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source = source;
  if (isError(result)) {
    throw result;
  }
  return result;
}

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$11 = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide an options object to indicate whether
 * `func` should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$11);
  }
  if (isObject$1(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/**
 * This method is like `_.tap` except that it returns the result of `interceptor`.
 * The purpose of this method is to "pass thru" values replacing intermediate
 * results in a method chain sequence.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Seq
 * @param {*} value The value to provide to `interceptor`.
 * @param {Function} interceptor The function to invoke.
 * @returns {*} Returns the result of `interceptor`.
 * @example
 *
 * _('  abc  ')
 *  .chain()
 *  .trim()
 *  .thru(function(value) {
 *    return [value];
 *  })
 *  .value();
 * // => ['abc']
 */
function thru(value, interceptor) {
  return interceptor(value);
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$4 = 9007199254740991;

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$6 = 4294967295;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$11 = Math.min;

/**
 * Invokes the iteratee `n` times, returning an array of the results of
 * each invocation. The iteratee is invoked with one argument; (index).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 * @example
 *
 * _.times(3, String);
 * // => ['0', '1', '2']
 *
 *  _.times(4, _.constant(0));
 * // => [0, 0, 0, 0]
 */
function times$1$1(n, iteratee) {
  n = toInteger(n);
  if (n < 1 || n > MAX_SAFE_INTEGER$4) {
    return [];
  }
  var index = MAX_ARRAY_LENGTH$6,
      length = nativeMin$11(n, MAX_ARRAY_LENGTH$6);

  iteratee = baseIteratee(iteratee);
  n -= MAX_ARRAY_LENGTH$6;

  var result = baseTimes(length, iteratee);
  while (++index < n) {
    iteratee(index);
  }
  return result;
}

/**
 * Enables the wrapper to be iterable.
 *
 * @name Symbol.iterator
 * @memberOf _
 * @since 4.0.0
 * @category Seq
 * @returns {Object} Returns the wrapper object.
 * @example
 *
 * var wrapped = _([1, 2]);
 *
 * wrapped[Symbol.iterator]() === wrapped;
 * // => true
 *
 * Array.from(wrapped);
 * // => [1, 2]
 */
function wrapperToIterator() {
  return this;
}

/**
 * The base implementation of `wrapperValue` which returns the result of
 * performing a sequence of actions on the unwrapped `value`, where each
 * successive action is supplied the return value of the previous.
 *
 * @private
 * @param {*} value The unwrapped value.
 * @param {Array} actions Actions to perform to resolve the unwrapped value.
 * @returns {*} Returns the resolved value.
 */
function baseWrapperValue(value, actions) {
  var result = value;
  if (result instanceof LazyWrapper) {
    result = result.value();
  }
  return arrayReduce(actions, function(result, action) {
    return action.func.apply(action.thisArg, arrayPush([result], action.args));
  }, result);
}

/**
 * Executes the chain sequence to resolve the unwrapped value.
 *
 * @name value
 * @memberOf _
 * @since 0.1.0
 * @alias toJSON, valueOf
 * @category Seq
 * @returns {*} Returns the resolved unwrapped value.
 * @example
 *
 * _([1, 2, 3]).value();
 * // => [1, 2, 3]
 */
function wrapperValue() {
  return baseWrapperValue(this.__wrapped__, this.__actions__);
}

/**
 * Converts `string`, as a whole, to lower case just like
 * [String#toLowerCase](https://mdn.io/toLowerCase).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the lower cased string.
 * @example
 *
 * _.toLower('--Foo-Bar--');
 * // => '--foo-bar--'
 *
 * _.toLower('fooBar');
 * // => 'foobar'
 *
 * _.toLower('__FOO_BAR__');
 * // => '__foo_bar__'
 */
function toLower(value) {
  return toString(value).toLowerCase();
}

/**
 * Converts `value` to a property path array.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {*} value The value to convert.
 * @returns {Array} Returns the new property path array.
 * @example
 *
 * _.toPath('a.b.c');
 * // => ['a', 'b', 'c']
 *
 * _.toPath('a[0].b.c');
 * // => ['a', '0', 'b', 'c']
 */
function toPath(value) {
  if (isArray$1(value)) {
    return arrayMap(value, toKey);
  }
  return isSymbol(value) ? [value] : copyArray(stringToPath(value));
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$5 = 9007199254740991;

/**
 * Converts `value` to a safe integer. A safe integer can be compared and
 * represented correctly.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toSafeInteger(3.2);
 * // => 3
 *
 * _.toSafeInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toSafeInteger(Infinity);
 * // => 9007199254740991
 *
 * _.toSafeInteger('3.2');
 * // => 3
 */
function toSafeInteger(value) {
  return baseClamp(toInteger(value), -MAX_SAFE_INTEGER$5, MAX_SAFE_INTEGER$5);
}

/**
 * Converts `string`, as a whole, to upper case just like
 * [String#toUpperCase](https://mdn.io/toUpperCase).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the upper cased string.
 * @example
 *
 * _.toUpper('--foo-bar--');
 * // => '--FOO-BAR--'
 *
 * _.toUpper('fooBar');
 * // => 'FOOBAR'
 *
 * _.toUpper('__foo_bar__');
 * // => '__FOO_BAR__'
 */
function toUpper(value) {
  return toString(value).toUpperCase();
}

/**
 * An alternative to `_.reduce`; this method transforms `object` to a new
 * `accumulator` object which is the result of running each of its own
 * enumerable string keyed properties thru `iteratee`, with each invocation
 * potentially mutating the `accumulator` object. If `accumulator` is not
 * provided, a new object with the same `[[Prototype]]` will be used. The
 * iteratee is invoked with four arguments: (accumulator, value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.transform([2, 3, 4], function(result, n) {
 *   result.push(n *= n);
 *   return n % 2 == 0;
 * }, []);
 * // => [4, 9]
 *
 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] }
 */
function transform$4(object, iteratee, accumulator) {
  var isArr = isArray$1(object) || isTypedArray(object);
  iteratee = baseIteratee(iteratee, 4);

  if (accumulator == null) {
    if (isArr || isObject$1(object)) {
      var Ctor = object.constructor;
      if (isArr) {
        accumulator = isArray$1(object) ? new Ctor : [];
      } else {
        accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
      }
    } else {
      accumulator = {};
    }
  }
  (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
    return iteratee(accumulator, value, index, object);
  });
  return accumulator;
}

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the last unmatched string symbol.
 */
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;

  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

/**
 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the first unmatched string symbol.
 */
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1,
      length = strSymbols.length;

  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

/** Used to match leading and trailing whitespace. */
var reTrim$2 = /^\s+|\s+$/g;

/**
 * Removes leading and trailing whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trim('  abc  ');
 * // => 'abc'
 *
 * _.trim('-_-abc-_-', '_-');
 * // => 'abc'
 *
 * _.map(['  foo  ', '  bar  '], _.trim);
 * // => ['foo', 'bar']
 */
function trim(string, chars, guard) {
  string = toString(string);
  if (string && (guard || chars === undefined)) {
    return string.replace(reTrim$2, '');
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string),
      chrSymbols = stringToArray(chars),
      start = charsStartIndex(strSymbols, chrSymbols),
      end = charsEndIndex(strSymbols, chrSymbols) + 1;

  return castSlice(strSymbols, start, end).join('');
}

/** Used to match leading and trailing whitespace. */
var reTrimEnd = /\s+$/;

/**
 * Removes trailing whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trimEnd('  abc  ');
 * // => '  abc'
 *
 * _.trimEnd('-_-abc-_-', '_-');
 * // => '-_-abc'
 */
function trimEnd(string, chars, guard) {
  string = toString(string);
  if (string && (guard || chars === undefined)) {
    return string.replace(reTrimEnd, '');
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string),
      end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

  return castSlice(strSymbols, 0, end).join('');
}

/** Used to match leading and trailing whitespace. */
var reTrimStart = /^\s+/;

/**
 * Removes leading whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trimStart('  abc  ');
 * // => 'abc  '
 *
 * _.trimStart('-_-abc-_-', '_-');
 * // => 'abc-_-'
 */
function trimStart(string, chars, guard) {
  string = toString(string);
  if (string && (guard || chars === undefined)) {
    return string.replace(reTrimStart, '');
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string),
      start = charsStartIndex(strSymbols, stringToArray(chars));

  return castSlice(strSymbols, start).join('');
}

/** Used as default options for `_.truncate`. */
var DEFAULT_TRUNC_LENGTH = 30;
var DEFAULT_TRUNC_OMISSION = '...';

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags$1 = /\w*$/;

/**
 * Truncates `string` if it's longer than the given maximum string length.
 * The last characters of the truncated string are replaced with the omission
 * string which defaults to "...".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to truncate.
 * @param {Object} [options={}] The options object.
 * @param {number} [options.length=30] The maximum string length.
 * @param {string} [options.omission='...'] The string to indicate text is omitted.
 * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
 * @returns {string} Returns the truncated string.
 * @example
 *
 * _.truncate('hi-diddly-ho there, neighborino');
 * // => 'hi-diddly-ho there, neighbo...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'length': 24,
 *   'separator': ' '
 * });
 * // => 'hi-diddly-ho there,...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'length': 24,
 *   'separator': /,? +/
 * });
 * // => 'hi-diddly-ho there...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'omission': ' [...]'
 * });
 * // => 'hi-diddly-ho there, neig [...]'
 */
function truncate(string, options) {
  var length = DEFAULT_TRUNC_LENGTH,
      omission = DEFAULT_TRUNC_OMISSION;

  if (isObject$1(options)) {
    var separator = 'separator' in options ? options.separator : separator;
    length = 'length' in options ? toInteger(options.length) : length;
    omission = 'omission' in options ? baseToString(options.omission) : omission;
  }
  string = toString(string);

  var strLength = string.length;
  if (reHasComplexSymbol.test(string)) {
    var strSymbols = stringToArray(string);
    strLength = strSymbols.length;
  }
  if (length >= strLength) {
    return string;
  }
  var end = length - stringSize(omission);
  if (end < 1) {
    return omission;
  }
  var result = strSymbols
    ? castSlice(strSymbols, 0, end).join('')
    : string.slice(0, end);

  if (separator === undefined) {
    return result + omission;
  }
  if (strSymbols) {
    end += (result.length - end);
  }
  if (isRegExp(separator)) {
    if (string.slice(end).search(separator)) {
      var match,
          substring = result;

      if (!separator.global) {
        separator = RegExp(separator.source, toString(reFlags$1.exec(separator)) + 'g');
      }
      separator.lastIndex = 0;
      while ((match = separator.exec(substring))) {
        var newEnd = match.index;
      }
      result = result.slice(0, newEnd === undefined ? end : newEnd);
    }
  } else if (string.indexOf(baseToString(separator), end) != end) {
    var index = result.lastIndexOf(separator);
    if (index > -1) {
      result = result.slice(0, index);
    }
  }
  return result + omission;
}

/**
 * Creates a function that accepts up to one argument, ignoring any
 * additional arguments.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 * @example
 *
 * _.map(['6', '8', '10'], _.unary(parseInt));
 * // => [6, 8, 10]
 */
function unary(func) {
  return ary(func, 1);
}

/** Used to map HTML entities to characters. */
var htmlUnescapes = {
  '&amp;': '&',
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&#39;': "'",
  '&#96;': '`'
};

/**
 * Used by `_.unescape` to convert HTML entities to characters.
 *
 * @private
 * @param {string} chr The matched character to unescape.
 * @returns {string} Returns the unescaped character.
 */
function unescapeHtmlChar(chr) {
  return htmlUnescapes[chr];
}

/** Used to match HTML entities and HTML characters. */
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g;
var reHasEscapedHtml = RegExp(reEscapedHtml.source);

/**
 * The inverse of `_.escape`; this method converts the HTML entities
 * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to
 * their corresponding characters.
 *
 * **Note:** No other HTML entities are unescaped. To unescape additional
 * HTML entities use a third-party library like [_he_](https://mths.be/he).
 *
 * @static
 * @memberOf _
 * @since 0.6.0
 * @category String
 * @param {string} [string=''] The string to unescape.
 * @returns {string} Returns the unescaped string.
 * @example
 *
 * _.unescape('fred, barney, &amp; pebbles');
 * // => 'fred, barney, & pebbles'
 */
function unescape(string) {
  string = toString(string);
  return (string && reHasEscapedHtml.test(string))
    ? string.replace(reEscapedHtml, unescapeHtmlChar)
    : string;
}

/** Used as references for various `Number` constants. */
var INFINITY$5 = 1 / 0;

/**
 * Creates a set of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set$1 && (1 / setToArray(new Set$1([,-0]))[1]) == INFINITY$5) ? noop : function(values) {
  return new Set$1(values);
};

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$3 = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE$3) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = rest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

/**
 * This method is like `_.union` except that it accepts `iteratee` which is
 * invoked for each element of each `arrays` to generate the criterion by
 * which uniqueness is computed. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.unionBy([2.1], [1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
var unionBy = rest(function(arrays) {
  var iteratee = last(arrays);
  if (isArrayLikeObject(iteratee)) {
    iteratee = undefined;
  }
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee));
});

/**
 * This method is like `_.union` except that it accepts `comparator` which
 * is invoked to compare elements of `arrays`. The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.unionWith(objects, others, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
 */
var unionWith = rest(function(arrays) {
  var comparator = last(arrays);
  if (isArrayLikeObject(comparator)) {
    comparator = undefined;
  }
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
});

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length)
    ? baseUniq(array)
    : [];
}

/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
function uniqBy(array, iteratee) {
  return (array && array.length)
    ? baseUniq(array, baseIteratee(iteratee))
    : [];
}

/**
 * This method is like `_.uniq` except that it accepts `comparator` which
 * is invoked to compare elements of `array`. The comparator is invoked with
 * two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.uniqWith(objects, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 */
function uniqWith(array, comparator) {
  return (array && array.length)
    ? baseUniq(array, undefined, comparator)
    : [];
}

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$14 = Math.max;

/**
 * This method is like `_.zip` except that it accepts an array of grouped
 * elements and creates an array regrouping the elements to their pre-zip
 * configuration.
 *
 * @static
 * @memberOf _
 * @since 1.2.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
 * // => [['fred', 30, true], ['barney', 40, false]]
 *
 * _.unzip(zipped);
 * // => [['fred', 'barney'], [30, 40], [true, false]]
 */
function unzip(array) {
  if (!(array && array.length)) {
    return [];
  }
  var length = 0;
  array = arrayFilter(array, function(group) {
    if (isArrayLikeObject(group)) {
      length = nativeMax$14(group.length, length);
      return true;
    }
  });
  return baseTimes(length, function(index) {
    return arrayMap(array, baseProperty(index));
  });
}

/**
 * This method is like `_.unzip` except that it accepts `iteratee` to specify
 * how regrouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @param {Function} [iteratee=_.identity] The function to combine
 *  regrouped values.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
 * // => [[1, 10, 100], [2, 20, 200]]
 *
 * _.unzipWith(zipped, _.add);
 * // => [3, 30, 300]
 */
function unzipWith(array, iteratee) {
  if (!(array && array.length)) {
    return [];
  }
  var result = unzip(array);
  if (iteratee == null) {
    return result;
  }
  return arrayMap(result, function(group) {
    return apply(iteratee, undefined, group);
  });
}

/**
 * The base implementation of `_.update`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to update.
 * @param {Function} updater The function to produce the updated value.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseUpdate(object, path, updater, customizer) {
  return baseSet(object, path, updater(baseGet(object, path)), customizer);
}

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

/**
 * This method is like `_.set` except that accepts `updater` to produce the
 * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
 * is invoked with one argument: (value).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.6.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {Function} updater The function to produce the updated value.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.update(object, 'a[0].b.c', function(n) { return n * n; });
 * console.log(object.a[0].b.c);
 * // => 9
 *
 * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
 * console.log(object.x[0].y.z);
 * // => 0
 */
function update(object, path, updater) {
  return object == null ? object : baseUpdate(object, path, castFunction(updater));
}

/**
 * This method is like `_.update` except that it accepts `customizer` which is
 * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
 * path creation is handled by the method instead. The `customizer` is invoked
 * with three arguments: (nsValue, key, nsObject).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.6.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {Function} updater The function to produce the updated value.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {};
 *
 * _.updateWith(object, '[0][1]', _.constant('a'), Object);
 * // => { '0': { '1': 'a' } }
 */
function updateWith(object, path, updater, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
}

/**
 * Converts `string`, as space separated words, to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the upper cased string.
 * @example
 *
 * _.upperCase('--foo-bar');
 * // => 'FOO BAR'
 *
 * _.upperCase('fooBar');
 * // => 'FOO BAR'
 *
 * _.upperCase('__foo_bar__');
 * // => 'FOO BAR'
 */
var upperCase = createCompounder(function(result, word, index) {
  return result + (index ? ' ' : '') + word.toUpperCase();
});

/**
 * Creates an array of the own and inherited enumerable string keyed property
 * values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.valuesIn(new Foo);
 * // => [1, 2, 3] (iteration order is not guaranteed)
 */
function valuesIn(object) {
  return object == null ? [] : baseValues(object, keysIn(object));
}

/**
 * Creates a function that provides `value` to the wrapper function as its
 * first argument. Any additional arguments provided to the function are
 * appended to those provided to the wrapper function. The wrapper is invoked
 * with the `this` binding of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {*} value The value to wrap.
 * @param {Function} [wrapper=identity] The wrapper function.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var p = _.wrap(_.escape, function(func, text) {
 *   return '<p>' + func(text) + '</p>';
 * });
 *
 * p('fred, barney, & pebbles');
 * // => '<p>fred, barney, &amp; pebbles</p>'
 */
function wrap$1(value, wrapper) {
  wrapper = wrapper == null ? identity : wrapper;
  return partial(wrapper, value);
}

/**
 * This method is the wrapper version of `_.at`.
 *
 * @name at
 * @memberOf _
 * @since 1.0.0
 * @category Seq
 * @param {...(string|string[])} [paths] The property paths of elements to pick.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
 *
 * _(object).at(['a[0].b.c', 'a[1]']).value();
 * // => [3, 4]
 */
var wrapperAt = rest(function(paths) {
  paths = baseFlatten(paths, 1);
  var length = paths.length,
      start = length ? paths[0] : 0,
      value = this.__wrapped__,
      interceptor = function(object) { return baseAt(object, paths); };

  if (length > 1 || this.__actions__.length ||
      !(value instanceof LazyWrapper) || !isIndex(start)) {
    return this.thru(interceptor);
  }
  value = value.slice(start, +start + (length ? 1 : 0));
  value.__actions__.push({
    'func': thru,
    'args': [interceptor],
    'thisArg': undefined
  });
  return new LodashWrapper(value, this.__chain__).thru(function(array) {
    if (length && !array.length) {
      array.push(undefined);
    }
    return array;
  });
});

/**
 * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
 *
 * @name chain
 * @memberOf _
 * @since 0.1.0
 * @category Seq
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 }
 * ];
 *
 * // A sequence without explicit chaining.
 * _(users).head();
 * // => { 'user': 'barney', 'age': 36 }
 *
 * // A sequence with explicit chaining.
 * _(users)
 *   .chain()
 *   .head()
 *   .pick('user')
 *   .value();
 * // => { 'user': 'barney' }
 */
function wrapperChain() {
  return chain(this);
}

/**
 * This method is the wrapper version of `_.reverse`.
 *
 * **Note:** This method mutates the wrapped array.
 *
 * @name reverse
 * @memberOf _
 * @since 0.1.0
 * @category Seq
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * var array = [1, 2, 3];
 *
 * _(array).reverse().value()
 * // => [3, 2, 1]
 *
 * console.log(array);
 * // => [3, 2, 1]
 */
function wrapperReverse() {
  var value = this.__wrapped__;
  if (value instanceof LazyWrapper) {
    var wrapped = value;
    if (this.__actions__.length) {
      wrapped = new LazyWrapper(this);
    }
    wrapped = wrapped.reverse();
    wrapped.__actions__.push({
      'func': thru,
      'args': [reverse],
      'thisArg': undefined
    });
    return new LodashWrapper(wrapped, this.__chain__);
  }
  return this.thru(reverse);
}

/**
 * The base implementation of methods like `_.xor`, without support for
 * iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of values.
 */
function baseXor(arrays, iteratee, comparator) {
  var index = -1,
      length = arrays.length;

  while (++index < length) {
    var result = result
      ? arrayPush(
          baseDifference(result, arrays[index], iteratee, comparator),
          baseDifference(arrays[index], result, iteratee, comparator)
        )
      : arrays[index];
  }
  return (result && result.length) ? baseUniq(result, iteratee, comparator) : [];
}

/**
 * Creates an array of unique values that is the
 * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
 * of the given arrays. The order of result values is determined by the order
 * they occur in the arrays.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.without
 * @example
 *
 * _.xor([2, 1], [2, 3]);
 * // => [1, 3]
 */
var xor = rest(function(arrays) {
  return baseXor(arrayFilter(arrays, isArrayLikeObject));
});

/**
 * This method is like `_.xor` except that it accepts `iteratee` which is
 * invoked for each element of each `arrays` to generate the criterion by
 * which by which they're compared. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
 * // => [1.2, 3.4]
 *
 * // The `_.property` iteratee shorthand.
 * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 2 }]
 */
var xorBy = rest(function(arrays) {
  var iteratee = last(arrays);
  if (isArrayLikeObject(iteratee)) {
    iteratee = undefined;
  }
  return baseXor(arrayFilter(arrays, isArrayLikeObject), baseIteratee(iteratee));
});

/**
 * This method is like `_.xor` except that it accepts `comparator` which is
 * invoked to compare elements of `arrays`. The comparator is invoked with
 * two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.xorWith(objects, others, _.isEqual);
 * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
 */
var xorWith = rest(function(arrays) {
  var comparator = last(arrays);
  if (isArrayLikeObject(comparator)) {
    comparator = undefined;
  }
  return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
});

/**
 * Creates an array of grouped elements, the first of which contains the
 * first elements of the given arrays, the second of which contains the
 * second elements of the given arrays, and so on.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @returns {Array} Returns the new array of grouped elements.
 * @example
 *
 * _.zip(['fred', 'barney'], [30, 40], [true, false]);
 * // => [['fred', 30, true], ['barney', 40, false]]
 */
var zip = rest(unzip);

/**
 * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
 *
 * @private
 * @param {Array} props The property identifiers.
 * @param {Array} values The property values.
 * @param {Function} assignFunc The function to assign values.
 * @returns {Object} Returns the new object.
 */
function baseZipObject(props, values, assignFunc) {
  var index = -1,
      length = props.length,
      valsLength = values.length,
      result = {};

  while (++index < length) {
    var value = index < valsLength ? values[index] : undefined;
    assignFunc(result, props[index], value);
  }
  return result;
}

/**
 * This method is like `_.fromPairs` except that it accepts two arrays,
 * one of property identifiers and one of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 0.4.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.zipObject(['a', 'b'], [1, 2]);
 * // => { 'a': 1, 'b': 2 }
 */
function zipObject(props, values) {
  return baseZipObject(props || [], values || [], assignValue);
}

/**
 * This method is like `_.zipObject` except that it supports property paths.
 *
 * @static
 * @memberOf _
 * @since 4.1.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
 * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
 */
function zipObjectDeep(props, values) {
  return baseZipObject(props || [], values || [], baseSet);
}

/**
 * This method is like `_.zip` except that it accepts `iteratee` to specify
 * how grouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @param {Function} [iteratee=_.identity] The function to combine grouped values.
 * @returns {Array} Returns the new array of grouped elements.
 * @example
 *
 * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
 *   return a + b + c;
 * });
 * // => [111, 222]
 */
var zipWith = rest(function(arrays) {
  var length = arrays.length,
      iteratee = length > 1 ? arrays[length - 1] : undefined;

  iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
  return unzipWith(arrays, iteratee);
});

var array = {
  chunk: chunk, compact: compact, concat: concat, difference: difference, differenceBy: differenceBy,
  differenceWith: differenceWith, drop: drop, dropRight: dropRight, dropRightWhile: dropRightWhile, dropWhile: dropWhile,
  fill: fill, findIndex: findIndex$1, findLastIndex: findLastIndex, first: head, flatten: flatten$1,
  flattenDeep: flattenDeep, flattenDepth: flattenDepth, fromPairs: fromPairs, head: head, indexOf: indexOf,
  initial: initial, intersection: intersection, intersectionBy: intersectionBy, intersectionWith: intersectionWith, join: join,
  last: last, lastIndexOf: lastIndexOf, nth: nth, pull: pull, pullAll: pullAll,
  pullAllBy: pullAllBy, pullAllWith: pullAllWith, pullAt: pullAt, remove: remove, reverse: reverse,
  slice: slice, sortedIndex: sortedIndex, sortedIndexBy: sortedIndexBy, sortedIndexOf: sortedIndexOf, sortedLastIndex: sortedLastIndex,
  sortedLastIndexBy: sortedLastIndexBy, sortedLastIndexOf: sortedLastIndexOf, sortedUniq: sortedUniq, sortedUniqBy: sortedUniqBy, tail: tail,
  take: take, takeRight: takeRight, takeRightWhile: takeRightWhile, takeWhile: takeWhile, union: union,
  unionBy: unionBy, unionWith: unionWith, uniq: uniq, uniqBy: uniqBy, uniqWith: uniqWith,
  unzip: unzip, unzipWith: unzipWith, without: without, xor: xor, xorBy: xorBy,
  xorWith: xorWith, zip: zip, zipObject: zipObject, zipObjectDeep: zipObjectDeep, zipWith: zipWith
};

var collection = {
  at: at, countBy: countBy, each: forEach$1, eachRight: forEachRight, every: every,
  filter: filter$2, find: find$1, findLast: findLast, flatMap: flatMap, flatMapDeep: flatMapDeep,
  flatMapDepth: flatMapDepth, forEach: forEach$1, forEachRight: forEachRight, groupBy: groupBy, includes: includes,
  invokeMap: invokeMap, keyBy: keyBy, map: map$2, orderBy: orderBy, partition: partition,
  reduce: reduce, reduceRight: reduceRight, reject: reject, sample: sample, sampleSize: sampleSize,
  shuffle: shuffle, size: size, some: some, sortBy: sortBy
};

var date = {
  now: now
};

var func = {
  after: after, ary: ary, before: before, bind: bind, bindKey: bindKey,
  curry: curry, curryRight: curryRight, debounce: debounce, defer: defer, delay: delay,
  flip: flip, memoize: memoize, negate: negate, once: once, overArgs: overArgs,
  partial: partial, partialRight: partialRight, rearg: rearg, rest: rest, spread: spread,
  throttle: throttle, unary: unary, wrap: wrap$1
};

var lang$1 = {
  castArray: castArray, clone: clone$2, cloneDeep: cloneDeep$2, cloneDeepWith: cloneDeepWith, cloneWith: cloneWith,
  eq: eq, gt: gt$1$1, gte: gte, isArguments: isArguments, isArray: isArray$1,
  isArrayBuffer: isArrayBuffer, isArrayLike: isArrayLike, isArrayLikeObject: isArrayLikeObject, isBoolean: isBoolean, isBuffer: isBuffer,
  isDate: isDate, isElement: isElement, isEmpty: isEmpty, isEqual: isEqual$1, isEqualWith: isEqualWith,
  isError: isError, isFinite: isFinite$1, isFunction: isFunction, isInteger: isInteger, isLength: isLength,
  isMap: isMap, isMatch: isMatch, isMatchWith: isMatchWith, isNaN: isNaN$1, isNative: isNative,
  isNil: isNil$1, isNull: isNull, isNumber: isNumber$1, isObject: isObject$1, isObjectLike: isObjectLike,
  isPlainObject: isPlainObject$1, isRegExp: isRegExp, isSafeInteger: isSafeInteger, isSet: isSet, isString: isString$1,
  isSymbol: isSymbol, isTypedArray: isTypedArray, isUndefined: isUndefined, isWeakMap: isWeakMap, isWeakSet: isWeakSet,
  lt: lt$1$1, lte: lte, toArray: toArray, toFinite: toFinite, toInteger: toInteger,
  toLength: toLength, toNumber: toNumber, toPlainObject: toPlainObject, toSafeInteger: toSafeInteger, toString: toString
};

var math = {
  add: add, ceil: ceil, divide: divide$1$1, floor: floor, max: max,
  maxBy: maxBy, mean: mean, meanBy: meanBy, min: min, minBy: minBy,
  multiply: multiply, round: round, subtract: subtract, sum: sum$1, sumBy: sumBy
};

var number = {
  clamp: clamp, inRange: inRange, random: random
};

var object = {
  assign: assign, assignIn: assignIn, assignInWith: assignInWith, assignWith: assignWith, create: create,
  defaults: defaults, defaultsDeep: defaultsDeep, entries: toPairs, entriesIn: toPairsIn, extend: assignIn,
  extendWith: assignInWith, findKey: findKey, findLastKey: findLastKey, forIn: forIn, forInRight: forInRight,
  forOwn: forOwn, forOwnRight: forOwnRight, functions: functions, functionsIn: functionsIn, get: get,
  has: has, hasIn: hasIn, invert: invert, invertBy: invertBy, invoke: invoke,
  keys: keys$1, keysIn: keysIn, mapKeys: mapKeys, mapValues: mapValues, merge: merge,
  mergeWith: mergeWith, omit: omit, omitBy: omitBy, pick: pick, pickBy: pickBy,
  result: result, set: set, setWith: setWith, toPairs: toPairs, toPairsIn: toPairsIn,
  transform: transform$4, unset: unset, update: update, updateWith: updateWith, values: values,
  valuesIn: valuesIn
};

var seq = {
  at: wrapperAt, chain: chain, commit: wrapperCommit, lodash: lodash, next: wrapperNext,
  plant: wrapperPlant, reverse: wrapperReverse, tap: tap, thru: thru, toIterator: wrapperToIterator,
  toJSON: wrapperValue, value: wrapperValue, valueOf: wrapperValue, wrapperChain: wrapperChain
};

var string = {
  camelCase: camelCase, capitalize: capitalize, deburr: deburr, endsWith: endsWith, escape: escape,
  escapeRegExp: escapeRegExp, kebabCase: kebabCase, lowerCase: lowerCase, lowerFirst: lowerFirst, pad: pad,
  padEnd: padEnd, padStart: padStart, parseInt: parseInt$1, repeat: repeat, replace: replace,
  snakeCase: snakeCase, split: split, startCase: startCase, startsWith: startsWith, template: template,
  templateSettings: templateSettings, toLower: toLower, toUpper: toUpper, trim: trim, trimEnd: trimEnd,
  trimStart: trimStart, truncate: truncate, unescape: unescape, upperCase: upperCase, upperFirst: upperFirst,
  words: words
};

var util = {
  attempt: attempt, bindAll: bindAll, cond: cond, conforms: conforms, constant: constant,
  flow: flow, flowRight: flowRight, identity: identity, iteratee: iteratee, matches: matches$1,
  matchesProperty: matchesProperty, method: method, methodOf: methodOf, mixin: mixin, noop: noop,
  nthArg: nthArg, over: over, overEvery: overEvery, overSome: overSome, property: property,
  propertyOf: propertyOf, range: range$1, rangeRight: rangeRight, stubArray: stubArray, stubFalse: stubFalse,
  stubObject: stubObject, stubString: stubString, stubTrue: stubTrue, times: times$1$1, toPath: toPath,
  uniqueId: uniqueId
};

/**
 * Creates a clone of the lazy wrapper object.
 *
 * @private
 * @name clone
 * @memberOf LazyWrapper
 * @returns {Object} Returns the cloned `LazyWrapper` object.
 */
function lazyClone() {
  var result = new LazyWrapper(this.__wrapped__);
  result.__actions__ = copyArray(this.__actions__);
  result.__dir__ = this.__dir__;
  result.__filtered__ = this.__filtered__;
  result.__iteratees__ = copyArray(this.__iteratees__);
  result.__takeCount__ = this.__takeCount__;
  result.__views__ = copyArray(this.__views__);
  return result;
}

/**
 * Reverses the direction of lazy iteration.
 *
 * @private
 * @name reverse
 * @memberOf LazyWrapper
 * @returns {Object} Returns the new reversed `LazyWrapper` object.
 */
function lazyReverse() {
  if (this.__filtered__) {
    var result = new LazyWrapper(this);
    result.__dir__ = -1;
    result.__filtered__ = true;
  } else {
    result = this.clone();
    result.__dir__ *= -1;
  }
  return result;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$16 = Math.max;
var nativeMin$14 = Math.min;

/**
 * Gets the view, applying any `transforms` to the `start` and `end` positions.
 *
 * @private
 * @param {number} start The start of the view.
 * @param {number} end The end of the view.
 * @param {Array} transforms The transformations to apply to the view.
 * @returns {Object} Returns an object containing the `start` and `end`
 *  positions of the view.
 */
function getView(start, end, transforms) {
  var index = -1,
      length = transforms.length;

  while (++index < length) {
    var data = transforms[index],
        size = data.size;

    switch (data.type) {
      case 'drop':      start += size; break;
      case 'dropRight': end -= size; break;
      case 'take':      end = nativeMin$14(end, start + size); break;
      case 'takeRight': start = nativeMax$16(start, end - size); break;
    }
  }
  return { 'start': start, 'end': end };
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$4 = 200;

/** Used to indicate the type of lazy iteratees. */
var LAZY_FILTER_FLAG$1 = 1;
var LAZY_MAP_FLAG = 2;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin$13 = Math.min;

/**
 * Extracts the unwrapped value from its lazy wrapper.
 *
 * @private
 * @name value
 * @memberOf LazyWrapper
 * @returns {*} Returns the unwrapped value.
 */
function lazyValue() {
  var array = this.__wrapped__.value(),
      dir = this.__dir__,
      isArr = isArray$1(array),
      isRight = dir < 0,
      arrLength = isArr ? array.length : 0,
      view = getView(0, arrLength, this.__views__),
      start = view.start,
      end = view.end,
      length = end - start,
      index = isRight ? end : (start - 1),
      iteratees = this.__iteratees__,
      iterLength = iteratees.length,
      resIndex = 0,
      takeCount = nativeMin$13(length, this.__takeCount__);

  if (!isArr || arrLength < LARGE_ARRAY_SIZE$4 ||
      (arrLength == length && takeCount == length)) {
    return baseWrapperValue(array, this.__actions__);
  }
  var result = [];

  outer:
  while (length-- && resIndex < takeCount) {
    index += dir;

    var iterIndex = -1,
        value = array[index];

    while (++iterIndex < iterLength) {
      var data = iteratees[iterIndex],
          iteratee = data.iteratee,
          type = data.type,
          computed = iteratee(value);

      if (type == LAZY_MAP_FLAG) {
        value = computed;
      } else if (!computed) {
        if (type == LAZY_FILTER_FLAG$1) {
          continue outer;
        } else {
          break outer;
        }
      }
    }
    result[resIndex++] = value;
  }
  return result;
}

/**
 * @license
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="es" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/** Used as the semantic version number. */
var VERSION = '4.13.1';

/** Used to compose bitmasks for wrapper metadata. */
var BIND_KEY_FLAG$5 = 2;

/** Used to indicate the type of lazy iteratees. */
var LAZY_FILTER_FLAG = 1;
var LAZY_WHILE_FLAG = 3;

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH$7 = 4294967295;

/** Used for built-in method references. */
var arrayProto$5 = Array.prototype;
var objectProto$33 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$18 = objectProto$33.hasOwnProperty;

/** Built-in value references. */
var iteratorSymbol$1 = typeof (iteratorSymbol$1 = Symbol && Symbol.iterator) == 'symbol' ? iteratorSymbol$1 : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$15 = Math.max;
var nativeMin$12 = Math.min;

// wrap `_.mixin` so it works when provided only one argument
var mixin$2 = (function(func$$1) {
  return function(object$$1, source, options) {
    if (options == null) {
      var isObj = isObject$1(source),
          props = isObj && keys$1(source),
          methodNames = props && props.length && baseFunctions(source, props);

      if (!(methodNames ? methodNames.length : isObj)) {
        options = source;
        source = object$$1;
        object$$1 = this;
      }
    }
    return func$$1(object$$1, source, options);
  };
}(mixin));

// Add methods that return wrapped values in chain sequences.
lodash.after = func.after;
lodash.ary = func.ary;
lodash.assign = object.assign;
lodash.assignIn = object.assignIn;
lodash.assignInWith = object.assignInWith;
lodash.assignWith = object.assignWith;
lodash.at = collection.at;
lodash.before = func.before;
lodash.bind = func.bind;
lodash.bindAll = util.bindAll;
lodash.bindKey = func.bindKey;
lodash.castArray = lang$1.castArray;
lodash.chain = seq.chain;
lodash.chunk = array.chunk;
lodash.compact = array.compact;
lodash.concat = array.concat;
lodash.cond = util.cond;
lodash.conforms = util.conforms;
lodash.constant = util.constant;
lodash.countBy = collection.countBy;
lodash.create = object.create;
lodash.curry = func.curry;
lodash.curryRight = func.curryRight;
lodash.debounce = func.debounce;
lodash.defaults = object.defaults;
lodash.defaultsDeep = object.defaultsDeep;
lodash.defer = func.defer;
lodash.delay = func.delay;
lodash.difference = array.difference;
lodash.differenceBy = array.differenceBy;
lodash.differenceWith = array.differenceWith;
lodash.drop = array.drop;
lodash.dropRight = array.dropRight;
lodash.dropRightWhile = array.dropRightWhile;
lodash.dropWhile = array.dropWhile;
lodash.fill = array.fill;
lodash.filter = collection.filter;
lodash.flatMap = collection.flatMap;
lodash.flatMapDeep = collection.flatMapDeep;
lodash.flatMapDepth = collection.flatMapDepth;
lodash.flatten = array.flatten;
lodash.flattenDeep = array.flattenDeep;
lodash.flattenDepth = array.flattenDepth;
lodash.flip = func.flip;
lodash.flow = util.flow;
lodash.flowRight = util.flowRight;
lodash.fromPairs = array.fromPairs;
lodash.functions = object.functions;
lodash.functionsIn = object.functionsIn;
lodash.groupBy = collection.groupBy;
lodash.initial = array.initial;
lodash.intersection = array.intersection;
lodash.intersectionBy = array.intersectionBy;
lodash.intersectionWith = array.intersectionWith;
lodash.invert = object.invert;
lodash.invertBy = object.invertBy;
lodash.invokeMap = collection.invokeMap;
lodash.iteratee = util.iteratee;
lodash.keyBy = collection.keyBy;
lodash.keys = keys$1;
lodash.keysIn = object.keysIn;
lodash.map = collection.map;
lodash.mapKeys = object.mapKeys;
lodash.mapValues = object.mapValues;
lodash.matches = util.matches;
lodash.matchesProperty = util.matchesProperty;
lodash.memoize = func.memoize;
lodash.merge = object.merge;
lodash.mergeWith = object.mergeWith;
lodash.method = util.method;
lodash.methodOf = util.methodOf;
lodash.mixin = mixin$2;
lodash.negate = func.negate;
lodash.nthArg = util.nthArg;
lodash.omit = object.omit;
lodash.omitBy = object.omitBy;
lodash.once = func.once;
lodash.orderBy = collection.orderBy;
lodash.over = util.over;
lodash.overArgs = func.overArgs;
lodash.overEvery = util.overEvery;
lodash.overSome = util.overSome;
lodash.partial = func.partial;
lodash.partialRight = func.partialRight;
lodash.partition = collection.partition;
lodash.pick = object.pick;
lodash.pickBy = object.pickBy;
lodash.property = util.property;
lodash.propertyOf = util.propertyOf;
lodash.pull = array.pull;
lodash.pullAll = array.pullAll;
lodash.pullAllBy = array.pullAllBy;
lodash.pullAllWith = array.pullAllWith;
lodash.pullAt = array.pullAt;
lodash.range = util.range;
lodash.rangeRight = util.rangeRight;
lodash.rearg = func.rearg;
lodash.reject = collection.reject;
lodash.remove = array.remove;
lodash.rest = rest;
lodash.reverse = array.reverse;
lodash.sampleSize = collection.sampleSize;
lodash.set = object.set;
lodash.setWith = object.setWith;
lodash.shuffle = collection.shuffle;
lodash.slice = array.slice;
lodash.sortBy = collection.sortBy;
lodash.sortedUniq = array.sortedUniq;
lodash.sortedUniqBy = array.sortedUniqBy;
lodash.split = string.split;
lodash.spread = func.spread;
lodash.tail = array.tail;
lodash.take = array.take;
lodash.takeRight = array.takeRight;
lodash.takeRightWhile = array.takeRightWhile;
lodash.takeWhile = array.takeWhile;
lodash.tap = seq.tap;
lodash.throttle = func.throttle;
lodash.thru = thru;
lodash.toArray = lang$1.toArray;
lodash.toPairs = object.toPairs;
lodash.toPairsIn = object.toPairsIn;
lodash.toPath = util.toPath;
lodash.toPlainObject = lang$1.toPlainObject;
lodash.transform = object.transform;
lodash.unary = func.unary;
lodash.union = array.union;
lodash.unionBy = array.unionBy;
lodash.unionWith = array.unionWith;
lodash.uniq = array.uniq;
lodash.uniqBy = array.uniqBy;
lodash.uniqWith = array.uniqWith;
lodash.unset = object.unset;
lodash.unzip = array.unzip;
lodash.unzipWith = array.unzipWith;
lodash.update = object.update;
lodash.updateWith = object.updateWith;
lodash.values = object.values;
lodash.valuesIn = object.valuesIn;
lodash.without = array.without;
lodash.words = string.words;
lodash.wrap = func.wrap;
lodash.xor = array.xor;
lodash.xorBy = array.xorBy;
lodash.xorWith = array.xorWith;
lodash.zip = array.zip;
lodash.zipObject = array.zipObject;
lodash.zipObjectDeep = array.zipObjectDeep;
lodash.zipWith = array.zipWith;

// Add aliases.
lodash.entries = object.toPairs;
lodash.entriesIn = object.toPairsIn;
lodash.extend = object.assignIn;
lodash.extendWith = object.assignInWith;

// Add methods to `lodash.prototype`.
mixin$2(lodash, lodash);

// Add methods that return unwrapped values in chain sequences.
lodash.add = math.add;
lodash.attempt = util.attempt;
lodash.camelCase = string.camelCase;
lodash.capitalize = string.capitalize;
lodash.ceil = math.ceil;
lodash.clamp = number.clamp;
lodash.clone = lang$1.clone;
lodash.cloneDeep = lang$1.cloneDeep;
lodash.cloneDeepWith = lang$1.cloneDeepWith;
lodash.cloneWith = lang$1.cloneWith;
lodash.deburr = string.deburr;
lodash.divide = math.divide;
lodash.endsWith = string.endsWith;
lodash.eq = lang$1.eq;
lodash.escape = string.escape;
lodash.escapeRegExp = string.escapeRegExp;
lodash.every = collection.every;
lodash.find = collection.find;
lodash.findIndex = array.findIndex;
lodash.findKey = object.findKey;
lodash.findLast = collection.findLast;
lodash.findLastIndex = array.findLastIndex;
lodash.findLastKey = object.findLastKey;
lodash.floor = math.floor;
lodash.forEach = collection.forEach;
lodash.forEachRight = collection.forEachRight;
lodash.forIn = object.forIn;
lodash.forInRight = object.forInRight;
lodash.forOwn = object.forOwn;
lodash.forOwnRight = object.forOwnRight;
lodash.get = object.get;
lodash.gt = lang$1.gt;
lodash.gte = lang$1.gte;
lodash.has = object.has;
lodash.hasIn = object.hasIn;
lodash.head = array.head;
lodash.identity = identity;
lodash.includes = collection.includes;
lodash.indexOf = array.indexOf;
lodash.inRange = number.inRange;
lodash.invoke = object.invoke;
lodash.isArguments = lang$1.isArguments;
lodash.isArray = isArray$1;
lodash.isArrayBuffer = lang$1.isArrayBuffer;
lodash.isArrayLike = lang$1.isArrayLike;
lodash.isArrayLikeObject = lang$1.isArrayLikeObject;
lodash.isBoolean = lang$1.isBoolean;
lodash.isBuffer = lang$1.isBuffer;
lodash.isDate = lang$1.isDate;
lodash.isElement = lang$1.isElement;
lodash.isEmpty = lang$1.isEmpty;
lodash.isEqual = lang$1.isEqual;
lodash.isEqualWith = lang$1.isEqualWith;
lodash.isError = lang$1.isError;
lodash.isFinite = lang$1.isFinite;
lodash.isFunction = lang$1.isFunction;
lodash.isInteger = lang$1.isInteger;
lodash.isLength = lang$1.isLength;
lodash.isMap = lang$1.isMap;
lodash.isMatch = lang$1.isMatch;
lodash.isMatchWith = lang$1.isMatchWith;
lodash.isNaN = lang$1.isNaN;
lodash.isNative = lang$1.isNative;
lodash.isNil = lang$1.isNil;
lodash.isNull = lang$1.isNull;
lodash.isNumber = lang$1.isNumber;
lodash.isObject = isObject$1;
lodash.isObjectLike = lang$1.isObjectLike;
lodash.isPlainObject = lang$1.isPlainObject;
lodash.isRegExp = lang$1.isRegExp;
lodash.isSafeInteger = lang$1.isSafeInteger;
lodash.isSet = lang$1.isSet;
lodash.isString = lang$1.isString;
lodash.isSymbol = lang$1.isSymbol;
lodash.isTypedArray = lang$1.isTypedArray;
lodash.isUndefined = lang$1.isUndefined;
lodash.isWeakMap = lang$1.isWeakMap;
lodash.isWeakSet = lang$1.isWeakSet;
lodash.join = array.join;
lodash.kebabCase = string.kebabCase;
lodash.last = last;
lodash.lastIndexOf = array.lastIndexOf;
lodash.lowerCase = string.lowerCase;
lodash.lowerFirst = string.lowerFirst;
lodash.lt = lang$1.lt;
lodash.lte = lang$1.lte;
lodash.max = math.max;
lodash.maxBy = math.maxBy;
lodash.mean = math.mean;
lodash.meanBy = math.meanBy;
lodash.min = math.min;
lodash.minBy = math.minBy;
lodash.stubArray = util.stubArray;
lodash.stubFalse = util.stubFalse;
lodash.stubObject = util.stubObject;
lodash.stubString = util.stubString;
lodash.stubTrue = util.stubTrue;
lodash.multiply = math.multiply;
lodash.nth = array.nth;
lodash.noop = util.noop;
lodash.now = date.now;
lodash.pad = string.pad;
lodash.padEnd = string.padEnd;
lodash.padStart = string.padStart;
lodash.parseInt = string.parseInt;
lodash.random = number.random;
lodash.reduce = collection.reduce;
lodash.reduceRight = collection.reduceRight;
lodash.repeat = string.repeat;
lodash.replace = string.replace;
lodash.result = object.result;
lodash.round = math.round;
lodash.sample = collection.sample;
lodash.size = collection.size;
lodash.snakeCase = string.snakeCase;
lodash.some = collection.some;
lodash.sortedIndex = array.sortedIndex;
lodash.sortedIndexBy = array.sortedIndexBy;
lodash.sortedIndexOf = array.sortedIndexOf;
lodash.sortedLastIndex = array.sortedLastIndex;
lodash.sortedLastIndexBy = array.sortedLastIndexBy;
lodash.sortedLastIndexOf = array.sortedLastIndexOf;
lodash.startCase = string.startCase;
lodash.startsWith = string.startsWith;
lodash.subtract = math.subtract;
lodash.sum = math.sum;
lodash.sumBy = math.sumBy;
lodash.template = string.template;
lodash.times = util.times;
lodash.toFinite = lang$1.toFinite;
lodash.toInteger = toInteger;
lodash.toLength = lang$1.toLength;
lodash.toLower = string.toLower;
lodash.toNumber = lang$1.toNumber;
lodash.toSafeInteger = lang$1.toSafeInteger;
lodash.toString = lang$1.toString;
lodash.toUpper = string.toUpper;
lodash.trim = string.trim;
lodash.trimEnd = string.trimEnd;
lodash.trimStart = string.trimStart;
lodash.truncate = string.truncate;
lodash.unescape = string.unescape;
lodash.uniqueId = util.uniqueId;
lodash.upperCase = string.upperCase;
lodash.upperFirst = string.upperFirst;

// Add aliases.
lodash.each = collection.forEach;
lodash.eachRight = collection.forEachRight;
lodash.first = array.head;

mixin$2(lodash, (function() {
  var source = {};
  baseForOwn(lodash, function(func$$1, methodName) {
    if (!hasOwnProperty$18.call(lodash.prototype, methodName)) {
      source[methodName] = func$$1;
    }
  });
  return source;
}()), { 'chain': false });

/**
 * The semantic version number.
 *
 * @static
 * @memberOf _
 * @type {string}
 */
lodash.VERSION = VERSION;
(lodash.templateSettings = string.templateSettings).imports._ = lodash;

// Assign default placeholders.
arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
  lodash[methodName].placeholder = lodash;
});

// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop', 'take'], function(methodName, index) {
  LazyWrapper.prototype[methodName] = function(n) {
    var filtered = this.__filtered__;
    if (filtered && !index) {
      return new LazyWrapper(this);
    }
    n = n === undefined ? 1 : nativeMax$15(toInteger(n), 0);

    var result$$1 = this.clone();
    if (filtered) {
      result$$1.__takeCount__ = nativeMin$12(n, result$$1.__takeCount__);
    } else {
      result$$1.__views__.push({
        'size': nativeMin$12(n, MAX_ARRAY_LENGTH$7),
        'type': methodName + (result$$1.__dir__ < 0 ? 'Right' : '')
      });
    }
    return result$$1;
  };

  LazyWrapper.prototype[methodName + 'Right'] = function(n) {
    return this.reverse()[methodName](n).reverse();
  };
});

// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
  var type = index + 1,
      isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

  LazyWrapper.prototype[methodName] = function(iteratee$$1) {
    var result$$1 = this.clone();
    result$$1.__iteratees__.push({
      'iteratee': baseIteratee(iteratee$$1, 3),
      'type': type
    });
    result$$1.__filtered__ = result$$1.__filtered__ || isFilter;
    return result$$1;
  };
});

// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head', 'last'], function(methodName, index) {
  var takeName = 'take' + (index ? 'Right' : '');

  LazyWrapper.prototype[methodName] = function() {
    return this[takeName](1).value()[0];
  };
});

// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial', 'tail'], function(methodName, index) {
  var dropName = 'drop' + (index ? '' : 'Right');

  LazyWrapper.prototype[methodName] = function() {
    return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
  };
});

LazyWrapper.prototype.compact = function() {
  return this.filter(identity);
};

LazyWrapper.prototype.find = function(predicate) {
  return this.filter(predicate).head();
};

LazyWrapper.prototype.findLast = function(predicate) {
  return this.reverse().find(predicate);
};

LazyWrapper.prototype.invokeMap = rest(function(path, args) {
  if (typeof path == 'function') {
    return new LazyWrapper(this);
  }
  return this.map(function(value$$1) {
    return baseInvoke(value$$1, path, args);
  });
});

LazyWrapper.prototype.reject = function(predicate) {
  predicate = baseIteratee(predicate, 3);
  return this.filter(function(value$$1) {
    return !predicate(value$$1);
  });
};

LazyWrapper.prototype.slice = function(start, end) {
  start = toInteger(start);

  var result$$1 = this;
  if (result$$1.__filtered__ && (start > 0 || end < 0)) {
    return new LazyWrapper(result$$1);
  }
  if (start < 0) {
    result$$1 = result$$1.takeRight(-start);
  } else if (start) {
    result$$1 = result$$1.drop(start);
  }
  if (end !== undefined) {
    end = toInteger(end);
    result$$1 = end < 0 ? result$$1.dropRight(-end) : result$$1.take(end - start);
  }
  return result$$1;
};

LazyWrapper.prototype.takeRightWhile = function(predicate) {
  return this.reverse().takeWhile(predicate).reverse();
};

LazyWrapper.prototype.toArray = function() {
  return this.take(MAX_ARRAY_LENGTH$7);
};

// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype, function(func$$1, methodName) {
  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
      isTaker = /^(?:head|last)$/.test(methodName),
      lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
      retUnwrapped = isTaker || /^find/.test(methodName);

  if (!lodashFunc) {
    return;
  }
  lodash.prototype[methodName] = function() {
    var value$$1 = this.__wrapped__,
        args = isTaker ? [1] : arguments,
        isLazy = value$$1 instanceof LazyWrapper,
        iteratee$$1 = args[0],
        useLazy = isLazy || isArray$1(value$$1);

    var interceptor = function(value$$1) {
      var result$$1 = lodashFunc.apply(lodash, arrayPush([value$$1], args));
      return (isTaker && chainAll) ? result$$1[0] : result$$1;
    };

    if (useLazy && checkIteratee && typeof iteratee$$1 == 'function' && iteratee$$1.length != 1) {
      // Avoid lazy use if the iteratee has a "length" value other than `1`.
      isLazy = useLazy = false;
    }
    var chainAll = this.__chain__,
        isHybrid = !!this.__actions__.length,
        isUnwrapped = retUnwrapped && !chainAll,
        onlyLazy = isLazy && !isHybrid;

    if (!retUnwrapped && useLazy) {
      value$$1 = onlyLazy ? value$$1 : new LazyWrapper(this);
      var result$$1 = func$$1.apply(value$$1, args);
      result$$1.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
      return new LodashWrapper(result$$1, chainAll);
    }
    if (isUnwrapped && onlyLazy) {
      return func$$1.apply(this, args);
    }
    result$$1 = this.thru(interceptor);
    return isUnwrapped ? (isTaker ? result$$1.value()[0] : result$$1.value()) : result$$1;
  };
});

// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
  var func$$1 = arrayProto$5[methodName],
      chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
      retUnwrapped = /^(?:pop|shift)$/.test(methodName);

  lodash.prototype[methodName] = function() {
    var args = arguments;
    if (retUnwrapped && !this.__chain__) {
      var value$$1 = this.value();
      return func$$1.apply(isArray$1(value$$1) ? value$$1 : [], args);
    }
    return this[chainName](function(value$$1) {
      return func$$1.apply(isArray$1(value$$1) ? value$$1 : [], args);
    });
  };
});

// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype, function(func$$1, methodName) {
  var lodashFunc = lodash[methodName];
  if (lodashFunc) {
    var key = (lodashFunc.name + ''),
        names = realNames[key] || (realNames[key] = []);

    names.push({ 'name': methodName, 'func': lodashFunc });
  }
});

realNames[createHybridWrapper(undefined, BIND_KEY_FLAG$5).name] = [{
  'name': 'wrapper',
  'func': undefined
}];

// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone = lazyClone;
LazyWrapper.prototype.reverse = lazyReverse;
LazyWrapper.prototype.value = lazyValue;

// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at = seq.at;
lodash.prototype.chain = seq.wrapperChain;
lodash.prototype.commit = seq.commit;
lodash.prototype.next = seq.next;
lodash.prototype.plant = seq.plant;
lodash.prototype.reverse = seq.reverse;
lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = seq.value;

if (iteratorSymbol$1) {
  lodash.prototype[iteratorSymbol$1] = seq.toIterator;
}

/**
 * @license
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="es" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/*
  Compute snapshot based on a given doc (JSON) and a set of changes
*/
function computeSnapshot(jsonDoc, changeset) {
  // Clone the doc to make sure we don't manipulate in-place
  jsonDoc = cloneDeep$2(jsonDoc);
  var nodes = jsonDoc.nodes;
  changeset.forEach(function (change) {
    change.ops.forEach(function (opData) {
      try {
        var op = ObjectOperation.fromJSON(opData);
        op.apply(nodes);
      } catch (err) {
        console.error(err, opData);
      }
    });
  });
  return jsonDoc
}

var EMPTY_DOC = { nodes: {} };

/*
  API for creating and retrieving document snapshots
*/
var SnapshotEngine = function SnapshotEngine(config) {
  this.changeStore = config.changeStore;
  this.snapshotStore = config.snapshotStore;
};

/*
  Compute snapshot for given documentId and version

  Example: Let's assume we want to request a snapshot for a new version 20.
  Now getClosestSnapshot will give us version 15. This requires us to fetch
  the changes since version 16 and apply those, plus the very new change.
*/
SnapshotEngine.prototype.getSnapshot = function getSnapshot (documentId, version, cb) {
    var this$1 = this;

  var jsonDoc = EMPTY_DOC;
  this._getClosestSnapshot(documentId, version, function (err, snapshot, closestVersion) {
    if (err) {
      return cb(err)
    }
    if (snapshot && version === closestVersion) {
      // we alread have a snapshot for this version
      return cb(null, snapshot, version)
    }
    var knownVersion;
    if (snapshot) {
      knownVersion = closestVersion;
    } else {
      knownVersion = 0; // we need to fetch all changes
    }
    if (snapshot) {
      jsonDoc = snapshot;
    }
    // Now we get the remaining changes after the known version
    this$1.changeStore.getChanges(documentId, knownVersion, version, function (err, changes) {
      if (err) { return cb(err) }
      if (changes.length < (version - knownVersion)) {
        return cb('Changes missing for reconstructing version '+ version)
      }
      jsonDoc = computeSnapshot(jsonDoc, changes);
      cb(null, jsonDoc, version);
    });
  });
};

/*
  Creates a snapshot
*/
SnapshotEngine.prototype.createSnapshot = function createSnapshot (documentId, version, cb) {
    var this$1 = this;

  this.getSnapshot(documentId, version, function (err, snapshot) {
    if (err) { return cb(err) }
    this$1.snapshotStore.saveSnapshot(documentId, version, snapshot, cb);
  });
};

SnapshotEngine.prototype._getClosestSnapshot = function _getClosestSnapshot (documentId, version, cb) {
    var this$1 = this;

  var closestVersion;

  this.snapshotStore.getVersions(documentId, function (err, versions) {
    if (versions.indexOf(version) >= 0) {
      closestVersion = version;
    } else {
      // We don't have a snaphot for that requested version
      var smallerVersions = versions.filter(function(v) {
        return parseInt(v, 10) < version
      });
      // Take the closest version if there is any
      closestVersion = Math.max.apply(null, smallerVersions);
    }
    if (!closestVersion) {
      return cb(null, undefined)
    }
    this$1.snapshotStore.getSnapshot(documentId, version, cb);
  });
};

/*
  DocumentEngine
*/
var DocumentEngine = (function (EventEmitter$$1) {
  function DocumentEngine(config) {
    EventEmitter$$1.call(this);
    this.changeStore = config.changeStore;
    this.snapshotStore = config.snapshotStore;
    // Snapshot creation frequency (e.g. if it equals 15 then every
    // 15th version will be saved as snapshot)
    this.snapshotFrequency = config.snapshotFrequency || 1;
    this.snapshotEngine = new SnapshotEngine({
      changeStore: this.changeStore,
      snapshotStore: this.snapshotStore
    });
  }

  if ( EventEmitter$$1 ) DocumentEngine.__proto__ = EventEmitter$$1;
  DocumentEngine.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  DocumentEngine.prototype.constructor = DocumentEngine;

  /*
    Creates a new document

    A valid document must have at least one valid change
  */
  DocumentEngine.prototype.createDocument = function createDocument (documentId, initialChange, cb) {
    this.addChange(documentId, initialChange, cb);
  };

  /*
    Get a document snapshot for a given version. If no version
    is provivded, the latest version is returned
  */
  DocumentEngine.prototype.getDocument = function getDocument (documentId, version, cb) {
    var this$1 = this;

    if (typeof version === 'function') {
      cb = version;
      version = undefined;
    }
    if (!documentId) {
      throw new Error('Invalid Arguments')
    }
    if (version === undefined) {
      this.getVersion(documentId, function (err, version) {
        if (err) { return cb(err) }
        this$1.snapshotEngine.getSnapshot(documentId, version, cb);
      });
    } else {
      this.snapshotEngine.getSnapshot(documentId, version, cb);
    }
  };

  /*
    Delete document by documentId
  */
  DocumentEngine.prototype.deleteDocument = function deleteDocument (documentId, cb) {
    this.changeStore.deleteChanges(documentId, function (err) {
      if (err) {
        return cb(new Error('Deleting changes failed'))
      }
    });
  };

  /*
    Check if a given document exists
  */
  DocumentEngine.prototype.documentExists = function documentExists (documentId, cb) {
    this.getVersion(documentId, function (err, version) {
      if (version >= 0) {
        cb(null, true);
      } else {
        cb(null, false);
      }
    });
  };

  /*
    Get changes based on documentId, sinceVersion
  */
  DocumentEngine.prototype.getChanges = function getChanges (documentId, sinceVersion, toVersion, cb) {
    this.changeStore.getChanges(documentId, sinceVersion, toVersion, cb);
  };

  /*
    Get version for given documentId
  */
  DocumentEngine.prototype.getVersion = function getVersion (documentId, cb) {
    this.changeStore.getVersion(documentId, cb);
  };

  /*
    Here the implementer decides whether a snapshot should be created or not.
    It may be a good strategy to only create a snaphot for every 10th version.
    However for now we will just snapshot each change to keep things simple.
  */
  DocumentEngine.prototype.requestSnapshot = function requestSnapshot (documentId, version, cb) {
    if (version % this.snapshotFrequency === 0) {
      this.snapshotEngine.createSnapshot(documentId, version, cb);
    } else {
      cb(null); // do nothing
    }
  };

  /*
    Add change to a given documentId.

    Snapshot creation is requested on each change to be stored.
  */
  DocumentEngine.prototype.addChange = function addChange (documentId, change, cb) {
    var this$1 = this;

    this.changeStore.addChange(documentId, change, function (err, newVersion) {
      if (err) { return cb(err) }

      this$1.requestSnapshot(documentId, newVersion, function () {
        // no matter if snaphot creation errored or not we will confirm change
        cb(null, newVersion);
      });
    });
  };

  return DocumentEngine;
}(EventEmitter));

/*
  DocumentServer module. Can be bound to an express instance
*/
var DocumentServer = function DocumentServer(params) {
  this.configurator = params.configurator;
  this.engine = this.configurator.getDocumentEngine();
  // TODO: make path configurable through configurator
  this.path = '/api/documents';
};

/*
  Attach this server to an express instance
*/
DocumentServer.prototype.bind = function bind (app) {
  app.post(this.path, this._createDocument.bind(this));
  app.get(this.path + '/:id', this._getDocument.bind(this));
  app.delete(this.path + '/:id', this._deleteDocument.bind(this));
};

/*
  Create a new document, given a documentId and initial change
*/
DocumentServer.prototype._createDocument = function _createDocument (req, res, next) {
  var ref = req.body;
    var documentId = ref.documentId;
    var change = ref.change;
  this.engine.createDocument(documentId, change, function(err, version) {
    if (err) { return next(err) }
    res.json(version);
  });
};

/*
  Get a document with given document id
*/
DocumentServer.prototype._getDocument = function _getDocument (req, res, next) {
  var documentId = req.params.id;
  this.engine.getDocument(documentId, function(err, jsonDoc, version) {
    if (err) { return next(err) }
    res.json({
      data: jsonDoc,
      version: version
    });
  });
};

/*
  Remove a document with given document id
*/
DocumentServer.prototype._deleteDocument = function _deleteDocument (req, res, next) {
  var documentId = req.params.id;
  this.engine.deleteDocument(documentId, function(err, result) {
    if (err) { return next(err) }
    res.json(result);
  });
};

/*
  Implements Substance SnapshotStore API. This is just a dumb store.
  No integrity checks are made, as this is the task of SnapshotEngine
*/
var SnapshotStore = function SnapshotStore(seed) {
  this._snapshots = seed || {};
};

/*
  Get all available versions for a document
*/
SnapshotStore.prototype.getVersions = function getVersions (documentId, cb) {
  var versions = this._getVersions(documentId);
  cb(null, versions);
};

/*
  Get Snapshot by documentId and version.

  Returns snapshot data and snaphot version
*/
SnapshotStore.prototype.getSnapshot = function getSnapshot (documentId, version, cb) {
  if (!arguments.length === 3) {
    throw new Error('Invalid Arguments')
  }
  var docEntry = this._snapshots[documentId];
  if (!docEntry) { return cb(null, undefined) }
  var snapshot = docEntry[version];
  if (snapshot) {
    cb(null, snapshot, version);
  } else {
    cb(null, undefined);
  }
};

/*
  Saves a snapshot for a given documentId and version.

  Please note that an existing snapshot will be overwritten.
*/
SnapshotStore.prototype.saveSnapshot = function saveSnapshot (documentId, version, data, cb) {
  if (!documentId || !version || !data) {
    throw new Error('Invalid arguments')
  }
  var docEntry = this._snapshots[documentId];
  if (!docEntry) {
    docEntry = this._snapshots[documentId] = {};
  }
  docEntry[version] = data;
  cb(null, docEntry[version]);
};

/*
  Removes a snapshot for a given documentId + version
*/
SnapshotStore.prototype.deleteSnapshot = function deleteSnapshot (documentId, version, cb) {
  var docEntry = this._snapshots[documentId];
  if (!docEntry || !docEntry[version]) {
    return cb(new Error('Snapshot does not exist and can not be deleted'))
  }
  var snapshot = this._snapshots[documentId][version];
  delete this._snapshots[documentId][version];
  cb(null, snapshot);
};

/*
  Get versions for a given document
*/
SnapshotStore.prototype._getVersions = function _getVersions (documentId) {
  var docEntry = this._snapshots[documentId];
  if (!docEntry) { return [] } // no versions available
  return Object.keys(docEntry)
};

var CollabServerConfigurator = function CollabServerConfigurator() {
  this.config = {
    heartbeat: 30*1000,
    documentStore: undefined,
    changeStore: undefined,
    snapshotStore: undefined
  };
};

CollabServerConfigurator.prototype.setHost = function setHost (host) {
  this.config.host = host;
};

CollabServerConfigurator.prototype.setPort = function setPort (port) {
  this.config.port = port;
};

// Record phase API
// ------------------------

CollabServerConfigurator.prototype.setDocumentStore = function setDocumentStore (documentStore) {
  this.config.documentStore = documentStore;
};

CollabServerConfigurator.prototype.setChangeStore = function setChangeStore (changeStore) {
  this.config.changeStore = changeStore;
};

CollabServerConfigurator.prototype.setSnapshotStore = function setSnapshotStore (snapshotStore) {
  this.config.snapshotStore = snapshotStore;
};

// Config Interpreter API
// ------------------------

CollabServerConfigurator.prototype.getHost = function getHost () {
  return this.config.host
};

CollabServerConfigurator.prototype.getPort = function getPort () {
  return this.config.port
};

CollabServerConfigurator.prototype.getDocumentStore = function getDocumentStore () {
  return this.config.documentStore
};

CollabServerConfigurator.prototype.getChangeStore = function getChangeStore () {
  return this.config.changeStore
};

CollabServerConfigurator.prototype.getSnapshotStore = function getSnapshotStore () {
  return this.config.snapshotStore
};

/*
  TODO: We should discuss if it is a good idea that the configurator 'owns'
  instances. Don't see a better solution for now though.
*/
CollabServerConfigurator.prototype.getDocumentEngine = function getDocumentEngine () {
  if (!this.documentEngine) {
    this.documentEngine = new DocumentEngine({
      documentStore: this.config.documentStore,
      changeStore: this.config.changeStore,
      snapshotStore: this.config.snapshotStore
    });
  }
  return this.documentEngine
};

/**
  Configure this instance of configuration for provided package.
  @param{Object} pkg   Object should contain a `configure` method that
                           takes a Configurator instance as the first method.
  @param{Object} options Additional options to pass to the
                           package.`configure` method

  @return {configurator} returns the configurator instance to make it easy
                           to chain calls to import.
 */
CollabServerConfigurator.prototype.import = function import$1 (pkg, options) {
  pkg.configure(this, options || {});
  return this
};

/**
  Standard configuration for Substance CollabServer
*/

function isBoolean$2(val) {
  return (val === true || val === false || (val && val.constructor === Boolean) )
}

/*
  Internal helper class used by model/data/Node.
*/
var Property = function Property(definition) {
  this.definition = definition;
};

var prototypeAccessors$7 = { type: {},name: {} };

Property.prototype.isArray = function isArray$1 () {
  return isArray(this.definition.type)
};

Property.prototype.isReference = function isReference () {
  if (this.isArray()) {
    return last$2(this.definition.type) === 'id'
  } else {
    return this.definition.type === 'id'
  }
};

Property.prototype.isText = function isText () {
  return Boolean(this.definition._isText)
};

Property.prototype.isOwned = function isOwned () {
  return Boolean(this.definition.owned)
};

Property.prototype.isOptional = function isOptional () {
  return Boolean(this.definition.optional)
};

Property.prototype.isNotNull = function isNotNull () {
  return Boolean(this.definition.notNull)
};

Property.prototype.hasDefault = function hasDefault () {
  return this.definition.hasOwnProperty('default')
};

Property.prototype.getDefault = function getDefault () {
  return this.definition.default
};

Property.prototype.createDefaultValue = function createDefaultValue () {
  if (isArray(this.definition.type)) {
    return []
  }
  switch(this.definition.type) {
    case 'object':
      return {}
    case 'number':
      return -1
    case 'coordinate':
      return new Coordinate([], 0)
    case 'boolean':
      return false
    case 'id':
      return null
    case 'string':
      return ''
    default:
      return null
  }
};

prototypeAccessors$7.type.get = function () {
  return this.definition.type
};

prototypeAccessors$7.name.get = function () {
  return this.definition.name
};

Object.defineProperties( Property.prototype, prototypeAccessors$7 );

/*
  Base node implementation.

  @prop {String} id an id that is unique within this data
 */
var Node = (function (EventEmitter$$1) {
  function Node(data) {
    var this$1 = this;

    EventEmitter$$1.call(this);

    var NodeClass = this.constructor;

    var schema = NodeClass.schema;
    for (var name in schema) {
      if (!schema.hasOwnProperty(name)) { continue }
      var prop = schema[name];
      // check integrity of provided data, such as type correctness,
      // and mandatory properties
      var propIsGiven = (data[name] !== undefined);
      var hasDefault = prop.hasDefault();
      var isOptional = prop.isOptional();
      if ( (!isOptional && !hasDefault) && !propIsGiven) {
        throw new Error('Property ' + name + ' is mandatory for node type ' + this$1.type)
      }
      if (propIsGiven) {
        this$1[name] = _checked(prop, data[name]);
      } else if (hasDefault) {
        this$1[name] = cloneDeep(_checked(prop, prop.getDefault()));
      } else {
        // property is optional
      }
    }
  }

  if ( EventEmitter$$1 ) Node.__proto__ = EventEmitter$$1;
  Node.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Node.prototype.constructor = Node;

  var prototypeAccessors = { type: {} };

  Node.prototype.dispose = function dispose () {};

  /**
    Check if the node is of a given type.

    @param {String} typeName
    @returns {Boolean} true if the node has a parent with given type, false otherwise.
  */
  Node.prototype.isInstanceOf = function isInstanceOf (typeName) {
    return Node.isInstanceOf(this.constructor, typeName)
  };

  Node.prototype.getSchema = function getSchema () {
    return this.constructor.schema
  };

  /**
    Get a the list of all polymorphic types.

    @returns {String[]} An array of type names.
   */
  Node.prototype.getTypeNames = function getTypeNames () {
    var typeNames = [];
    var NodeClass = this.constructor;
    while (NodeClass.type !== "node") {
      typeNames.push(NodeClass.type);
      NodeClass = Object.getPrototypeOf(NodeClass);
    }
    return typeNames
  };

  /**
   * Get the type of a property.
   *
   * @param {String} propertyName
   * @returns The property's type.
   */
  Node.prototype.getPropertyType = function getPropertyType (propertyName) {
    var schema = this.constructor.schema;
    return schema[propertyName].type
  };

  /**
    Convert node to JSON.

    @returns {Object} JSON representation of node.
   */
  Node.prototype.toJSON = function toJSON () {
    var this$1 = this;

    var data = {
      type: this.type
    };
    var schema = this.getSchema();
    forEach(schema, function (prop, name) {
      var val = this$1[name];
      if (prop.isOptional() && val === undefined) { return }
      if (isArray(val) || isObject(val)) {
        val = cloneDeep(val);
      }
      data[prop.name] = val;
    });
    return data
  };

  prototypeAccessors.type.get = function () {
    return this.constructor.type
  };

  Object.defineProperties( Node.prototype, prototypeAccessors );

  return Node;
}(EventEmitter));

Node.prototype._isNode = true;

// NOTE: this code and its deps will always be included in the bundle as rollup considers this as global side-effect
Object.defineProperty(Node, 'schema', {
  get: function get() { return this._schema },
  set: function set(schema) {
    var NodeClass = this;
    // TODO: discuss if we want this. Is a bit more convenient
    // ATM we transfer 'type' to the static property
    if (schema.type) {
      NodeClass.type = schema.type;
    }
    // collects a full schema considering the schemas of parent class
    // we will use the unfolded schema, check integrity of the given props (mandatory, readonly)
    // or fill in default values for undefined properties.
    NodeClass._schema = compileSchema(NodeClass, schema);
  }
});

Node.define = Node.defineSchema = function define(schema) {
  this.schema = schema;
};

Node.schema = {
  type: "node",
  id: 'string'
};

/**
  Internal implementation of Node.prototype.isInstanceOf.

  @static
  @private
  @returns {Boolean}
 */
Node.isInstanceOf = function(NodeClass, typeName) {
  var type = NodeClass.type;
  while (type !== "node") {
    if (type === typeName) { return true }
    var _super = Object.getPrototypeOf(NodeClass.prototype).constructor;
    if (_super && _super.type) {
      NodeClass = _super;
      type = NodeClass.type;
    } else {
      break
    }
  }
  return false
};

// ### Internal implementation

function compileSchema(NodeClass, schema) {
  var compiledSchema = _compileSchema(schema);
  var schemas = [compiledSchema];
  var clazz = NodeClass;
  while(clazz) {
    var parentProto = Object.getPrototypeOf(clazz.prototype);
    if (!parentProto) {
      break
    }
    clazz = parentProto.constructor;
    if (clazz && clazz._schema) {
      schemas.unshift(clazz._schema);
    }
  }
  schemas.unshift({});
  return Object.assign.apply(null, schemas)
}

function _compileSchema(schema) {
  var compiledSchema = {};
  forEach(schema, function(definition, name) {
    // skip 'type'
    if (name === 'type') {
      return
    }
    if (isString(definition) || isArray(definition)) {
      definition = { type: definition };
    }
    definition = _compileDefintion(definition);
    definition.name = name;
    compiledSchema[name] = new Property(definition);
  });
  return compiledSchema
}

function _compileDefintion(definition) {
  var result = definition;
  if (isArray(definition.type) && definition.type[0] !== "array") {
    definition.type = [ "array", definition.type[0] ];
  } else if (definition.type === 'text') {
    result = {
      type: "string",
      default: '',
      _isText: true
    };
  }
  return result
}

function _checked(prop, value) {
  var type;
  var name = prop.name;
  if (prop.isArray()) {
    type = "array";
  } else {
    type = prop.type;
  }
  if (value === null) {
    if (prop.isNotNull()) {
      throw new Error('Value for property ' + name + ' is null.')
    } else {
      return value
    }
  }
  if (value === undefined) {
    throw new Error('Value for property ' + name + ' is undefined.')
  }
  if (type === "string" && !isString(value) ||
      type === "boolean" && !isBoolean$2(value) ||
      type === "number" && !isNumber(value) ||
      type === "array" && !isArray(value) ||
      type === "id" && !isString(value) ||
      type === "object" && !isObject(value)) {
    throw new Error('Illegal value type for property ' + name + ': expected ' + type + ', was ' + (typeof value))
  }
  return value
}

/**
  Base node type for document nodes.

  @example

  The following example shows how a new node type is defined.

  ```js
  class Todo extends TextBlock {}
  Todo.schema = {
    type: 'todo',
    content: 'text',
    done: { type: 'bool', default: false }
  }
  ```

  The following data types are supported:

  - `string` bare metal string data type
  - `text` a string that carries annotations
  - `number` numeric values
  - `bool` boolean values
  - `id` a node id referencing another node in the document
*/
var DocumentNode = (function (DataNode) {
  function DocumentNode(doc, props) {
    DataNode.call(this, props);
    // being less strict here allows us to create a detached node
    // which can be useful for testing
    // if (!doc) throw new Error('Document instance is mandatory.')
    this.document = doc;
  }

  if ( DataNode ) DocumentNode.__proto__ = DataNode;
  DocumentNode.prototype = Object.create( DataNode && DataNode.prototype );
  DocumentNode.prototype.constructor = DocumentNode;

  /**
    Get the Document instance.

    @returns {Document}
  */
  DocumentNode.prototype.getDocument = function getDocument () {
    return this.document
  };

  /**
    Whether this node has a parent.

    `parent` is a built-in property for implementing nested nodes.

    @returns {Boolean}
  */
  DocumentNode.prototype.hasParent = function hasParent () {
    return Boolean(this.parent)
  };

  /**
    @returns {DocumentNode} the parent node
  */
  DocumentNode.prototype.getParent = function getParent () {
    return this.document.get(this.parent)
  };

  /**
    Get the root node.

    The root node is the last ancestor returned
    by a sequence of `getParent()` calls.

    @returns {DocumentNode}
  */
  DocumentNode.prototype.getRoot = function getRoot () {
    var node = this;
    while(node.parent) {
      node = node.parent;
    }
    return node
  };

  /**
    Checks whether this node has children.

    @returns {Boolean} default: false
  */
  DocumentNode.prototype.hasChildren = function hasChildren () {
    return false
  };

  /**
    Get the index of a given child.

    @returns {Number} default: -1
  */
  DocumentNode.prototype.getChildIndex = function getChildIndex (child) { // eslint-disable-line
    return -1
  };

  /**
    Get a child node at a given position.

    @returns {DocumentNode} default: null
  */
  DocumentNode.prototype.getChildAt = function getChildAt (idx) { // eslint-disable-line
    return null
  };

  /**
    Get the number of children nodes.

    @returns {Number} default: 0
  */
  DocumentNode.prototype.getChildCount = function getChildCount () {
    return 0
  };

  // TODO: should this really be here?
  // volatile property necessary to render highlighted node differently
  // TODO: We should get this out here
  DocumentNode.prototype.setHighlighted = function setHighlighted (highlighted, scope) {
    if (this.highlighted !== highlighted) {
      this.highlightedScope = scope;
      this.highlighted = highlighted;
      this.emit('highlighted', highlighted);
    }
  };

  // Experimental: we are working on a simpler API replacing the
  // rather inconvenient EventProxy API.
  DocumentNode.prototype.on = function on (eventName, handler, ctx) {
    var match = _matchPropertyEvent(eventName);
    if (match) {
      var propertyName = match[1];
      if (this.constructor.schema[propertyName]) {
        var doc = this.getDocument();
        doc.getEventProxy('path')
          .on([this.id, propertyName], handler, ctx);
      }
    }
    EventEmitter.prototype.on.apply(this, arguments);
  };

  DocumentNode.prototype.off = function off (ctx, eventName, handler) {
    var doc = this.getDocument();
    var match = false;
    if (!eventName) {
      doc.getEventProxy('path').off(ctx);
    } else {
      match = _matchPropertyEvent(eventName);
    }
    if (match) {
      var propertyName = match[1];
      doc.getEventProxy('path')
        .off(ctx, [this.id, propertyName], handler);
    }
    EventEmitter.prototype.off.apply(this, arguments);
  };

  DocumentNode.prototype._onPropertyChange = function _onPropertyChange (propertyName) {
    var args = [propertyName + ':changed']
      .concat(Array.prototype.slice.call(arguments, 1));
    this.emit.apply(this, args);
  };

  // Node categories
  // --------------------

  /**
    @returns {Boolean} true if node is a block node (e.g. Paragraph, Figure, List, Table)
  */
  DocumentNode.prototype.isBlock = function isBlock () {
    return Boolean(this.constructor.isBlock)
  };

  /**
    @returns {Boolean} true if node is a text node (e.g. Paragraph, Codebock)
  */
  DocumentNode.prototype.isText = function isText () {
    return Boolean(this.constructor.isText)
  };

  /**
    @returns {Boolean} true if node is an inline node (e.g. Citation)
  */
  DocumentNode.prototype.isInline = function isInline () {
    return Boolean(this.constructor.isInline)
  };

  DocumentNode.prototype.isList = function isList () {
    return Boolean(this.constructor.isList)
  };

  DocumentNode.prototype.isIsolatedNode = function isIsolatedNode () {
    return !this.isText() && !this.isList()
  };

  return DocumentNode;
}(Node));

DocumentNode.prototype._isDocumentNode = true;

/**
  Declares a node to be treated as block-type node.

  BlockNodes are considers the direct descendant of `Container` nodes.
  @type {Boolean} default: false
*/
DocumentNode.isBlock = false;

/**
  Declares a node to be treated as text-ish node.

  @type {Boolean} default: false
*/
DocumentNode.isText = false;

/**
  Declares a node to be treated as {@link model/PropertyAnnotation}.

  @type {Boolean} default: false
*/
DocumentNode.isPropertyAnnotation = false;

/**
  Declares a node to be treated as {@link model/ContainerAnnotation}.

  @type {Boolean} default: false
*/
DocumentNode.isContainerAnnotation = false;

/**
  Declares a node to be treated as {@link model/InlineNode}.

  @type {Boolean} default: false
*/
DocumentNode.isInline = false;

function _matchPropertyEvent(eventName) {
  return /([a-zA-Z_0-9]+):changed/.exec(eventName)
}

var BlockNode = (function (DocumentNode$$1) {
	function BlockNode () {
		DocumentNode$$1.apply(this, arguments);
	}if ( DocumentNode$$1 ) BlockNode.__proto__ = DocumentNode$$1;
	BlockNode.prototype = Object.create( DocumentNode$$1 && DocumentNode$$1.prototype );
	BlockNode.prototype.constructor = BlockNode;

	

	return BlockNode;
}(DocumentNode));

BlockNode.isBlock = true;

var ContainerAddress = function ContainerAddress(pos, offset) {
  this.pos = pos;
  this.offset = offset;
};

ContainerAddress.prototype.isBefore = function isBefore (other, strict) {
  strict = Boolean(strict);
  if (this.pos < other.pos) {
    return true
  } else if (this.pos > other.pos) {
    return false
  } else if (this.offset < other.offset) {
    return true
  } else if (this.offset > other.offset) {
    return false
  }
  if (strict) {
    return false
  } else {
    return true
  }
};

ContainerAddress.prototype.isAfter = function isAfter (other, strict) {
  return other.isBefore(this, strict)
};

ContainerAddress.prototype.isEqual = function isEqual (other) {
  return (this.pos === other.pos && this.offset === other.offset)
};

ContainerAddress.prototype.toString = function toString () {
  return [this.pos,'.',this.offset].join('')
};

/*
  A Container represents a list of nodes.

  While most editing occurs on a property level (such as editing text),
  other things happen on a node level, e.g., breaking or mergin nodes,
  or spanning annotations so called ContainerAnnotations.
*/
var Container = (function (DocumentNode$$1) {
  function Container() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    DocumentNode$$1.apply(this, args);

    // NOTE: we are caching positions as they are queried very often,
    // whereas the number of changes to a container are quite rare.
    // The cache gets invalidated whenever the container is changed.
    this._enableCaching();
  }

  if ( DocumentNode$$1 ) Container.__proto__ = DocumentNode$$1;
  Container.prototype = Object.create( DocumentNode$$1 && DocumentNode$$1.prototype );
  Container.prototype.constructor = Container;

  var prototypeAccessors = { length: {} };

  Container.prototype.dispose = function dispose () {
    this.document.off(this);
  };

  Container.prototype.getContentPath = function getContentPath () {
    return [this.id, 'nodes']
  };

  Container.prototype.getContent = function getContent () {
    return this.nodes
  };

  Container.prototype.getPosition = function getPosition (node, strict) {
    if (isString(node)) {
      node = this.document.get(node);
    }
    var pos = this._getPosition(node);
    if (strict && pos < 0) {
      throw new Error('Node is not within this container: ' + node.id)
    }
    return pos
  };

  Container.prototype.getNodeAt = function getNodeAt (idx) {
    var content = this.getContent();
    if (idx < 0 || idx >= content.length) {
      throw new Error('Array index out of bounds: ' + idx + ", " + content.length)
    }
    return this.getDocument().get(content[idx])
  };

  Container.prototype.getNodes = function getNodes () {
    var doc = this.getDocument();
    return this.getContent().map(function (id) { return doc.get(id); }).filter(Boolean)
  };

  Container.prototype.show = function show (nodeId, pos) {
    var doc = this.getDocument();
    var arg1 = arguments[0];
    if (!isString(arg1)) {
      if (arg1._isNode) {
        nodeId = arg1.id;
      }
    }
    if (!isNumber(pos)) {
      pos = this.getLength();
    }
    doc.update(this.getContentPath(), { type: 'insert', pos: pos, value: nodeId });
  };

  Container.prototype.hide = function hide (nodeId) {
    var doc = this.getDocument();
    var pos = this.getPosition(nodeId);
    if (pos >= 0) {
      doc.update(this.getContentPath(), { type: 'delete', pos: pos });
    }
  };

  Container.prototype.getAddress = function getAddress (coor) {
    if (!coor._isCoordinate) {
      // we have broken with an earlier version of this API
      throw new Error('Illegal argument: Container.getAddress(coor) expects a Coordinate instance.')
    }
    var nodeId = coor.path[0];
    var nodePos = this.getPosition(nodeId);
    var offset;
    if (coor.isNodeCoordinate()) {
      if (coor.offset > 0) {
        offset = Number.MAX_VALUE;
      } else {
        offset = 0;
      }
    } else {
      offset = coor.offset;
    }
    return new ContainerAddress(nodePos, offset)
  };

  Container.prototype.getLength = function getLength () {
    return this.getContent().length
  };

  prototypeAccessors.length.get = function () {
    return this.getLength()
  };

  Container.prototype._getPosition = function _getPosition (node) {
    if (this._isCaching) {
      return this._getCachedPosition(node)
    } else {
      return this._lookupPosition(node)
    }
  };

  Container.prototype._getCachedPosition = function _getCachedPosition (node) {
    var cache = this._cachedPositions || this._fillCache();
    var nodeId = node.id;
    var pos = -1;
    if (cache.hasOwnProperty(nodeId)) {
      pos = cache[nodeId];
    } else {
      pos = this._lookupPosition(node);
      cache[nodeId] = pos;
    }
    return pos
  };

  Container.prototype._fillCache = function _fillCache () {
    var positions = {};
    this.nodes.forEach(function (id, pos) {
      positions[id] = pos;
    });
    this._cachedPositions = positions;
    return positions
  };

  Container.prototype._invalidateCache = function _invalidateCache () {
    this._cachedPositions = null;
  };

  Container.prototype._lookupPosition = function _lookupPosition (node) {
    if (node.hasParent()) {
      node = node.getRoot();
    }
    return this.getContent().indexOf(node.id)
  };

  Container.prototype._enableCaching = function _enableCaching () {
    // this hook is used to invalidate cached positions
    // caching is done only in the 'real' document, not in a TransactionDocument
    if (this.document) {
      this.document.data.on('operation:applied', this._onOperationApplied, this);
      this._isCaching = true;
    }
  };

  Container.prototype._onOperationApplied = function _onOperationApplied (op) {
    if (op.type === 'set' || op.type === 'update') {
      if (op.path[0] === this.id) {
        this._invalidateCache();
      }
    }
  };

  Container.prototype._onDocumentChange = function _onDocumentChange (change) {
    if (change.isUpdated(this.getContentPath())) {
      this._invalidateCache();
    }
  };

  // NOTE: this has been in ParentNodeMixin before
  // TODO: try to get rid of this

  Container.prototype.hasChildren = function hasChildren () {
    return this.nodes.length > 0
  };

  Container.prototype.getChildIndex = function getChildIndex (child) {
    return this.nodes.indexOf(child.id)
  };

  Container.prototype.getChildren = function getChildren () {
    var doc = this.getDocument();
    var childrenIds = this.nodes;
    return childrenIds.map(function(id) {
      return doc.get(id)
    })
  };

  Container.prototype.getChildAt = function getChildAt (idx) {
    var childrenIds = this.nodes;
    if (idx < 0 || idx >= childrenIds.length) {
      throw new Error('Array index out of bounds: ' + idx + ", " + childrenIds.length)
    }
    return this.getDocument().get(childrenIds[idx])
  };

  Container.prototype.getChildCount = function getChildCount () {
    return this.nodes.length
  };

  Object.defineProperties( Container.prototype, prototypeAccessors );

  return Container;
}(DocumentNode));

Container.prototype._isContainer = true;

Container.schema = {
  type: 'container',
  nodes: { type: ['array', 'id'], default: [] }
};

var Annotation = (function (DocumentNode$$1) {
  function Annotation(doc, props) {
    DocumentNode$$1.call(this, doc, _normalizedProps(props));

    // wrap coordinates
    this.start = new Coordinate(this.start);
    this.end = new Coordinate(this.end);
  }

  if ( DocumentNode$$1 ) Annotation.__proto__ = DocumentNode$$1;
  Annotation.prototype = Object.create( DocumentNode$$1 && DocumentNode$$1.prototype );
  Annotation.prototype.constructor = Annotation;

  var prototypeAccessors = { startPath: {},startOffset: {},endPath: {},endOffset: {} };

  prototypeAccessors.startPath.get = function () {
    console.warn('DEPRECATED: use Annotation.start.path instead.');
    return this.start.path
  };

  prototypeAccessors.startPath.set = function (path) {
    console.warn('DEPRECATED: use Annotation.start.path instead.');
    this.start.path = path;
  };

  prototypeAccessors.startOffset.get = function () {
    console.warn('DEPRECATED: use Annotation.start.offset instead.');
    return this.start.offset
  };

  prototypeAccessors.startOffset.set = function (offset) {
    console.warn('DEPRECATED: use Annotation.start.offset instead.');
    this.start.offset = offset;
  };

  prototypeAccessors.endPath.get = function () {
    console.warn('DEPRECATED: use Annotation.end.path instead.');
    return this.end.path
  };

  prototypeAccessors.endPath.set = function (path) {
    console.warn('DEPRECATED: use Annotation.end.path instead.');
    this.end.path = path;
  };

  prototypeAccessors.endOffset.get = function () {
    console.warn('DEPRECATED: use Annotation.end.offset instead.');
    return this.end.offset
  };

  prototypeAccessors.endOffset.set = function (offset) {
    console.warn('DEPRECATED: use Annotation.end.offset instead.');
    this.end.offset = offset;
  };

  /**
    Get the plain text spanned by this annotation.

    @return {String}
  */
  Annotation.prototype.getText = function getText () {
    var doc = this.getDocument();
    if (!doc) {
      console.warn('Trying to use a Annotation which is not attached to the document.');
      return ""
    }
    return documentHelpers.getTextForSelection(doc, this.getSelection())
  };

  /**
    Determines if an annotation can be split e.g., when breaking a node.

    In these cases, a new annotation will be created attached to the created node.

    For certain annotation types,you may want to the annotation truncated
    rather than split, where you need to override this method returning `false`.
  */
  Annotation.prototype.canSplit = function canSplit () {
    return true
  };

  /**
    If this annotation is an Anchor.

    Anchors are annotations with a zero width.
    For instance, ContainerAnnotation have a start and an end anchor,
    or rendered cursors are modeled as anchors.

    @returns {Boolean}
  */
  Annotation.prototype.isAnchor = function isAnchor () {
    return false
  };

  Object.defineProperties( Annotation.prototype, prototypeAccessors );

  return Annotation;
}(DocumentNode));

Annotation.define({
  type: "annotation",
  start: "coordinate",
  end: "coordinate"
});

Annotation.prototype._isAnnotation = true;

function _normalizedProps(props) {
  if (!props.hasOwnProperty('start')) {
    /*
      Instead of
        { path: [...], startOffset: 0, endOffset: 10 }
      use
        { start: { path: [], offset: 0 }, end: { path: [], offset: 10 } }
    */
    console.warn('DEPRECATED: create Annotation with "start" and "end" coordinate instead.');
    props = Object.assign({}, props);
    props.start = {
      path: props.startPath || props.path,
      offset: props.startOffset
    };
    props.end = {};
    if (props.hasOwnProperty('endPath')) {
      props.end.path = props.endPath;
    } else {
      props.end.path = props.start.path;
    }
    if (props.hasOwnProperty('endOffset')) {
      props.end.offset = props.endOffset;
    } else {
      props.end.offset = props.start.offset;
    }
    delete props.path;
    delete props.startPath;
    delete props.endPath;
    delete props.startOffset;
    delete props.endOffset;
  } else if (props.hasOwnProperty('end') && !props.end.path) {
    props.end.path = props.start.path;
  }
  return props
}

/*
  Describes an annotation sticking on a container that can span over multiple
  nodes.

  @class

  @example

  ```js
  {
    "id": "subject_reference_1",
    "type": "subject_reference",
    "containerId": "content",
    "start": {
      "path": ["text_2", "content"],
      "offset": 100,
    },
    "end": {
      "path": ["text_4", "content"],
      "offset": 40
    }
  }
  ```
 */

var ContainerAnnotation = (function (Annotation$$1) {
  function ContainerAnnotation () {
    Annotation$$1.apply(this, arguments);
  }

  if ( Annotation$$1 ) ContainerAnnotation.__proto__ = Annotation$$1;
  ContainerAnnotation.prototype = Object.create( Annotation$$1 && Annotation$$1.prototype );
  ContainerAnnotation.prototype.constructor = ContainerAnnotation;

  ContainerAnnotation.prototype.getSelection = function getSelection () {
    var doc = this.getDocument();
    // Guard: when this is called while this node has been detached already.
    if (!doc) {
      console.warn('Trying to use a ContainerAnnotation which is not attached to the document.');
      return Selection.nullSelection()
    }
    return doc.createSelection({
      type: "container",
      containerId: this.containerId,
      startPath: this.start.path,
      startOffset: this.start.offset,
      endPath: this.end.path,
      endOffset: this.end.offset
    })
  };

  ContainerAnnotation.prototype.setHighlighted = function setHighlighted (highlighted, scope) {
    if (this.highlighted !== highlighted) {
      this.highlighted = highlighted;
      this.highlightedScope = scope;
      this.emit('highlighted', highlighted, scope);
      forEach(this.fragments, function(frag) {
        frag.emit('highlighted', highlighted, scope);
      });
    }
  };

  ContainerAnnotation.prototype._updateRange = function _updateRange (tx, sel) {
    if (!sel.isContainerSelection()) {
      throw new Error('Invalid argument.')
    }
    // TODO: use coordinate ops
    if (!isEqual(this.start.path, sel.start.path)) {
      tx.set([this.id, 'start', 'path'], sel.start.path);
    }
    if (this.start.offset !== sel.start.offset) {
      tx.set([this.id, 'start', 'offset'], sel.start.offset);
    }
    if (!isEqual(this.end.path, sel.end.path)) {
      tx.set([this.id, 'end', 'path'], sel.end.path);
    }
    if (this.end.offset !== sel.end.offset) {
      tx.set([this.id, 'end', 'offset'], sel.end.offset);
    }
  };

  return ContainerAnnotation;
}(Annotation));

ContainerAnnotation.schema = {
  type: "container-annotation",
  containerId: "string"
};

ContainerAnnotation.prototype._isContainerAnnotation = true;

/**
  A property annotation can be used to overlay text and give it a special meaning.
  PropertyAnnotations only work on text properties. If you want to annotate multiple
  nodes you have to use a {@link model/ContainerAnnotation}.

  @prop {String[]} path Identifies a text property in the document (e.g. `['text_1', 'content']`)
  @prop {Number} startOffset the character where the annoation starts
  @prop {Number} endOffset: the character where the annoation starts

  @example

  Here's how a **strong** annotation is created. In Substance annotations are stored
  separately from the text. Annotations are just regular nodes in the document.
  They refer to a certain range (`startOffset, endOffset`) in a text property (`path`).

  ```js
  doc.transaction(function(tx) {
    tx.create({
      id: 's1',
      type: 'strong',
      start: {
        path: ['p1', 'content'],
        offset: 10
      },
      end: {
        offset
      }
      path: ['p1', 'content'],
      "startOffset": 10,
      "endOffset": 19
    })
  })
  ```
*/
var PropertyAnnotation = (function (Annotation$$1) {
  function PropertyAnnotation () {
    Annotation$$1.apply(this, arguments);
  }

  if ( Annotation$$1 ) PropertyAnnotation.__proto__ = Annotation$$1;
  PropertyAnnotation.prototype = Object.create( Annotation$$1 && Annotation$$1.prototype );
  PropertyAnnotation.prototype.constructor = PropertyAnnotation;

  var prototypeAccessors = { path: {},startPath: {},endPath: {} };

  prototypeAccessors.path.get = function () {
    return this.start.path
  };

  PropertyAnnotation.prototype.getPath = function getPath () {
    return this.start.path
  };

  PropertyAnnotation.prototype.getSelection = function getSelection () {
    return this.getDocument().createSelection({
      type: 'property',
      path: this.path,
      startOffset: this.start.offset,
      endOffset: this.end.offset
    })
  };

  // used by annotationHelpers
  PropertyAnnotation.prototype._updateRange = function _updateRange (tx, sel) {
    if (!sel.isPropertySelection()) {
      throw new Error('Invalid argument: PropertyAnnotation._updateRange() requires a PropertySelection.')
    }
    if (!isArrayEqual(this.start.path, sel.start.path)) {
      tx.set([this.id, 'path'], sel.start.path);
    }
    // TODO: these should be Coordinate ops
    if (this.start.offset !== sel.start.offset) {
      tx.set([this.id, 'start', 'offset'], sel.start.offset);
    }
    if (this.end.offset !== sel.end.offset) {
      tx.set([this.id, 'end', 'offset'], sel.end.offset);
    }
  };

  prototypeAccessors.startPath.get = function () {
    return this.path
  };

  prototypeAccessors.endPath.get = function () {
    return this.path
  };

  Object.defineProperties( PropertyAnnotation.prototype, prototypeAccessors );

  return PropertyAnnotation;
}(Annotation));

PropertyAnnotation.isPropertyAnnotation = true;
PropertyAnnotation.prototype._isAnnotation = true;
PropertyAnnotation.prototype._isPropertyAnnotation = true;

PropertyAnnotation.schema = {
  type: "annotation",
  start: "coordinate",
  end: "coordinate",
  // this is only used when an annotation is used 'stand-alone'
  // i.e. not attached to a property
  _content: { type: "string", optional: true}
};

var ENTER = 1;
var EXIT = -1;
var ANCHOR = -2;

// Fragmenter
// --------
//
// An algorithm that is used to fragment overlapping structure elements
// following a priority rule set.
// E.g., we use this for creating DOM elements for annotations. The annotations
// can partially be overlapping. However this is not allowed in general for DOM elements
// or other hierarchical structures.
//
// Example: For the annotation use case consider a 'comment' spanning partially
// over an 'emphasis' annotation.
// 'The <comment>quick brown <bold>fox</comment> jumps over</bold> the lazy dog.'
// We want to be able to create a valid XML structure:
// 'The <comment>quick brown <bold>fox</bold></comment><bold> jumps over</bold> the lazy dog.'
//
// For that one would choose
//
//     {
//        'comment': 0,
//        'bold': 1
//     }
//
// as priority levels.
// In case of structural violations as in the example, elements with a higher level
// would be fragmented and those with lower levels would be preserved as one piece.
//
// TODO: If a violation for nodes of the same level occurs an Error should be thrown.
// Currently, in such cases the first element that is opened earlier is preserved.

var Fragmenter = function Fragmenter(options) {
  Object.assign(this, options);
};

Fragmenter.prototype.start = function start (rootContext, text, annotations) {
  if (!isString(text)) {
    throw new Error("Illegal argument: 'text' must be a String, but was " + text)
  }
  this._start(rootContext, text, annotations);
};

Fragmenter.prototype.onText = function onText (context, text, entry) { // eslint-disable-line
};

// should return the created user context
Fragmenter.prototype.onEnter = function onEnter (entry, parentContext) { // eslint-disable-line
  return null
};

Fragmenter.prototype.onExit = function onExit (entry, context, parentContext) { // eslint-disable-line
};

Fragmenter.prototype._enter = function _enter (entry, parentContext) {
  entry.counter++;
  return this.onEnter(entry, parentContext)
};

Fragmenter.prototype._exit = function _exit (entry, context, parentContext) {
  this.onExit(entry, context, parentContext);
};

Fragmenter.prototype._createText = function _createText (context, text, entry) {
  this.onText(context, text, entry);
};

Fragmenter.prototype._start = function _start (rootContext, text, annotations) {
    var this$1 = this;

  var entries = _extractEntries.call(this, annotations);
  var stack = [{context: rootContext, entry: null}];

  var pos = 0;
  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i];
    var textFragment = text.substring(pos, entry.pos);
    if (textFragment) {
      // add the last text to the current element
      this$1._createText(stack[stack.length-1].context, textFragment, entry);
    }

    pos = entry.pos;
    var stackLevel, idx, _entry;
    if (entry.mode === ENTER || entry.mode === ANCHOR) {
      // find the correct position and insert an entry
      for (stackLevel = 1; stackLevel < stack.length; stackLevel++) {
        if (entry.level < stack[stackLevel].entry.level) {
          break
        }
      }
      // create elements which are open, and are now stacked ontop of the
      // entered entry
      for (idx = stack.length-1; idx >= stackLevel; idx--) {
        _entry = stack[idx].entry;
        // compute number of characters since last 'enter'
        _entry.length = pos - _entry.pos;
        this$1._exit(_entry, stack[idx].context, stack[idx-1].context);
      }
      stack.splice(stackLevel, 0, {entry: entry});
      // create new elements for all lower entries
      for (idx = stackLevel; idx < stack.length; idx++) {
        _entry = stack[idx].entry;
        // bump 'enter' pos
        _entry.pos = pos;
        stack[idx].context = this$1._enter(_entry, stack[idx-1].context);
      }
    }
    if (entry.mode === EXIT || entry.mode === ANCHOR) {
      // find the according entry and remove it from the stack
      for (stackLevel = 1; stackLevel < stack.length; stackLevel++) {
        if (stack[stackLevel].entry.node === entry.node) {
          break
        }
      }
      for (idx = stack.length-1; idx >= stackLevel; idx--) {
        _entry = stack[idx].entry;
        // compute number of characters since last 'enter'
        _entry.length = pos - _entry.pos;
        this$1._exit(_entry, stack[idx].context, stack[idx-1].context);
      }
      stack.splice(stackLevel, 1);
      // create new elements for all lower entries
      for (idx = stackLevel; idx < stack.length; idx++) {
        _entry = stack[idx].entry;
        // bump 'enter' pos
        _entry.pos = pos;
        stack[idx].context = this$1._enter(_entry, stack[idx-1].context);
      }
    }
  }

  // Finally append a trailing text node
  var trailingText = text.substring(pos);
  if (trailingText) {
    this._createText(rootContext, trailingText);
  }
};

Fragmenter.SHOULD_NOT_SPLIT = 0;
Fragmenter.NORMAL = 10;
Fragmenter.ANY = 100;
Fragmenter.ALWAYS_ON_TOP = Number.MAX_VALUE;

// This is a sweep algorithm wich uses a set of ENTER/EXIT entries
// to manage a stack of active elements.
// Whenever a new element is entered it will be appended to its parent element.
// The stack is ordered by the annotation types.
//
// Examples:
//
// - simple case:
//
//       [top] -> ENTER(idea1) -> [top, idea1]
//
//   Creates a new 'idea' element and appends it to 'top'
//
// - stacked ENTER:
//
//       [top, idea1] -> ENTER(bold1) -> [top, idea1, bold1]
//
//   Creates a new 'bold' element and appends it to 'idea1'
//
// - simple EXIT:
//
//       [top, idea1] -> EXIT(idea1) -> [top]
//
//   Removes 'idea1' from stack.
//
// - reordering ENTER:
//
//       [top, bold1] -> ENTER(idea1) -> [top, idea1, bold1]
//
//   Inserts 'idea1' at 2nd position, creates a new 'bold1', and appends itself to 'top'
//
// - reordering EXIT
//
//       [top, idea1, bold1] -> EXIT(idea1)) -> [top, bold1]
//
//   Removes 'idea1' from stack and creates a new 'bold1'
//

function _extractEntries(annotations) {
  var openers = [];
  var closers = [];
  forEach(annotations, function(a) {
    var isAnchor = (a.isAnchor ? a.isAnchor() : false);
    // special treatment for zero-width annos such as ContainerAnnotation.Anchors
    if (isAnchor) {
      openers.push({
        mode: ANCHOR,
        pos: a.offset,
        id: a.id,
        level: Fragmenter.ALWAYS_ON_TOP,
        type: 'anchor',
        node: a,
        counter: -1,
        length: 0
      });
    } else {
      // TODO better naming, `Node.level` does not say enough
      // Better would be `Node.fragmentation = Fragmenter.SHOULD_NOT_SPLIT;`
      // meaning, that the fragmenter should try to render the fragment as one single
      // element, and not splitting it up on different stack levels.
      // E.g. When bold an link are overlapping
      // the fragmenter should not split the link element such as A<b>B<a>CD</a></b><a>EF</a>GH
      // but should instead A<b>B</b><a><b>CD</b><a>EF</a>GH

      // use a weak default level when not given
      var l = Fragmenter.NORMAL;
      var isInline = (a.isInline ? a.isInline() : false);
      if (isInline) {
        l = Number.MAX_VALUE;
      } else if (a.constructor.hasOwnProperty('fragmentation')) {
        l = a.constructor.fragmentation;
      } else if (a.hasOwnProperty('fragmentationHint')) {
        l = a.fragmentationHint;
      }
      var startOffset = Math.min(a.start.offset, a.end.offset);
      var endOffset = Math.max(a.start.offset, a.end.offset);
      var opener = {
        pos: startOffset,
        mode: ENTER,
        level: l,
        id: a.id,
        type: a.type,
        node: a,
        length: 0,
        counter: -1,
      };
      openers.push(opener);
      closers.push({
        pos: endOffset,
        mode: EXIT,
        level: l,
        id: a.id,
        type: a.type,
        node: a,
        opener: opener
      });
    }
  });

  // sort the openers
  openers.sort(_compareOpeners);
  // store indexes for openers
  for (var i = openers.length - 1; i >= 0; i--) {
    openers[i].idx = i;
  }
  closers.sort(_compareClosers);
  // merge openers and closers, sorted by pos
  var entries = new Array(openers.length+closers.length);
  var idx = 0;
  var idx1 = 0;
  var idx2 = 0;
  var opener = openers[idx1];
  var closer = closers[idx2];
  while(opener || closer) {
    if (opener && closer) {
      // close before open
      if (closer.pos <= opener.pos && closer.opener !== opener) {
        entries[idx] = closer;
        idx2++;
      } else {
        entries[idx] = opener;
        idx1++;
      }
    } else if (opener) {
      entries[idx] = opener;
      idx1++;
    } else if (closer) {
      entries[idx] = closer;
      idx2++;
    }
    opener = openers[idx1];
    closer = closers[idx2];
    idx++;
  }
  return entries
}

function _compareOpeners(a, b) {
  if (a.pos < b.pos) { return -1 }
  if (a.pos > b.pos) { return 1 }
  if (a.mode < b.mode) { return -1 }
  if (a.mode > b.mode) { return 1 }
  if (a.mode === b.mode) {
    if (a.level < b.level) { return -1 }
    if (a.level > b.level) { return 1 }
  }
  return 0
}

// sort in inverse order of openers
function _compareClosers(a, b) {
  if (a.pos < b.pos) { return -1 }
  if (a.pos > b.pos) { return 1 }
  // this makes closer be sorted in inverse order of openers
  // to reduce stack sice
  // HACK: a bit trial error. When we have to collapsed annotations
  // at the same position then we want the closers in the same order
  // as the openers.
  if (a.pos === a.opener.pos && b.pos === b.opener.pos) {
    if (a.opener.idx < b.opener.idx) {
      return -1
    } else {
      return 1
    }
  }
  if (a.opener.idx > b.opener.idx) { return -1 }
  if (a.opener.idx < b.opener.idx) { return 1 }
  return 0
}

/*
  Escape XML Entities

  HACK: this is just a cheap implementation to escape XML entities
*/
function encodeXMLEntities(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
}

var DOMExporter = function DOMExporter(config, context) {
  this.context = context || {};
  if (!config.converters) {
    throw new Error('config.converters is mandatory')
  }
  if (!config.converters._isRegistry) {
    this.converters = new Registry();
    config.converters.forEach(function(Converter) {
      var converter = isFunction$2(Converter) ? new Converter() : Converter;
      if (!converter.type) {
        console.error('Converter must provide the type of the associated node.', converter);
        return
      }
      this.converters.add(converter.type, converter);
    }.bind(this));
  } else {
    this.converters = config.converters;
  }

  this.state = {
    doc: null
  };
  this.config = config;
  // NOTE: Subclasses (HTMLExporter and XMLExporter) must initialize this
  // with a proper DOMElement instance which is used to create new elements.
  this._elementFactory = config.elementFactory;
  if (!this._elementFactory) {
    throw new Error("'elementFactory' is mandatory")
  }
  this.$$ = this.createElement.bind(this);
};

DOMExporter.prototype.exportDocument = function exportDocument (doc) {
  // TODO: this is no left without much functionality
  // still, it would be good to have a consistent top-level API
  // i.e. converter.importDocument(el) and converter.exportDocument(doc)
  // On the other side, the 'internal' API methods are named this.convert*.
  return this.convertDocument(doc)
};

/**
  @param {Document}
  @returns {DOMElement|DOMElement[]} The exported document as DOM or an array of elements
           if exported as partial, which depends on the actual implementation
           of `this.convertDocument()`.

  @abstract
  @example

  convertDocument(doc) {
    var elements = this.convertContainer(doc, this.state.containerId)
    var out = elements.map(function(el) {
      return el.outerHTML
    })
    return out.join('')
  }
*/
DOMExporter.prototype.convertDocument = function convertDocument (doc) { // eslint-disable-line
  throw new Error('This method is abstract')
};

DOMExporter.prototype.convertContainer = function convertContainer (container) {
  if (!container) {
    throw new Error('Illegal arguments: container is mandatory.')
  }
  var doc = container.getDocument();
  this.state.doc = doc;
  var elements = [];
  container.nodes.forEach(function(id) {
    var node = doc.get(id);
    var nodeEl = this.convertNode(node);
    elements.push(nodeEl);
  }.bind(this));
  return elements
};

DOMExporter.prototype.convertNode = function convertNode (node) {
  if (isString(node)) {
    // Assuming this.state.doc has been set by convertDocument
    node = this.state.doc.get(node);
  } else {
    this.state.doc = node.getDocument();
  }
  var converter = this.getNodeConverter(node);
  // special treatment for annotations, i.e. if someone calls
  // `exporter.convertNode(anno)`
  if (node._isPropertyAnnotation && (!converter || !converter.export)) {
    return this._convertPropertyAnnotation(node)
  }
  if (!converter) {
    converter = this.getDefaultBlockConverter();
  }
  var el;
  if (converter.tagName) {
    el = this.$$(converter.tagName);
  } else {
    el = this.$$('div');
  }
  el.attr(this.config.idAttribute, node.id);
  if (converter.export) {
    el = converter.export(node, el, this) || el;
  } else {
    el = this.getDefaultBlockConverter().export(node, el, this) || el;
  }
  return el
};

DOMExporter.prototype.convertProperty = function convertProperty (doc, path, options) {
  this.initialize(doc, options);
  var wrapper = this.$$('div')
    .append(this.annotatedText(path));
  return wrapper.innerHTML
};

DOMExporter.prototype.annotatedText = function annotatedText (path) {
  var doc = this.state.doc;
  var text = doc.get(path);
  var annotations = doc.getIndex('annotations').get(path);
  return this._annotatedText(text, annotations)
};

DOMExporter.prototype.getNodeConverter = function getNodeConverter (node) {
  return this.converters.get(node.type)
};

DOMExporter.prototype.getDefaultBlockConverter = function getDefaultBlockConverter () {
  throw new Error('This method is abstract.')
};

DOMExporter.prototype.getDefaultPropertyAnnotationConverter = function getDefaultPropertyAnnotationConverter () {
  throw new Error('This method is abstract.')
};

DOMExporter.prototype.getDocument = function getDocument () {
  return this.state.doc
};

DOMExporter.prototype.createElement = function createElement (str) {
  return this._elementFactory.createElement(str)
};

DOMExporter.prototype._annotatedText = function _annotatedText (text, annotations) {
  var self = this;

  var annotator = new Fragmenter();
  annotator.onText = function(context, text) {
    context.children.push(encodeXMLEntities(text));
  };
  annotator.onEnter = function(fragment) {
    var anno = fragment.node;
    return {
      annotation: anno,
      children: []
    }
  };
  annotator.onExit = function(fragment, context, parentContext) {
    var anno = context.annotation;
    var converter = self.getNodeConverter(anno);
    if (!converter) {
      converter = self.getDefaultPropertyAnnotationConverter();
    }
    var el;
    if (converter.tagName) {
      el = this.$$(converter.tagName);
    } else {
      el = this.$$('span');
    }
    el.attr(this.config.idAttribute, anno.id);
    el.append(context.children);
    if (converter.export) {
      el = converter.export(anno, el, self) || el;
    }
    parentContext.children.push(el);
  }.bind(this);
  var wrapper = { children: [] };
  annotator.start(wrapper, text, annotations);
  return wrapper.children
};

/*
  This is used when someone calls `exporter.convertNode(anno)`
  Usually, annotations are converted by calling exporter.annotatedText(path).
  Still it makes sense to be able to export just a fragment containing just
  the annotation element.
*/
DOMExporter.prototype._convertPropertyAnnotation = function _convertPropertyAnnotation (anno) {
  // take only the annotations within the range of the anno
  var wrapper = this.$$('div').append(this.annotatedText(anno.path));
  var el = wrapper.find('['+this.config.idAttribute+'="'+anno.id+'"]');
  return el
};

function createCountingIdGenerator() {
  var counters = {};
  return function uuid(prefix) {
    if (!counters.hasOwnProperty(prefix)) {
      counters[prefix] = 1;
    }
    var result = [prefix, '-', counters[prefix]++].join('');
    return result
  }
}

var WS_LEFT = /^\s+/g;
var WS_LEFT_ALL = /^\s*/g;
var WS_RIGHT = /\s+$/g;
var WS_ALL = /\s+/g;
// var ALL_WS_NOTSPACE_LEFT = /^[\t\n]+/g
// var ALL_WS_NOTSPACE_RIGHT = /[\t\n]+$/g
var SPACE = " ";
var TABS_OR_NL = /[\t\n\r]+/g;

/**
  A generic base implementation for XML/HTML importers.

  @class
  @param {Object} config
 */
var DOMImporter = function DOMImporter(config, context) {
  this.context = context || {};

  if (!config.converters) {
    throw new Error('config.converters is mandatory')
  }
  if (!config.DocumentClass) {
    throw new Error('DocumentClass is mandatory')
  }

  this.config = extend({ idAttribute: 'id' }, config);
  this.schema = config.schema;
  this.state = null;

  this._defaultBlockConverter = null;
  this._allConverters = [];
  this._blockConverters = [];
  this._propertyAnnotationConverters = [];

  var schema = this.schema;
  var defaultTextType = schema.getDefaultTextType();

  config.converters.forEach(function(Converter) {
    var converter;
    if (typeof Converter === 'function') {
      // console.log('installing converter', Converter)
      converter = new Converter();
    } else {
      converter = Converter;
    }
    if (!converter.type) {
      console.error('Converter must provide the type of the associated node.', converter);
      return
    }
    if (!converter.matchElement && !converter.tagName) {
      console.error('Converter must provide a matchElement function or a tagName property.', converter);
      return
    }
    if (!converter.matchElement) {
      converter.matchElement = this._defaultElementMatcher.bind(converter);
    }
    var NodeClass = schema.getNodeClass(converter.type);
    if (!NodeClass) {
      console.error('No node type defined for converter', converter.type);
      return
    }
    if (!this._defaultBlockConverter && defaultTextType === converter.type) {
      this._defaultBlockConverter = converter;
    }

    this._allConverters.push(converter);
    // Defaults to _blockConverters
    if (NodeClass.prototype._isPropertyAnnotation) {
      this._propertyAnnotationConverters.push(converter);
    } else {
      this._blockConverters.push(converter);
    }

  }.bind(this));

  this.state = new DOMImporter.State();
};

DOMImporter.prototype.reset = function reset () {
  this.state.reset();
  this.createDocument();
};

DOMImporter.prototype.createDocument = function createDocument () {
  this.state.doc = this._createDocument(this.config.schema);
  return this.state.doc
};

// Note: this is e.g. shared by ClipboardImporter which has a different
// implementation of this.createDocument()
DOMImporter.prototype._createDocument = function _createDocument (schema) {
  // create an empty document and initialize the container if not present
  var doc = new this.config.DocumentClass(schema);
  return doc
};

// should be called at the end to finish conversion
// For instance, the creation of annotation is deferred
// to make sure that the nodes they are attached to are created first
// TODO: we might want to rethink this in future
// as it makes this a bit more complicated
DOMImporter.prototype.generateDocument = function generateDocument () {
  if (!this.state.doc) {
    this.state.doc = this.createDocument();
  }
  this._createNodes();
  return this.state.doc
};

DOMImporter.prototype._createNodes = function _createNodes$1 () {
  var state = this.state;
  _createNodes(state.doc, state.nodes);
  this._createInlineNodes();
};

DOMImporter.prototype._createInlineNodes = function _createInlineNodes () {
  var state = this.state;
  _createNodes(state.doc, state.inlineNodes);
};

/**
  Converts and shows all children of a given element.

  @param {ui/DOMElement[]} elements All elements that should be converted into the container.
  @param {String} containerId The id of the target container node.
  @returns {Object} the preliminary container node
 */
DOMImporter.prototype.convertContainer = function convertContainer (elements, containerId) {
    var this$1 = this;

  var state = this.state;
  state.container = [];
  state.containerId = containerId;
  var iterator = new ArrayIterator(elements);
  while(iterator.hasNext()) {
    var el = iterator.next();
    var blockTypeConverter = this$1._getConverterForElement(el, 'block');
    var node;
    if (blockTypeConverter) {
      node = this$1._createNode(el, blockTypeConverter.type);
      state.pushContext(el.tagName, blockTypeConverter);
      node = blockTypeConverter.import(el, node, this$1) || node;
      state.popContext();
      this$1._createAndShow(node);
    } else {
      if (el.isCommentNode()) {
        // skip HTML comment nodes on block level
      } else if (el.isTextNode()) {
        var text = el.textContent;
        if (/^\s*$/.exec(text)) { continue }
        // If we find text nodes on the block level we wrap
        // it into a paragraph element (or what is configured as default block level element)
        iterator.back();
        this$1._wrapInlineElementsIntoBlockElement(iterator);
      } else if (el.isElementNode()) {
        // NOTE: hard to tell if unsupported nodes on this level
        // should be treated as inline or not.
        // ATM: we apply a catch-all to handle cases where inline content
        // is found on top level
        iterator.back();
        this$1._wrapInlineElementsIntoBlockElement(iterator);
      }
    }
  }
  var container = {
    type: 'container',
    id: containerId,
    nodes: this.state.container.slice(0)
  };
  this.createNode(container);
  return container
};

/**
  Converts a single HTML element and creates a node in the current document.

  @param {ui/DOMElement} el the HTML element
  @returns {object} the created node as JSON
 */
DOMImporter.prototype.convertElement = function convertElement (el) {
  var isTopLevel = !this.state.isConverting;
  if (isTopLevel) {
    this.state.isConverting = true;
  }
  var node = this._convertElement(el);
  // HACK: to allow using an importer stand-alone
  // i.e. creating detached elements
  if (this.config["stand-alone"] && isTopLevel) {
    this.state.isConverting = false;
    this.generateDocument();
    node = this.state.doc.get(node.id);
    this.reset();
  }
  return node
};

DOMImporter.prototype._convertElement = function _convertElement (el, mode) {
  var node;
  var converter = this._getConverterForElement(el, mode);
  if (converter) {
    node = this._createNode(el, converter.type);
    var NodeClass = this.schema.getNodeClass(node.type);
    this.state.pushContext(el.tagName, converter);
    // Note: special treatment for property annotations and inline nodes
    // i.e. if someone calls `importer.convertElement(annoEl)`
    // usually, annotations are imported in the course of `importer.annotatedText(..)`
    // The peculiarity here is that in such a case, it is not
    // not clear, which property the annotation is attached to
    if (NodeClass.isInline) {
      this._convertInlineNode(el, node, converter);
    }
    else if (NodeClass.prototype._isPropertyAnnotation) {
      this._convertPropertyAnnotation(el, node);
    } else {
      node = converter.import(el, node, this) || node;
    }
    this.state.popContext();
    this.createNode(node);
  } else {
    throw new Error('No converter found for '+el.tagName)
  }
  return node
};

DOMImporter.prototype._convertPropertyAnnotation = function _convertPropertyAnnotation (el, node) {
  // if there is no context, this is called stand-alone
  // i.e., user tries to convert an annotation element
  // directly, not part of a block element, such as a paragraph
  node._content = this.annotatedText(el, node.path);
  node.start = {
    path: [node.id, '_content'],
    offset: 0
  };
  node.end = {
    offset: node._content.length
  };
};

DOMImporter.prototype._convertInlineNode = function _convertInlineNode (el, node, converter) {
  node._content = '$';
  node.start = {
    path: [node.id, '_content'],
    offset: 0
  };
  node.end = {
    offset: 1
  };
  node = converter.import(el, node, this);
  return node
};

DOMImporter.prototype.createNode = function createNode (node) {
  if (!node.type) {
    throw new Error('node.type required.')
  }
  if (!node.id) {
    node.id = this.nextId(node.type);
  }
  if (this.state.ids[node.id]) {
    throw new Error('Node with id alread exists:' + node.id)
  }
  this.state.ids[node.id] = true;
  this.state.nodes.push(node);
  return node
};

DOMImporter.prototype.show = function show (node) {
  this.state.container.push(node.id);
};

DOMImporter.prototype._createNode = function _createNode (el, type) {
  var NodeClass = this.schema.getNodeClass(type);
  if (!NodeClass) { throw new Error('No NodeClass registered for type '+type) }
  var nodeData = {};
  forEach(NodeClass.schema, function(prop, name) {
    if (prop.hasDefault()) {
      nodeData[name] = clone(prop.default);
    } else {
      // otherwise we use a default value
      // so that Node creation will still succeed
      // TODO: this might be risky if the Node impl is relying
      // on all data being valid
      nodeData[name] = prop.createDefaultValue();
    }
  });
  nodeData.type = type;
  nodeData.id = this.getIdForElement(el, type);
  // NOTE: this instance is detached,
  // still we want a real instance for sake of consistency
  var node = new NodeClass(null, nodeData);
  return node
};

DOMImporter.prototype._createAndShow = function _createAndShow (node) {
  this.createNode(node);
  this.show(node);
};

/**
  Convert annotated text. You should call this method only for elements
  containing rich-text.

  @param {ui/DOMElement} el
  @param {String[]} path The target property where the extracted text (plus annotations) should be stored.
  @param {Object} options
  @param {Boolean} options.preserveWhitespace when true will preserve whitespace. Default: false.
  @returns {String} The converted text as plain-text
 */
DOMImporter.prototype.annotatedText = function annotatedText (el, path, options) {
  var state = this.state;
  if (path) {
    // if (state.stack.length>0) {
    // throw new Error('Contract: it is not allowed to bind a new call annotatedText to a path while the previous has not been completed.', el.outerHTML)
    // }
    if (options && options.preserveWhitespace) {
      state.preserveWhitespace = true;
    }
    state.stack.push({ path: path, offset: 0, text: ""});
  } else {
    if (state.stack.length===0) {
      throw new Error("Contract: DOMImporter.annotatedText() requires 'path' for non-reentrant call.", el.outerHTML)
    }
  }
  // IMO we should reset the last char, as it is only relevant within one
  // annotated text property. This feature is mainly used to eat up
  // whitespace in XML/HTML at tag boundaries, produced by pretty-printed XML/HTML.
  this.state.lastChar = '';
  var text;
  var iterator = el.getChildNodeIterator();
  text = this._annotatedText(iterator);
  if (path) {
    state.stack.pop();
    state.preserveWhitespace = false;
  }
  return text
};

/**
  Converts the given element as plain-text.

  @param {ui/DOMElement} el
  @returns {String} The plain text
 */
DOMImporter.prototype.plainText = function plainText (el) {
  var state = this.state;
  var text = el.textContent;
  if (state.stack.length > 0) {
    var context = last$2(state.stack);
    context.offset += text.length;
    context.text += context.text.concat(text);
  }
  return text
};

/**
  Tells the converter to insert custom text.

  This is useful when during conversion a generated label needs to be inserted instead
  of real text.

  @param {String}
 */
DOMImporter.prototype.customText = function customText (text) {
  var state = this.state;
  if (state.stack.length > 0) {
    var context = last$2(state.stack);
    context.offset += text.length;
    context.text += context.text.concat(text);
  }
  return text
};

/**
  Generates an id. The generated id is unique with respect to all ids generated so far.

  @param {String} a prefix
  @return {String} the generated id
 */
DOMImporter.prototype.nextId = function nextId (prefix) {
  // TODO: we could create more beautiful ids?
  // however we would need to be careful as there might be another
  // element in the HTML coming with that id
  // For now we use shas
  return this.state.uuid(prefix)
};

DOMImporter.prototype.getIdForElement = function getIdForElement (el, type) {
    var this$1 = this;

  var id = el.getAttribute(this.config.idAttribute);
  if (id && !this.state.ids[id]) { return id }

  var root = el.getRoot();
  id = this.nextId(type);
  while (this.state.ids[id] || root.find('#'+id)) {
    id = this$1.nextId(type);
  }
  return id
};

DOMImporter.prototype.defaultConverter = function defaultConverter (el, converter) {
  if (!this.IGNORE_DEFAULT_WARNINGS) {
    console.warn('This element is not handled by the converters you provided. This is the default implementation which just skips conversion. Override DOMImporter.defaultConverter(el, converter) to change this behavior.', el.outerHTML);
  }
  var defaultTextType = this.schema.getDefaultTextType();
  var defaultConverter = this._defaultBlockConverter;
  if (!defaultConverter) {
    throw new Error('Could not find converter for default type ', defaultTextType)
  }
  var node = this._createNode(el, defaultTextType);
  this.state.pushContext(el.tagName, converter);
  node = defaultConverter.import(el, node, converter) || node;
  this.state.popContext();
  return node
};

DOMImporter.prototype._defaultElementMatcher = function _defaultElementMatcher (el) {
  return el.is(this.tagName)
};

// Internal function for parsing annotated text
// --------------------------------------------
//
DOMImporter.prototype._annotatedText = function _annotatedText (iterator) {
    var this$1 = this;

  var state = this.state;
  var context = last$2(state.stack);
  if (!context) {
    throw new Error('Illegal state: context is null.')
  }
  while(iterator.hasNext()) {
    var el = iterator.next();
    var text = "";
    // Plain text nodes...
    if (el.isTextNode()) {
      text = this$1._prepareText(state, el.textContent);
      if (text.length) {
        // Note: text is not merged into the reentrant state
        // so that we are able to return for this reentrant call
        context.text = context.text.concat(text);
        context.offset += text.length;
      }
    } else if (el.isCommentNode()) {
      // skip comment nodes
      continue
    } else if (el.isElementNode()) {
      var inlineTypeConverter = this$1._getConverterForElement(el, 'inline');
      // if no inline converter is found we just traverse deeper
      if (!inlineTypeConverter) {
        if (!this$1.IGNORE_DEFAULT_WARNINGS) {
          console.warn('Unsupported inline element. We will not create an annotation for it, but process its children to extract annotated text.', el.outerHTML);
        }
        // Note: this will store the result into the current context
        this$1.annotatedText(el);
        continue
      }
      // reentrant: we delegate the conversion to the inline node class
      // it will either call us back (this.annotatedText) or give us a finished
      // node instantly (self-managed)
      var startOffset = context.offset;
      var inlineType = inlineTypeConverter.type;
      var inlineNode = this$1._createNode(el, inlineType);
      if (inlineTypeConverter.import) {
        // push a new context so we can deal with reentrant calls
        state.stack.push({
          path: context.path,
          offset: startOffset,
          text: ""
        });
        state.pushContext(el.tagName, inlineTypeConverter);
        inlineNode = inlineTypeConverter.import(el, inlineNode, this$1) || inlineNode;
        state.popContext();

        var NodeClass = this$1.schema.getNodeClass(inlineType);
        // inline nodes are attached to an invisible character
        if (NodeClass.isInline) {
          this$1.customText("\u200B");
        } else {
          // We call this to descent into the element
          // which could be 'forgotten' otherwise.
          // TODO: what if the converter has processed the element already?
          this$1.annotatedText(el);
        }
        // ... and transfer the result into the current context
        var result = state.stack.pop();
        context.offset = result.offset;
        context.text = context.text.concat(result.text);
      } else {
        this$1.annotatedText(el);
      }
      // in the mean time the offset will probably have changed to reentrant calls
      var endOffset = context.offset;
      inlineNode.start = {
        path: context.path.slice(0),
        offset: startOffset
      };
      inlineNode.end = {
        offset: endOffset
      };
      state.inlineNodes.push(inlineNode);
    } else {
      console.warn('Unknown element type. Taking plain text.', el.outerHTML);
      text = this$1._prepareText(state, el.textContent);
      context.text = context.text.concat(text);
      context.offset += text.length;
    }
  }
  // return the plain text collected during this reentrant call
  return context.text
};

DOMImporter.prototype._getConverterForElement = function _getConverterForElement (el, mode) {
    var this$1 = this;

  var converters;
  if (mode === "block") {
    if (!el.tagName) { return null }
    converters = this._blockConverters;
  } else if (mode === "inline") {
    converters = this._propertyAnnotationConverters;
  } else {
    converters = this._allConverters;
  }
  var converter = null;
  for (var i = 0; i < converters.length; i++) {
    if (this$1._converterCanBeApplied(converters[i], el)) {
      converter = converters[i];
      break
    }
  }
  return converter
};

DOMImporter.prototype._converterCanBeApplied = function _converterCanBeApplied (converter, el) {
  return converter.matchElement(el, converter)
};

DOMImporter.prototype._createElement = function _createElement (tagName) {
  return this._el.createElement(tagName)
};

/**
  Wraps the remaining (inline) elements of a node iterator into a default
  block node.

  @private
  @param {model/DOMImporter.ChildIterator} childIterator
  @returns {model/DocumentNode}
 */
DOMImporter.prototype._wrapInlineElementsIntoBlockElement = function _wrapInlineElementsIntoBlockElement (childIterator) {
    var this$1 = this;

  var wrapper = this._createElement('div');
  while(childIterator.hasNext()) {
    var el = childIterator.next();
    // if there is a block node we finish this wrapper
    var blockTypeConverter = this$1._getConverterForElement(el, 'block');
    if (blockTypeConverter) {
      childIterator.back();
      break
    }
    wrapper.append(el.clone());
  }
  var node = this.defaultConverter(wrapper, this);
  if (node) {
    if (!node.type) {
      throw new Error('Contract: DOMImporter.defaultConverter() must return a node with type.')
    }
    this._createAndShow(node);
  }
  return node
};

/**
  Converts an element into a default block level node.

  @private
  @param {ui/DOMElement} el
  @returns {model/DocumentNode}
 */
DOMImporter.prototype._createDefaultBlockElement = function _createDefaultBlockElement (el) {
  var node = this.defaultConverter(el, this);
  if (node) {
    if (!node.type) {
      throw new Error('Contract: Html.defaultConverter() must return a node with type.', el.outerHTML)
    }
    node.id = node.id || this.defaultId(el, node.type);
    this._createAndShow(node);
  }
};

// TODO: this needs to be tested and documented
DOMImporter.prototype._prepareText = function _prepareText (state, text) {
  if (state.preserveWhitespace) {
    return text
  }
  var repl = SPACE;
  // replace multiple tabs and new-lines by one space
  text = text.replace(TABS_OR_NL, '');
  // TODO: the last char handling is only necessary for for nested calls
  // i.e., when processing the content of an annotation, for instance
  // we need to work out how we could control this with an inner state
  if (state.lastChar === SPACE) {
    text = text.replace(WS_LEFT_ALL, repl);
  } else {
    text = text.replace(WS_LEFT, repl);
  }
  text = text.replace(WS_RIGHT, repl);
  // EXPERIMENTAL: also remove white-space within
  // this happens if somebody treats the text more like it would be done in Markdown
  // i.e. introducing line-breaks
  if (this.config.REMOVE_INNER_WS || state.removeInnerWhitespace) {
    text = text.replace(WS_ALL, SPACE);
  }
  state.lastChar = text[text.length-1] || state.lastChar;
  return text
};

/**
  Removes any leading and trailing whitespaces from the content
  within the given element.
  Attention: this is not yet implemented fully. Atm, trimming is only done
  on the first and last text node (if they exist).

  @private
  @param {util/jQuery} $el
  @returns {util/jQuery} an element with trimmed text
 */
DOMImporter.prototype._trimTextContent = function _trimTextContent (el) {
  var nodes = el.getChildNodes();
  var firstNode = nodes[0];
  var lastNode = last$2(nodes);
  var text, trimmed;
    // trim the first and last text
  if (firstNode && firstNode.isTextNode()) {
    text = firstNode.textContent;
    trimmed = this._trimLeft(text);
    firstNode.textContent = trimmed;
  }
  if (lastNode && lastNode.isTextNode()) {
    text = lastNode.textContent;
    trimmed = this._trimRight(text);
    lastNode.textContent = trimmed;
  }
  return el
};

DOMImporter.prototype._trimLeft = function _trimLeft (text) {
  return text.replace(WS_LEFT, "")
};

DOMImporter.prototype._trimRight = function _trimRight (text) {
  return text.replace(WS_RIGHT, "")
};

var DOMImporterState = function DOMImporterState() {
  this.reset();
};

DOMImporterState.prototype.reset = function reset () {
  this.preserveWhitespace = false;
  this.nodes = [];
  this.inlineNodes = [];
  this.containerId = null;
  this.container = [];
  this.ids = {};
  // stack for reentrant calls into _convertElement()
  this.contexts = [];
  // stack for reentrant calls into _annotatedText()
  this.stack = [];
  this.lastChar = "";
  this.skipTypes = {};
  this.ignoreAnnotations = false;
  this.isConverting = false;

  // experimental: trying to generate simpler ids during import
  // this.uuid = uuid
  this.uuid = createCountingIdGenerator();
};

DOMImporterState.prototype.pushContext = function pushContext (tagName, converter) {
  this.contexts.push({ tagName: tagName, converter: converter});
};

DOMImporterState.prototype.popContext = function popContext () {
  return this.contexts.pop()
};

DOMImporterState.prototype.getCurrentContext = function getCurrentContext () {
  return last$2(this.contexts)
};

DOMImporter.State = DOMImporterState;

function _createNodes(doc, nodes) {
  nodes.forEach(function (node) {
    // NOTE: if your Document implementation adds default nodes in the constructor
    // and you have exported the node, we need to remove the default version first
    // TODO: alternatively we could just update the existing one. For now we remove the old one.
    var _node = doc.get(node.id);
    if (_node && _node !== node) {
      // console.warn('Node with same it already exists.', node)
      doc.delete(node.id);
    }
    if (node.document !== doc) {
      doc.create(node);
    }
  });
}

/*
  A FileProxy represents a proxy from a FileNode to the real resource.
  As real resources may need to be fetched, the FileProxy typically has
  multiple internal states.
*/
var FileProxy = function FileProxy(fileNode, context) {
  this.fileNode = fileNode;
  this.context = context;
  fileNode.setProxy(this);
};

var prototypeAccessors$8 = { id: {} };

prototypeAccessors$8.id.get = function () {
  return this.fileNode.id
};

/*
  Fires a property update on the file node
*/
FileProxy.prototype.triggerUpdate = function triggerUpdate () {
  var fileId = this.fileNode.id;
  this.context.editorSession.transaction(function (tx) {
    tx.set([fileId, '__changed__'], '');
  }, { history: false });
};

FileProxy.prototype.getUrl = function getUrl () {
  return ''
};

FileProxy.prototype.sync = function sync () {
  return Promise.reject(new Error('sync method not implemented'))
};

Object.defineProperties( FileProxy.prototype, prototypeAccessors$8 );

FileProxy.match = function(fileNode, context) { // eslint-disable-line
  return false
};

/*
  Base class for custom HTML exporters. If you want to use XML as your
  exchange format see {@link model/XMLExporter}.
*/

var HTMLExporter = (function (DOMExporter$$1) {
  function HTMLExporter(config, context) {
    DOMExporter$$1.call(this, _defaultConfig(config), context);
  }

  if ( DOMExporter$$1 ) HTMLExporter.__proto__ = DOMExporter$$1;
  HTMLExporter.prototype = Object.create( DOMExporter$$1 && DOMExporter$$1.prototype );
  HTMLExporter.prototype.constructor = HTMLExporter;

  HTMLExporter.prototype.exportDocument = function exportDocument (doc) {
    var htmlEl = DefaultDOMElement.parseHTML('<html><head></head><body></body></html>');
    return this.convertDocument(doc, htmlEl)
  };

  HTMLExporter.prototype.getDefaultBlockConverter = function getDefaultBlockConverter () {
    return defaultBlockConverter // eslint-disable-line no-use-before-define
  };

  HTMLExporter.prototype.getDefaultPropertyAnnotationConverter = function getDefaultPropertyAnnotationConverter () {
    return defaultAnnotationConverter // eslint-disable-line no-use-before-define
  };

  return HTMLExporter;
}(DOMExporter));

function _defaultConfig(config) {
  config = Object.assign({
    idAttribute: 'data-id'
  }, config);
  if (!config.elementFactory) {
    config.elementFactory = DefaultDOMElement.createDocument('html');
  }
  return config
}


var defaultAnnotationConverter = {
  tagName: 'span',
  export: function(node, el) {
    el.tagName = 'span';
    el.attr('data-type', node.type);
    var properties = node.toJSON();
    forEach(properties, function(value, name) {
      if (name === 'id' || name === 'type') { return }
      if (isString(value) || isNumber(value) || isBoolean$2(value)) {
        el.attr('data-'+name, value);
      }
    });
  }
};

var defaultBlockConverter = {
  export: function(node, el, converter) {
    el.attr('data-type', node.type);
    var properties = node.toJSON();
    forEach(properties, function(value, name) {
      if (name === 'id' || name === 'type') {
        return
      }
      var prop = converter.$$('div').attr('property', name);
      if (node.getPropertyType(name) === 'string' && value) {
        prop.append(converter.annotatedText([node.id, name]));
      } else {
        prop.text(value);
      }
      el.append(prop);
    });
  }
};

/*
  Base class for custom HTML importers. If you want to use XML as your
  exchange format see {@link model/XMLImporter}.

  @class
  @abstract
*/
var HTMLImporter = (function (DOMImporter$$1) {
  function HTMLImporter(config) {
    DOMImporter$$1.call(this, Object.assign({ idAttribute: 'data-id' }, config));

    // only used internally for creating wrapper elements
    this._el = DefaultDOMElement.parseHTML('<html></html>');
  }

  if ( DOMImporter$$1 ) HTMLImporter.__proto__ = DOMImporter$$1;
  HTMLImporter.prototype = Object.create( DOMImporter$$1 && DOMImporter$$1.prototype );
  HTMLImporter.prototype.constructor = HTMLImporter;

  HTMLImporter.prototype.importDocument = function importDocument (html) {
    this.reset();
    var parsed = DefaultDOMElement.parseHTML(html);
    // creating all nodes
    this.convertDocument(parsed);
    this.generateDocument();
    return this.state.doc
  };

  /**
    Orchestrates conversion of a whole document.

    This method should be overridden by custom importers to reflect the
    structure of a custom HTML document or fragment, and to control where
    things go to within the document.

    @abstract
    @param {ui/DOMElement} documentEl the document element.

    @example

    When a fragment `<h1>Foo</h1><p></Bar</p>` is imported the implementation
    looks like this.

    ```js
      convertDocument(els) {
        this.convertContainer(els, 'body')
      }
    ```

    If a full document `<html><body><p>A</p><p>B</p></body></html>` is imported
    you get the `<html>` element instead of a node array.

    ```js
      convertDocument(htmlEl) {
        var bodyEl = htmlEl.find('body')
        this.convertContainer(bodyEl.children, 'body')
      }
    ```
  */
  HTMLImporter.prototype.convertDocument = function convertDocument (documentEl) { // eslint-disable-line
    throw new Error('This method is abstract')
  };

  return HTMLImporter;
}(DOMImporter));

var InlineNode = (function (PropertyAnnotation$$1) {
	function InlineNode () {
		PropertyAnnotation$$1.apply(this, arguments);
	}if ( PropertyAnnotation$$1 ) InlineNode.__proto__ = PropertyAnnotation$$1;
	InlineNode.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
	InlineNode.prototype.constructor = InlineNode;

	

	return InlineNode;
}(PropertyAnnotation));

InlineNode.prototype._isInlineNode = true;

InlineNode.isInline = true;

var Marker = (function (PropertyAnnotation$$1) {
  function Marker () {
    PropertyAnnotation$$1.apply(this, arguments);
  }

  if ( PropertyAnnotation$$1 ) Marker.__proto__ = PropertyAnnotation$$1;
  Marker.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
  Marker.prototype.constructor = Marker;

  Marker.prototype.invalidate = function invalidate () {};
  Marker.prototype.remove = function remove () {
    this.getDocument().data.delete(this.id);
  };

  // TODO: we should use the Coordinate comparison API here
  Marker.prototype.containsSelection = function containsSelection (sel) {
    if (sel.isNull()) { return false; }
    if (sel.isPropertySelection()) {
      return (isArrayEqual(this.start.path, sel.start.path) &&
        this.start.offset <= sel.start.offset &&
        this.end.offset >= sel.end.offset)
    } else {
      console.warn('Marker.contains() does not support other selection types.');
    }
  };

  return Marker;
}(PropertyAnnotation));

// while having the same interface, Markers should still be treated differently, e.g. not go into the AnnotationIndex
Marker.prototype._isPropertyAnnotation = false;
Marker.prototype._isMarker = true;

/**
  A base class for all text-ish nodes, such as Paragraphs, Headings,
  Prerendered, etc.
*/
var TextNode = (function (DocumentNode$$1) {
  function TextNode () {
    DocumentNode$$1.apply(this, arguments);
  }

  if ( DocumentNode$$1 ) TextNode.__proto__ = DocumentNode$$1;
  TextNode.prototype = Object.create( DocumentNode$$1 && DocumentNode$$1.prototype );
  TextNode.prototype.constructor = TextNode;

  TextNode.prototype.getTextPath = function getTextPath () {
    // TODO: deprecate this
    // console.warn('DEPRECATED: use node.getPath()')
    return this.getPath()
  };

  TextNode.prototype.getPath = function getPath () {
    return [this.id, 'content']
  };

  TextNode.prototype.getText = function getText () {
    return this.content
  };

  TextNode.prototype.isEmpty = function isEmpty () {
    return !this.content
  };

  TextNode.prototype.getLength = function getLength () {
    return this.content.length
  };

  return TextNode;
}(DocumentNode));

TextNode.isText = true;

TextNode.schema = {
  type: "text",
  content: "text",
  direction: { type: "string", optional: true }
};

var TextBlock = (function (TextNode$$1) {
	function TextBlock () {
		TextNode$$1.apply(this, arguments);
	}if ( TextNode$$1 ) TextBlock.__proto__ = TextNode$$1;
	TextBlock.prototype = Object.create( TextNode$$1 && TextNode$$1.prototype );
	TextBlock.prototype.constructor = TextBlock;

	

	return TextBlock;
}(TextNode));

TextBlock.isBlock = true;

/*
  @example

  ```js
  $$(Button, {
    name: 'add-ref' // used to resolve icon and label
    label: 'Add reference' // optional if you want to set the label string explicity
  })
  ```
*/
var Button = (function (Component$$1) {
  function Button () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Button.__proto__ = Component$$1;
  Button.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Button.prototype.constructor = Button;

  Button.prototype.render = function render ($$) {
    var el = $$('button')
      .addClass('sc-button');

    if (this.props.icon) {
      el.append(this.renderIcon($$));
    }
    if (this.props.label) {
      el.append(this.renderLabel($$));
    }
    if (this.props.active) {
      el.addClass('sm-active');
    }
    if (this.props.style) {
      el.addClass('sm-style-'+this.props.style);
    }
    if (this.props.disabled) {
      // make button inaccessible
      el.attr('tabindex', -1)
        .attr('disabled', true);
    } else {
      // make button accessible for tab-navigation
      el.attr('tabindex', 1);
    }

    // Ability to inject additional elements (should be avoided!)
    el.append(this.props.children);
    return el
  };

  Button.prototype.renderIcon = function renderIcon ($$) {
    var iconEl = this.context.iconProvider.renderIcon($$, this.props.icon);
    return iconEl
  };

  Button.prototype.renderLabel = function renderLabel ($$) {
    return $$('div').addClass('se-label').append(
      this.getLabel(this.props.label)
    )
  };

  Button.prototype.renderHint = function renderHint ($$) {
    return $$('div').addClass('se-hint').append(
      this.getLabel(this.props.hint+'-hint')
    )
  };

  Button.prototype.getLabel = function getLabel (name) {
    var labelProvider = this.context.labelProvider;
    return labelProvider.getLabel(name)
  };

  return Button;
}(Component));

var ButtonPackage = {
  name: 'button',
  configure: function(config) {
    config.addComponent('button', Button);
  }
};

var Toolbox = (function (Component$$1) {
  function Toolbox () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Toolbox.__proto__ = Component$$1;
  Toolbox.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Toolbox.prototype.constructor = Toolbox;

  Toolbox.prototype.getInitialState = function getInitialState () {
    return {
      activeToolGroups: this.getActiveToolGroups()
    }
  };

  Toolbox.prototype.shouldRerender = function shouldRerender (newProps, newState) {
    // poor-man's immutable style
    var hasChanged = !isEqual(this.props, newProps) || !isEqual(this.state.activeToolGroups, newState.activeToolGroups);

    if (!hasChanged) {
      this.hide();
      return false
    }
    return true
  };

  Toolbox.prototype.didMount = function didMount () {
    // rerender the context menu after anything else has been updated
    this.context.editorSession.onRender(this._onCommandStatesChanged, this);
  };

  Toolbox.prototype.dispose = function dispose () {
    this.context.editorSession.off(this);
  };

  Toolbox.prototype._onCommandStatesChanged = function _onCommandStatesChanged (editorSession) {
    if (editorSession.hasChanged('commandStates')) {
      this.setState({
        activeToolGroups: this.getActiveToolGroups()
      });
    }
  };

  /*
    Returns A map of tooltargets, the value being an array of tool objects
    containing Class and toolProps for rendering
  */
  Toolbox.prototype.getActiveToolGroups = function getActiveToolGroups () {
    var this$1 = this;

    this._hasActiveTools = false;

    var toolGroups = this.context.toolGroups;
    var activeToolGroupNames = this.getActiveToolGroupNames();
    var activeToolGroups = new Map();

    activeToolGroupNames.forEach(function (toolGroupName) {
      var toolGroup = toolGroups.get(toolGroupName);
      if (!toolGroup) { return }
      var tools = toolGroup.tools;
      var activeTools = this$1.getActiveTools(tools, toolGroupName);
      activeToolGroups.set(toolGroupName, {
        name: toolGroupName,
        Class: toolGroup.Class,
        tools: activeTools
      });
    });
    return activeToolGroups
  };

  /*
    For a given Map of tools and a toolGroupName determine
    a set of activeTools, based on the current commandStates
  */
  Toolbox.prototype.getActiveTools = function getActiveTools (tools, toolGroupName) {
    var this$1 = this;
 // eslint-disable-line
    var activeTools = new Map();
    var commandStates = this._getCommandStates();

    tools.forEach(function (tool, toolName) {
      if (!commandStates[toolName]) {
        throw new Error(("Could not find commandState for " + toolName))
      }

      var toolProps = Object.assign({}, commandStates[toolName], {
        name: toolName,
        label: toolName,
        // style hint only interprerted by generic Tool class
        style: this$1.getToolStyle(toolName)
      });

      if (!toolProps.disabled || this$1.showDisabled()) {
        activeTools.set(tool.name, {
          name: tool.name,
          Class: tool.Class,
          toolProps: toolProps
        });
        this$1._hasActiveTools = true;
      }
    });

    return activeTools
  };

  Toolbox.prototype.hasActiveTools = function hasActiveTools () {
    return Boolean(this._hasActiveTools)
  };

  Toolbox.prototype.getActiveToolGroupNames = function getActiveToolGroupNames () {
    throw new Error('Abstract method')
  };

  Toolbox.prototype.showDisabled = function showDisabled () {
    return false
  };

  Toolbox.prototype.hide = function hide () {
    // Optional hook for hiding the toolbox component
  };

  /*
    Override if you just want to use a different style
  */
  Toolbox.prototype.getToolStyle = function getToolStyle () {
    throw new Error('Abstract method')
  };

  Toolbox.prototype._getCommandStates = function _getCommandStates () {
    return this.context.commandManager.getCommandStates()
  };

  return Toolbox;
}(Component));

var ContextMenu = (function (Toolbox$$1) {
  function ContextMenu () {
    Toolbox$$1.apply(this, arguments);
  }

  if ( Toolbox$$1 ) ContextMenu.__proto__ = Toolbox$$1;
  ContextMenu.prototype = Object.create( Toolbox$$1 && Toolbox$$1.prototype );
  ContextMenu.prototype.constructor = ContextMenu;

  ContextMenu.prototype.didMount = function didMount () {
    Toolbox$$1.prototype.didMount.call(this);
    if (!this.context.scrollPane) {
      throw new Error('Requires a scrollPane context')
    }
    this.context.scrollPane.on('context-menu:opened', this._onContextMenuOpened, this);
  };

  ContextMenu.prototype.dispose = function dispose () {
    Toolbox$$1.prototype.dispose.call(this);
    this.context.scrollPane.off(this);
  };

  /*
    Override with custom rendering
  */
  ContextMenu.prototype.render = function render ($$) {
    var this$1 = this;

    var el = $$('div').addClass('sc-context-menu sm-hidden');
    var activeToolGroups = this.state.activeToolGroups;

    activeToolGroups.forEach(function (toolGroup) {
      var toolGroupProps = Object.assign({}, toolGroup, {
        toolStyle: this$1.getToolStyle(),
        showLabels: true,
        // showHints: true
      });

      if (toolGroupProps.tools.size > 0) {
        var toolGroupEl = $$(toolGroup.Class, toolGroupProps);
        el.append(toolGroupEl);
      }
    });
    return el
  };

  ContextMenu.prototype.getActiveToolGroupNames = function getActiveToolGroupNames () {
    return ['context-menu-primary', 'context-menu-document']
  };

  ContextMenu.prototype.showDisabled = function showDisabled () {
    return true
  };

  /*
    Override if you just want to use a different style
  */
  ContextMenu.prototype.getToolStyle = function getToolStyle () {
    return 'plain-dark'
  };

  ContextMenu.prototype.hide = function hide () {
    this.el.addClass('sm-hidden');
  };

  /*
    Positions the content menu relative to the scrollPane
  */
  ContextMenu.prototype._onContextMenuOpened = function _onContextMenuOpened (hints) {
    var mouseBounds = hints.mouseBounds;
    this.el.removeClass('sm-hidden');
    var contextMenuWidth = this.el.htmlProp('offsetWidth');

    // By default, context menu are aligned left bottom to the mouse coordinate clicked
    this.el.css('top', mouseBounds.top);
    var leftPos = mouseBounds.left;
    // Must not exceed left bound
    leftPos = Math.max(leftPos, 0);
    // Must not exceed right bound
    var maxLeftPos = mouseBounds.left + mouseBounds.right - contextMenuWidth;
    leftPos = Math.min(leftPos, maxLeftPos);
    this.el.css('left', leftPos);
  };

  return ContextMenu;
}(Toolbox));

var ContextMenuPackage = {
  name: 'context-menu',
  configure: function(config) {
    config.addComponent('context-menu', ContextMenu);
  }
};

/*
  Simple component for realizing grid layouts
*/
var Grid = (function (Component$$1) {
  function Grid () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Grid.__proto__ = Component$$1;
  Grid.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Grid.prototype.constructor = Grid;

  Grid.prototype.render = function render ($$) {
    var el = $$('div').addClass('sc-grid');
    if (this.props.mobile) {
      el.addClass('sm-mobile');
    }
    el.append(this.props.children);
    return el
  };

  return Grid;
}(Component));

/*
  A grid row
*/
var Row = (function (Component$$1) {
  function Row () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Row.__proto__ = Component$$1;
  Row.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Row.prototype.constructor = Row;

  Row.prototype.render = function render ($$) {
    var el = $$('div').addClass('se-row');
    el.append(this.props.children);
    return el
  };

  return Row;
}(Component));

/*
  A grid cell
*/
var Cell = (function (Component$$1) {
  function Cell () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Cell.__proto__ = Component$$1;
  Cell.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Cell.prototype.constructor = Cell;

  Cell.prototype.render = function render ($$) {
    var el = $$('div').addClass('se-cell');
    el.addClass('sm-column-'+this.props.columns);
    el.append(this.props.children);
    return el
  };

  return Cell;
}(Component));

Grid.Row = Row;
Grid.Cell = Cell;

var GridPackage = {
  name: 'grid',
  configure: function(config) {
    config.addComponent('grid', Grid);
  }
};

/*
  A default implementation to render the content for the overlay (aka popup) tools.
*/
var Gutter = (function (Toolbox$$1) {
  function Gutter () {
    Toolbox$$1.apply(this, arguments);
  }

  if ( Toolbox$$1 ) Gutter.__proto__ = Toolbox$$1;
  Gutter.prototype = Object.create( Toolbox$$1 && Toolbox$$1.prototype );
  Gutter.prototype.constructor = Gutter;

  Gutter.prototype.render = function render ($$) {
    var this$1 = this;

    var el = $$('div').addClass(this.getClassNames());
    el.addClass('sm-hidden');
    el.addClass('sm-theme-'+this.getTheme());
    var activeToolGroups = this.state.activeToolGroups;
    var activeToolsEl = $$('div').addClass('se-active-tools');

    activeToolGroups.forEach(function (toolGroup) {
      var toolGroupProps = Object.assign({}, toolGroup, {
        toolStyle: this$1.getToolStyle(),
        showIcons: true
      });
      activeToolsEl.append(
        $$(toolGroup.Class, toolGroupProps)
      );
    });

    el.append(activeToolsEl);
    return el
  };

  /*
    Override if you just want to use a different style
  */
  Gutter.prototype.getToolStyle = function getToolStyle () {
    return 'outline-dark'
  };

  Gutter.prototype.show = function show (hints) {
    this.el.removeClass('sm-hidden');
    this._position(hints);
  };

  Gutter.prototype.hide = function hide () {
    this.el.addClass('sm-hidden');
  };

  Gutter.prototype._position = function _position (hints) {
    if (hints) {
      // By default, gutter is centered (y-axis) and left of the scrollPane content (x-axis)
      this.el.css('top', hints.rectangle.top + hints.rectangle.height - hints.rectangle.height / 2);
      this.el.css('left', 0);
    }
  };

  Gutter.prototype.getClassNames = function getClassNames () {
    return 'sc-gutter'
  };

  Gutter.prototype.getTheme = function getTheme () {
    return 'dark'
  };

  Gutter.prototype.getActiveToolGroupNames = function getActiveToolGroupNames () {
    return ['gutter']
  };

  return Gutter;
}(Toolbox));

var GutterPackage = {
  name: 'gutter',
  configure: function(config) {
    config.addToolGroup('gutter');
    config.addComponent('gutter', Gutter);
  }
};

var Input = (function (Component$$1) {
  function Input () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Input.__proto__ = Component$$1;
  Input.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Input.prototype.constructor = Input;

  Input.prototype._onChange = function _onChange () {
    var editorSession = this.context.editorSession;
    var path = this.props.path;
    var newVal = this.el.val();

    editorSession.transaction(function(tx) {
      tx.set(path, newVal);
    });
  };

  Input.prototype.render = function render ($$) {
    var val;

    if (this.props.path) {
      var editorSession = this.context.editorSession;
      var doc = editorSession.getDocument();
      val = doc.get(this.props.path);
    } else {
      val = this.props.value;
    }

    var el = $$('input').attr({
      value: val,
      type: this.props.type,
      placeholder: this.props.placeholder
    })
    .addClass('sc-input');

    if (this.props.path) {
      el.on('change', this._onChange);
    }

    if (this.props.centered) {
      el.addClass('sm-centered');
    }

    return el
  };

  return Input;
}(Component));

var InputPackage = {
  name: 'input',
  configure: function(config) {
    config.addComponent('input', Input);
  }
};

/**
  Layout component for simple layout tasks, without having to write CSS

  @class
  @component

  @prop {String} width 'small', 'medium', 'large' and 'full'
  @prop {String} [textAlign] 'center', 'left' or 'right'
  @prop {String} [noPadding] No padding around layout, will fill the whole space

  @example

  ```js
  var form = $$(Layout, {
    width: 'large',
    textAlign: 'center'
  });
  ```
*/
var Layout = (function (Component$$1) {
  function Layout () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Layout.__proto__ = Component$$1;
  Layout.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Layout.prototype.constructor = Layout;

  Layout.prototype.render = function render ($$) {
    var el = $$('div').addClass('sc-layout');
    el.addClass('sm-width-'+this.props.width);
    if (this.props.textAlign) {
      el.addClass('sm-text-align-'+this.props.textAlign);
    }

    if (this.props.noPadding) {
      el.addClass('sm-no-padding');
    }

    el.append(this.props.children);
    return el
  };

  return Layout;
}(Component));

var LayoutPackage = {
  name: 'layout',
  configure: function(config) {
    config.addComponent('layout', Layout);
  }
};

/**
  Modal dialog component

  @class
  @component

  @prop {String} width 'small', 'medium', 'large' and 'full'

  @example

  ```js
  var form = $$(Modal, {
    width: 'medium',
    textAlign: 'center'
  });
  ```
*/
var Modal = (function (Component$$1) {
  function Modal () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Modal.__proto__ = Component$$1;
  Modal.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Modal.prototype.constructor = Modal;

  Modal.prototype.render = function render ($$) {
    var el = $$('div').addClass('sc-modal');

    // TODO: don't think that this is good enough. Right the modal is closed by any unhandled click.
    // Need to be discussed.
    el.on('click', this._closeModal);

    if (this.props.width) {
      el.addClass('sm-width-'+this.props.width);
    }

    el.append(
      $$('div').addClass('se-body').append(
        this.props.children
      )
    );
    return el
  };

  Modal.prototype._closeModal = function _closeModal (e) {
    var closeSurfaceClick = e.target.classList.contains('sc-modal');
    if (closeSurfaceClick) {
      this.send('closeModal');
    }
  };

  return Modal;
}(Component));

var ModalPackage = {
  name: 'modal',
  configure: function(config) {
    config.addComponent('modal', Modal);
  }
};

/*
  A default implementation to render the content for the overlay (aka popup) tools.
*/
var Overlay = (function (Toolbox$$1) {
  function Overlay () {
    Toolbox$$1.apply(this, arguments);
  }

  if ( Toolbox$$1 ) Overlay.__proto__ = Toolbox$$1;
  Overlay.prototype = Object.create( Toolbox$$1 && Toolbox$$1.prototype );
  Overlay.prototype.constructor = Overlay;

  Overlay.prototype.didMount = function didMount () {
    Toolbox$$1.prototype.didMount.call(this);
    if (!this.context.scrollPane) {
      throw new Error('Requires scrollPane context')
    }
    this.context.scrollPane.on('selection:positioned', this._onSelectionPositioned, this);
  };

  Overlay.prototype.dispose = function dispose () {
    Toolbox$$1.prototype.dispose.call(this);
    this.context.scrollPane.off(this);
  };

  Overlay.prototype.render = function render ($$) {
    var this$1 = this;

    var el = $$('div').addClass(this.getClassNames());
    el.addClass('sm-hidden');
    el.addClass('sm-theme-'+this.getTheme());
    var activeToolGroups = this.state.activeToolGroups;
    var activeToolsEl = $$('div').addClass('se-active-tools');

    activeToolGroups.forEach(function (toolGroup) {
      var toolGroupProps = Object.assign({}, toolGroup, {
        toolStyle: this$1.getToolStyle(),
        showIcons: true
      });
      activeToolsEl.append(
        $$(toolGroup.Class, toolGroupProps)
      );
    });

    el.append(activeToolsEl);
    return el
  };

  /*
    Override if you just want to use a different style
  */
  Overlay.prototype.getToolStyle = function getToolStyle () {
    return 'plain-dark'
  };

  Overlay.prototype.show = function show (hints) {
    this.el.removeClass('sm-hidden');
    this._position(hints);
  };

  Overlay.prototype.hide = function hide () {
    this.el.addClass('sm-hidden');
  };

  Overlay.prototype._onSelectionPositioned = function _onSelectionPositioned (hints) {
    if (this.hasActiveTools()) {
      this.el.removeClass('sm-hidden');
      var overlayWidth = this.el.htmlProp('offsetWidth');
      var selRect = hints.selectionRect;
      var selectionMaxWidth = selRect.width;
      // By default, Overlays are aligned center/bottom to the selection
      this.el.css('top', selRect.top + selRect.height);
      var leftPos = selRect.left + selectionMaxWidth/2 - overlayWidth/2;
      // Must not exceed left bound
      leftPos = Math.max(leftPos, 0);
      // Must not exceed right bound
      var maxLeftPos = selRect.left + selectionMaxWidth + selRect.right - overlayWidth;
      leftPos = Math.min(leftPos, maxLeftPos);
      this.el.css('left', leftPos);
    } else {
      this.el.addClass('sm-hidden');
    }
  };

  Overlay.prototype.getClassNames = function getClassNames () {
    return 'sc-overlay'
  };

  Overlay.prototype.getTheme = function getTheme () {
    return 'dark'
  };

  Overlay.prototype.getActiveToolGroupNames = function getActiveToolGroupNames () {
    return this.props.toolGroups || ['overlay']
  };

  return Overlay;
}(Toolbox));

var OverlayPackage = {
  name: 'overlay',
  configure: function(config) {
    config.addToolGroup('overlay');
    config.addComponent('overlay', Overlay);
  }
};

/**
  Get bounding rectangle relative to a given parent element. Allows multiple
  elements being passed (we need this for selections that consist of multiple
  selection fragments). Takes a relative parent element that is used as a
  reference point, instead of the browser's viewport.

  @param {Array} els elements to compute the bounding rectangle for
  @param {DOMElement} containerEl relative parent used as a reference point
  @return {object} rectangle description with left, top, right, bottom, width and height
*/
function getRelativeBoundingRect(els, containerEl) {
  if (els.length === undefined) {
    els = [els];
  }
  var elRects = map(els, function(el) {
    return _getBoundingOffsetsRect(el, containerEl)
  });

  var elsRect = _getBoundingRect(elRects);
  var containerElRect = containerEl.getBoundingClientRect();
  return {
    left: elsRect.left,
    top: elsRect.top,
    right: containerElRect.width - elsRect.left - elsRect.width,
    bottom: containerElRect.height - elsRect.top - elsRect.height,
    width: elsRect.width,
    height: elsRect.height
  }
}

/*
  Calculate a bounding rectangle for a set of rectangles.

  Note: Here, `bounds.right` and `bounds.bottom` are relative to
  the left top of the viewport.
*/
function _getBoundingRect(rects) {
  var bounds = {
    left: Number.POSITIVE_INFINITY,
    top: Number.POSITIVE_INFINITY,
    right: Number.NEGATIVE_INFINITY,
    bottom: Number.NEGATIVE_INFINITY,
    width: Number.NaN,
    height: Number.NaN
  };

  forEach(rects, function(rect) {
    if (rect.left < bounds.left) {
      bounds.left = rect.left;
    }
    if (rect.top < bounds.top) {
      bounds.top = rect.top;
    }
    if (rect.left + rect.width > bounds.right) {
      bounds.right = rect.left + rect.width;
    }
    if (rect.top + rect.height > bounds.bottom) {
      bounds.bottom = rect.top + rect.height;
    }
  });
  bounds.width = bounds.right - bounds.left;
  bounds.height = bounds.bottom - bounds.top;
  return bounds
}

/*
  Calculate the bounding rect of a single element relative to a parent.

  The rectangle dimensions are calculated as the union of the given elements
  clientRects. A selection fragment, for example, may appear as a multi-line span
  element that consists of a single client rect per line of text in variable widths.
*/
function _getBoundingOffsetsRect(el, relativeParentEl) {
  var relativeParentElRect = relativeParentEl.getBoundingClientRect();
  var elRect = _getBoundingRect(el.getClientRects());

  var left = elRect.left - relativeParentElRect.left;
  var top = elRect.top - relativeParentElRect.top;
  return {
    left: left,
    top: top,
    right: relativeParentElRect.width - left - elRect.width,
    bottom: relativeParentElRect.height - top - elRect.height,
    width: elRect.width,
    height: elRect.height
  }
}

var Dropzones = (function (Component$$1) {
  function Dropzones () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Dropzones.__proto__ = Component$$1;
  Dropzones.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Dropzones.prototype.constructor = Dropzones;

  Dropzones.prototype.didMount = function didMount () {
    this.context.dragManager.on('drag:started', this.onDragStarted, this);
    this.context.dragManager.on('drag:finished', this.onDragFinished, this);
  };

  Dropzones.prototype.render = function render ($$) {
    var this$1 = this;

    var el = $$('div').addClass('sc-dropzones');

    if (this.state.dropzones) {
      el.on('dragenter', this.onDrag)
        .on('dragover', this.onDrag);

      // Dropzones are scoped by surfaceId
      forEach(this.state.dropzones, function (dropzones, surfaceId) {
        dropzones.forEach(function (dropzone, index) {
          var dropType = dropzone.type;
          var dropzoneEl;
          if (dropType === 'place') {
            dropzoneEl = $$('div').addClass('se-dropzone')
              .attr({
                'data-dropzone-index': index,
                'data-dropzone-surface': surfaceId
              }).append(
                $$('div').addClass('se-drop-teaser').css({
                  top: dropzone.teaserPos
                })
              );
          } else if (dropType === 'custom') {
            dropzoneEl = $$('div').addClass('se-custom-dropzone').attr({
              'data-dropzone-index': index,
              'data-dropzone-surface': surfaceId
            }).append(
              // TODO: also provide se-custom-drop-teaser when custom
              // dropzone is provided
              $$('div').addClass('se-message').append(dropzone.message)
            );
          }
          if (dropzoneEl) {
            var shield = $$('div').addClass('se-drop-shield')
              .on('dragenter', this$1.onDragEnter)
              .on('dragleave', this$1.onDragLeave)
              .on('drop', this$1.onDrop)
              .on('mouseenter', this$1.onDragEnter)
              .on('mouseleave', this$1.onDragLeave)
              .on('mouseup', this$1.onDrop);
            dropzoneEl.append(shield);
            dropzoneEl.css({
              position: 'absolute',
              top: dropzone.top,
              left: dropzone.left,
              width: dropzone.width,
              height: dropzone.height
            });
            el.append(dropzoneEl);
          }
        });
      });
    } else {
      el.addClass('sm-hidden');
    }
    return el
  };

  // triggered by DragManager
  Dropzones.prototype.onDragStarted = function onDragStarted (dragState) {
    var this$1 = this;

    var dropzones = this._computeDropzones(dragState);
    setTimeout(function () {
      this$1.setState({
        dropzones: dropzones
      });
    }, 250);
  };

  // triggered by DragManager
  Dropzones.prototype.onDragFinished = function onDragFinished () {
    this.setState({});
  };

  Dropzones.prototype.onDragEnter = function onDragEnter (e) {
    // console.log('onDragEnter', e.target)
    e.target.parentNode.classList.add('sm-over');
  };

  Dropzones.prototype.onDragLeave = function onDragLeave (e) {
    // console.log('onDragLeave', e.target)
    e.target.parentNode.classList.remove('sm-over');
  };

  // just so that the teaser does not prevent dropping
  Dropzones.prototype.onDrag = function onDrag (e) { // eslint-disable-line
    // console.log('onDrag', e.target)
    e.preventDefault();
  };

  Dropzones.prototype.onDrop = function onDrop (e) {
    // console.log('Dropzones.onDrop()', e.target)
    // HACK: try if this is really necessary
    e.__reserved__ = true;
    e.preventDefault();
    e.stopPropagation();
    var dropzoneIndex = e.target.parentNode.dataset.dropzoneIndex;
    var dropzoneSurface = e.target.parentNode.dataset.dropzoneSurface;
    var dropzone = this.state.dropzones[dropzoneSurface][dropzoneIndex];
    var dropParams = dropzone.dropParams;
    var dropType = dropzone.type;
    // Determine target surface
    var targetSurface = this.context.surfaceManager.getSurface(dropzoneSurface);
    // Original component (e.g. img element)
    var component = dropzone.component;
    var dropzoneComponent = dropzone.dropzoneComponent;
    // HACK: extending the dragState here
    var dragManager = this.context.dragManager;
    dragManager.extendDragState({
      targetSurface: targetSurface,
      dropType: dropType,
      dropParams: dropParams,
      component: component,
      dropzoneComponent: dropzoneComponent
    });
    dragManager._onDragEnd(e);
  };

  /*
    Get bounding rect for a component (relative to scrollPane content element)
  */
  Dropzones.prototype._getBoundingRect = function _getBoundingRect (comp) {
    var scrollPane = comp.context.scrollPane;
    var contentElement = scrollPane.getContentElement().getNativeElement();
    var rect = getRelativeBoundingRect(comp.getNativeElement(), contentElement);
    return rect
  };

  Dropzones.prototype._computeDropzones = function _computeDropzones (dragState) {
    var this$1 = this;

    var scrollPaneName = this.context.scrollPane.getName();
    var surfaces = dragState.scrollPanes[scrollPaneName].surfaces;
    var scopedDropzones = {};

    forEach(surfaces, function (surface) {
      var components = surface.childNodes;

      // e.g. 3 components = 4 drop zones (1 before, 1 after, 2 in-between)
      var numDropzones = components.length + 1;
      var dropzones = [];

      for (var i = 0; i < numDropzones; i++) {
        if (i === 0) {
          // First dropzone
          var firstComp = this$1._getBoundingRect(components[0]);
          dropzones.push({
            type: 'place',
            left: firstComp.left,
            top: firstComp.top,
            width: firstComp.width,
            height: firstComp.height / 2,
            teaserPos: 0,
            dropParams: {
              insertPos: i
            }
          });
        } else if (i === numDropzones - 1) {
          // Last dropzone
          var lastComp = this$1._getBoundingRect(components[i - 1]);
          dropzones.push({
            type: 'place',
            left: lastComp.left,
            top: lastComp.top + lastComp.height / 2,
            width: lastComp.width,
            height: lastComp.height / 2,
            teaserPos: lastComp.height / 2,
            dropParams: {
              insertPos: i
            }
          });
        } else {
          // Drop zone in between two components
          var upperComp = this$1._getBoundingRect(components[i-1]);
          var lowerComp = this$1._getBoundingRect(components[i]);
          var topBound = upperComp.top + upperComp.height / 2;
          var bottomBound = lowerComp.top + lowerComp.height / 2;

          dropzones.push({
            type: 'place',
            left: upperComp.left,
            top: topBound,
            width: upperComp.width,
            height: bottomBound - topBound,
            teaserPos: (upperComp.top + upperComp.height + lowerComp.top) / 2 - topBound,
            dropParams: {
              insertPos: i
            }
          });
        }

        if (i < numDropzones - 1) {
          var comp = components[i];
          // We get the isolated node wrapper and want to use the content element
          if (comp._isIsolatedNodeComponent) {
            comp = comp.getContent();
          }
          // If component has dropzones declared
          if (comp.getDropzoneSpecs) {
            var dropzoneSpecs = comp.getDropzoneSpecs();
            dropzoneSpecs.forEach(function (dropzoneSpec) {
              var dropzoneComp = dropzoneSpec.component;
              var rect = this$1._getBoundingRect(dropzoneComp);
              dropzones.push({
                type: 'custom',
                component: comp,
                dropzoneComponent: dropzoneComp,
                left: rect.left,
                top: rect.top,
                width: rect.width,
                height: rect.height,
                message: dropzoneSpec.message,
                dropParams: dropzoneSpec.dropParams
              });
            });
          }
        }
      }
      scopedDropzones[surface.getName()] = dropzones;
    });
    return scopedDropzones
  };

  Dropzones.prototype._renderDropTeaser = function _renderDropTeaser (hints) {
    if (hints.visible) {
      this.el.removeClass('sm-hidden');
      this.el.css('top', hints.rect.top);
      this.el.css('left', hints.rect.left);
      this.el.css('right', hints.rect.right);
    } else {
      this.el.addClass('sm-hidden');
    }
  };

  return Dropzones;
}(Component));

var DropzonesPackage = {
  name: 'dropzones',
  configure: function(config) {
    config.addComponent('dropzones', Dropzones);
  }
};

/**
  A rich scrollbar implementation that supports highlights.   Usually
  instantiated by {@link ScrollPane}, so you will likely not create it
  yourself.

  @class Scrollbar
  @component
  @private

  @prop {ui/ScrollPane} scrollPane scroll pane the scrollbar operates on
  @prop {object} highlights hightlights grouped by scope

  @example

  ```js
  $$(Scrollbar, {
    scrollPane: this,
    highlights: {
      'bib-items': ['bib-item-citation-1', 'bib-item-citation-2']
    }
  }).ref('scrollbar')
  ```
*/

var Scrollbar = (function (Component$$1) {
  function Scrollbar () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Scrollbar.__proto__ = Component$$1;
  Scrollbar.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Scrollbar.prototype.constructor = Scrollbar;

  Scrollbar.prototype.didMount = function didMount () {
    // do a full rerender when window gets resized
    DefaultDOMElement.getBrowserWindow().on('resize', this.onResize, this);
    // update the scroll handler on scroll
    this.props.scrollPane.on('scroll', this.onScroll, this);
    // TODO: why is this necessary here?
    setTimeout(function() {
      this.updatePositions();
    }.bind(this));
  };

  Scrollbar.prototype.dispose = function dispose () {
    DefaultDOMElement.getBrowserWindow().off(this);
    this.props.scrollPane.off(this);
  };

  Scrollbar.prototype.didUpdate = function didUpdate () {
    this.updatePositions();
  };

  Scrollbar.prototype.render = function render ($$) {
    var el = $$('div')
      .addClass('sc-scrollbar')
      .on('mousedown', this.onMouseDown);

    if (this.props.highlights) {
      var highlightEls = [];

      forEach(this.props.highlights, function(highlights, scope) {
        forEach(highlights, function(h) {
          highlightEls.push(
            $$('div').ref(h).addClass('se-highlight sm-'+scope)
          );
        });
      });

      el.append(
        $$('div').ref('highlights')
          .addClass('se-highlights')
          .append(highlightEls)
      );
    }
    el.append($$('div').ref('thumb').addClass('se-thumb'));
    return el
  };

  Scrollbar.prototype.updatePositions = function updatePositions () {
    var scrollPane = this.props.scrollPane;
    var scrollableEl = scrollPane.getScrollableElement();
    var contentHeight = scrollPane.getContentHeight();
    var scrollPaneHeight = scrollPane.getHeight();
    var scrollTop = scrollPane.getScrollPosition();
    var contentEl = scrollPane.getContentElement();

    // Needed for scrollbar interaction
    this.factor = (contentHeight / scrollPaneHeight);

    if (this.factor <= 1) {
      this.el.addClass('sm-hide-thumb');
    } else {
      this.el.removeClass('sm-hide-thumb');
    }

    this.refs.thumb.css({
      top: scrollTop / this.factor,
      height: scrollPaneHeight / this.factor
    });

    // If we have highlights, update them as well
    if (this.props.highlights) {
      // Compute highlights
      forEach(this.props.highlights,function(highlights) {
        forEach(highlights, function(nodeId) {
          var nodeEl = scrollableEl.find('*[data-id="'+nodeId+'"]');

          if (!nodeEl) { return }

          // Compute bounding rect relative to scroll pane content element
          var rect = getRelativeBoundingRect(nodeEl.getNativeElement(), contentEl.getNativeElement());
          var top = rect.top / this.factor;
          var height = rect.height / this.factor;

          // Use specified minHeight for highlights
          if (height < Scrollbar.overlayMinHeight) {
            height = Scrollbar.overlayMinHeight;
          }

          var highlightEl = this.refs[nodeId];
          if (highlightEl) {
            this.refs[nodeId].css({
              top: top,
              height: height
            });
          } else {
            console.warn('no ref found for highlight', nodeId);
          }
        }.bind(this));
      }.bind(this));
    }
  };

  Scrollbar.prototype.getScrollableElement = function getScrollableElement () {
    return this.props.scrollPane.getScrollableElement()
  };

  Scrollbar.prototype.onResize = function onResize () {
    this.rerender();
  };

  Scrollbar.prototype.onScroll = function onScroll () {
    this.updatePositions();
  };

  Scrollbar.prototype.onMouseDown = function onMouseDown (e) {
    e.stopPropagation();
    e.preventDefault();
    this._mouseDown = true;

    // temporarily, we bind to events on window level
    // because could leave the this element's area while dragging
    var _window = DefaultDOMElement.getBrowserWindow();
    _window.on('mousemove', this.onMouseMove, this);
    _window.on('mouseup', this.onMouseUp, this);

    var scrollBarOffset = this.el.getOffset().top;
    var y = e.pageY - scrollBarOffset;
    var thumbEl = this.refs.thumb.el;
    if (e.target !== thumbEl.getNativeElement()) {
      // Jump to mousedown position
      this.offset = thumbEl.height / 2;
      this.onMouseMove(e);
    } else {
      this.offset = y - thumbEl.getPosition().top;
    }
  };

  // Handle Mouse Up
  Scrollbar.prototype.onMouseUp = function onMouseUp () {
    this._mouseDown = false;
    var _window = DefaultDOMElement.getBrowserWindow();
    _window.off('mousemove', this.onMouseMove, this);
    _window.off('mouseup', this.onMouseUp, this);
  };

  Scrollbar.prototype.onMouseMove = function onMouseMove (e) {
    if (this._mouseDown) {
      var scrollPane = this.props.scrollPane;
      var scrollableEl = scrollPane.getScrollableElement();
      var scrollBarOffset = this.el.getOffset().top;
      var y = e.pageY - scrollBarOffset;

      // find offset to visible-area.top
      var scroll = (y-this.offset)*this.factor;
      scrollableEl.setProperty('scrollTop', scroll);
    }
  };

  return Scrollbar;
}(Component));

Scrollbar.overlayMinHeight = 2;

var ScrollbarPackage = {
  name: 'scrollbar',
  configure: function(config) {
    config.addComponent('scrollbar', Scrollbar);
  }
};

/**
  Get bounding bounds for a given mouse event, relative parent element.

  @param {MouseEvent} mouseEvent the source mouse event
  @param {DOMElement} containerEl used as a reference point to calculate position
  @return {object} bound description with left, top, right, bottom
*/
function getRelativeMouseBounds(mouseEvent, containerEl) {
  var containerElRect = containerEl.getBoundingClientRect();
  var left = mouseEvent.clientX - containerElRect.left;
  var top = mouseEvent.clientY - containerElRect.top;
  var res = {
    left: left,
    right: containerElRect.width - left,
    top: top,
    bottom: containerElRect.height - top
  };
  return res;
}

var AbstractScrollPane = (function (Component$$1) {
  function AbstractScrollPane () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) AbstractScrollPane.__proto__ = Component$$1;
  AbstractScrollPane.prototype = Object.create( Component$$1 && Component$$1.prototype );
  AbstractScrollPane.prototype.constructor = AbstractScrollPane;

  AbstractScrollPane.prototype.getChildContext = function getChildContext () {
    return {
      scrollPane: this
    }
  };

  AbstractScrollPane.prototype.didMount = function didMount () {
    this.handleActions({
      'domSelectionRendered': this._onDomSelectionRendered
    });

    if (inBrowser) {
      this.windowEl = DefaultDOMElement.wrapNativeElement(window);
      this.windowEl.on('resize', this._onDomSelectionRendered, this);
    }
  };

  AbstractScrollPane.prototype.dispose = function dispose () {
    if (this.windowEl) {
      this.windowEl.off(this);
    }
  };

  AbstractScrollPane.prototype.getName = function getName () {
    return this.props.name
  };

  /*
    Determine selection rectangle relative to content element
    and emit a dom-selection:rendered event with positioning hints
  */
  AbstractScrollPane.prototype._onDomSelectionRendered = function _onDomSelectionRendered () {
    var contentRect = this._getContentRect();
    var selectionRect = this._getSelectionRect();
    if (!selectionRect) { return }
    // Allows overlays to do positioning relative to the current
    // selection bounding rectangle.
    this.emit('selection:positioned', {
      contentRect: contentRect,
      selectionRect: selectionRect
    });
    // TODO: Remove legacy support
    this.emit('dom-selection:rendered', {
      contentRect: contentRect,
      selectionRect: selectionRect
    });
    this._scrollSelectionIntoView(selectionRect);
  };

  /*
    Determine mouse bounds relative to content element
    and emit context-menu:opened event with positioning hints
  */
  AbstractScrollPane.prototype._onContextMenu = function _onContextMenu (e) {
    e.preventDefault();
    var mouseBounds = this._getMouseBounds(e);
    this.emit('context-menu:opened', {
      mouseBounds: mouseBounds
    });
  };

  AbstractScrollPane.prototype._scrollSelectionIntoView = function _scrollSelectionIntoView (selectionRect) {
    var upperBound = this.getScrollPosition();
    var lowerBound = upperBound + this.getHeight();
    var selTop = selectionRect.top;
    var selBottom = selectionRect.top + selectionRect.height;
    if ((selTop < upperBound && selBottom < upperBound) ||
        (selTop > lowerBound && selBottom > lowerBound)) {
      this.setScrollPosition(selTop);
    }
  };

  /**
    Returns the height of scrollPane (inner content overflows)
  */
  AbstractScrollPane.prototype.getHeight = function getHeight () {
    throw new Error('Abstract method')
  };

  /**
    Returns the cumulated height of a panel's content
  */
  AbstractScrollPane.prototype.getContentHeight = function getContentHeight () {
    throw new Error('Abstract method')
  };

  AbstractScrollPane.prototype.getContentElement = function getContentElement () {
    // TODO: should be wrapped in DefaultDOMElement
    throw new Error('Abstract method')
  };

  // /**
  //   Get the `.se-scrollable` element
  // */
  AbstractScrollPane.prototype.getScrollableElement = function getScrollableElement () {
    throw new Error('Abstract method')
  };

  /**
    Get current scroll position (scrollTop) of `.se-scrollable` element
  */
  AbstractScrollPane.prototype.getScrollPosition = function getScrollPosition () {
    throw new Error('Abstract method')
  };

  AbstractScrollPane.prototype.setScrollPosition = function setScrollPosition () {
    throw new Error('Abstract method')
  };

  /**
    Get offset relative to `.se-content`.

    @param {DOMNode} el DOM node that lives inside the
  */
  AbstractScrollPane.prototype.getPanelOffsetForElement = function getPanelOffsetForElement (el) { // eslint-disable-line
    throw new Error('Abstract method')
  };

  /**
    Scroll to a given sub component.

    @param {String} componentId component id, must be present in data-id attribute
  */
  AbstractScrollPane.prototype.scrollTo = function scrollTo (componentId, onlyIfNotVisible) { // eslint-disable-line
    throw new Error('Abstract method')
  };

  AbstractScrollPane.prototype._getContentRect = function _getContentRect () {
    return this.getContentElement().getNativeElement().getBoundingClientRect()
  };

  /*
    Get selection rectangle relative to panel content element
  */
  AbstractScrollPane.prototype._getSelectionRect = function _getSelectionRect () {
    return getSelectionRect(this._getContentRect())
  };

  AbstractScrollPane.prototype._getMouseBounds = function _getMouseBounds (e) {
    return getRelativeMouseBounds(e, this.getContentElement().getNativeElement())
  };

  return AbstractScrollPane;
}(Component));

/**
  Wraps content in a scroll pane.

  NOTE: It is best practice to put all overlays as direct childs of the ScrollPane
        to reduce the chance that positioning gets messed up (position: relative)

  @prop {String} scrollbarType 'native' or 'substance' for a more advanced visual scrollbar. Defaults to 'native'
  @prop {String} [scrollbarPosition] 'left' or 'right' only relevant when scrollBarType: 'substance'. Defaults to 'right'
  @prop {ui/Highlights} [highlights] object that maintains highlights and can be manipulated from different sources
  @prop {ui/TOCProvider} [tocProvider] object that maintains table of content entries

  @example

  ```js
  $$(ScrollPane, {
    scrollbarType: 'substance', // defaults to native
    scrollbarPosition: 'left', // defaults to right
    onScroll: this.onScroll.bind(this),
    highlights: this.contentHighlights,
    tocProvider: this.tocProvider
  })
  ```
*/
var ScrollPane = (function (AbstractScrollPane$$1) {
  function ScrollPane () {
    AbstractScrollPane$$1.apply(this, arguments);
  }

  if ( AbstractScrollPane$$1 ) ScrollPane.__proto__ = AbstractScrollPane$$1;
  ScrollPane.prototype = Object.create( AbstractScrollPane$$1 && AbstractScrollPane$$1.prototype );
  ScrollPane.prototype.constructor = ScrollPane;

  ScrollPane.prototype.didMount = function didMount () {
    AbstractScrollPane$$1.prototype.didMount.call(this);
    if (this.refs.scrollbar && this.props.highlights) {
      this.props.highlights.on('highlights:updated', this.onHighlightsUpdated, this);
    }
    if (this.refs.scrollbar) {
      this.domObserver = new window.MutationObserver(this._onContentChanged.bind(this));
      this.domObserver.observe(this.el.getNativeElement(), {
        subtree: true,
        attributes: true,
        characterData: true,
        childList: true,
      });
      this.context.editorSession.onPosition(this._onPosition, this);
    }
  };

  ScrollPane.prototype.dispose = function dispose () {
    AbstractScrollPane$$1.prototype.dispose.call(this);
    if (this.props.highlights) {
      this.props.highlights.off(this);
    }
    this.context.editorSession.off(this);
    this.context.dragManager.off(this);
  };

  ScrollPane.prototype.render = function render ($$) {
    var el = $$('div')
      .addClass('sc-scroll-pane');

    if (platform.isFF) {
      el.addClass('sm-firefox');
    }

    // When noStyle is provided we just use ScrollPane as a container, but without
    // any absolute positioned containers, leaving the body scrollable.
    if (!this.props.noStyle) {
      el.addClass('sm-default-style');
    }

    // Initialize Substance scrollbar (if enabled)
    if (this.props.scrollbarType === 'substance') {
      el.addClass('sm-substance-scrollbar');
      el.addClass('sm-scrollbar-position-' + this.props.scrollbarPosition);

      el.append(
        // TODO: is there a way to pass scrollbar highlights already
        // via props? Currently the are initialized with a delay
        $$(Scrollbar, {
          scrollPane: this
        }).ref('scrollbar')
          .attr('id', 'content-scrollbar')
      );

      // Scanline is debugging purposes, display: none by default.
      el.append(
        $$('div').ref("scanline").addClass('se-scanline')
      );
    }

    el.append(
      $$('div').ref('scrollable').addClass('se-scrollable').append(
        this.renderContent($$)
      ).on('scroll', this.onScroll)
    );
    return el
  };

  ScrollPane.prototype.renderContent = function renderContent ($$) {
    var contentEl = $$('div').ref('content').addClass('se-content');
    contentEl.append(this.props.children);
    if (this.props.contextMenu === 'custom') {
      contentEl.on('contextmenu', this._onContextMenu);
    }
    return contentEl
  };

  ScrollPane.prototype._onContentChanged = function _onContentChanged () {
    this._contentChanged = true;
  };

  ScrollPane.prototype._onPosition = function _onPosition () {
    if (this.refs.scrollbar && this._contentChanged) {
      this._contentChanged = false;
      this._updateScrollbar();
    }
  };

  ScrollPane.prototype._updateScrollbar = function _updateScrollbar () {
    if (this.refs.scrollbar) {
      this.refs.scrollbar.updatePositions();
    }
  };

  ScrollPane.prototype.onHighlightsUpdated = function onHighlightsUpdated (highlights) {
    this.refs.scrollbar.extendProps({
      highlights: highlights
    });
  };

  ScrollPane.prototype.onScroll = function onScroll () {
    var scrollPos = this.getScrollPosition();
    var scrollable = this.refs.scrollable;
    if (this.props.onScroll) {
      this.props.onScroll(scrollPos, scrollable);
    }
    // Update TOCProvider given
    if (this.props.tocProvider) {
      this.props.tocProvider.markActiveEntry(this);
    }
    this.emit('scroll', scrollPos, scrollable);
  };

  /**
    Returns the height of scrollPane (inner content overflows)
  */
  ScrollPane.prototype.getHeight = function getHeight () {
    var scrollableEl = this.getScrollableElement();
    return scrollableEl.height
  };

  /**
    Returns the cumulated height of a panel's content
  */
  ScrollPane.prototype.getContentHeight = function getContentHeight () {
    var contentEl = this.refs.content.el.getNativeElement();
    // Important to use scrollHeight here (e.g. to consider overflowing
    // content, that stretches the content area, such as an overlay or
    // a context menu)
    return contentEl.scrollHeight
  };

  /**
    Get the `.se-content` element
  */
  ScrollPane.prototype.getContentElement = function getContentElement () {
    return this.refs.content.el
  };

  /**
    Get the `.se-scrollable` element
  */
  ScrollPane.prototype.getScrollableElement = function getScrollableElement () {
    return this.refs.scrollable.el
  };

  /**
    Get current scroll position (scrollTop) of `.se-scrollable` element
  */
  ScrollPane.prototype.getScrollPosition = function getScrollPosition () {
    var scrollableEl = this.getScrollableElement();
    return scrollableEl.getProperty('scrollTop')
  };

  ScrollPane.prototype.setScrollPosition = function setScrollPosition (scrollPos) {
    var scrollableEl = this.getScrollableElement();
    scrollableEl.setProperty('scrollTop', scrollPos);
  };

  /**
    Get offset relative to `.se-content`.

    @param {DOMNode} el DOM node that lives inside the
  */
  ScrollPane.prototype.getPanelOffsetForElement = function getPanelOffsetForElement (el) {
    var nativeEl = el.getNativeElement();
    var contentContainerEl = this.refs.content.getNativeElement();
    var rect = getRelativeBoundingRect(nativeEl, contentContainerEl);
    return rect.top
  };

  /**
    Scroll to a given sub component.

    @param {String} componentId component id, must be present in data-id attribute
  */
  ScrollPane.prototype.scrollTo = function scrollTo (componentId, onlyIfNotVisible) {
    var scrollableEl = this.getScrollableElement();
    var targetNode = scrollableEl.find('*[data-id="'+componentId+'"]');
    if (targetNode) {
      var offset = this.getPanelOffsetForElement(targetNode);
      var shouldScroll = true;
      if (onlyIfNotVisible) {
        var height = scrollableEl.height;
        var oldOffset = scrollableEl.getProperty('scrollTop');
        shouldScroll = (offset < oldOffset || oldOffset+height<offset);
      }
      if (shouldScroll) {
        this.setScrollPosition(offset);
      }
    } else {
      console.warn(componentId, 'not found in scrollable container');
    }
  };

  /*
    Determines the selection bounding rectangle relative to the scrollpane's content.
  */
  ScrollPane.prototype._onDomSelectionRendered = function _onDomSelectionRendered () {
    AbstractScrollPane$$1.prototype._onDomSelectionRendered.call(this);
    this._updateScrollbar();
  };

  ScrollPane.prototype._onContextMenu = function _onContextMenu (e) {
    AbstractScrollPane$$1.prototype._onContextMenu.call(this, e);
    this._updateScrollbar();
  };

  return ScrollPane;
}(AbstractScrollPane));

var ScrollPanePackage = {
  name: 'scroll-pane',
  configure: function(config) {
    config.addComponent('scroll-pane', ScrollPane);
  }
};

/**
  Wraps content in a scroll pane.

  @class ScrollPane
  @component

  @prop {String} scrollbarType 'native' or 'substance' for a more advanced visual scrollbar. Defaults to 'native'
  @prop {String} [scrollbarPosition] 'left' or 'right' only relevant when scrollBarType: 'substance'. Defaults to 'right'
  @prop {ui/Highlights} [highlights] object that maintains highlights and can be manipulated from different sources
  @prop {ui/TOCProvider} [tocProvider] object that maintains table of content entries

  @example

  ```js
  $$(BodyScrollPane).append(
    content,
    $$(ContextMenu)
    $$(Overlay)
  )
  ```
*/
var BodyScrollPane = (function (AbstractScrollPane$$1) {
  function BodyScrollPane () {
    AbstractScrollPane$$1.apply(this, arguments);
  }

  if ( AbstractScrollPane$$1 ) BodyScrollPane.__proto__ = AbstractScrollPane$$1;
  BodyScrollPane.prototype = Object.create( AbstractScrollPane$$1 && AbstractScrollPane$$1.prototype );
  BodyScrollPane.prototype.constructor = BodyScrollPane;

  BodyScrollPane.prototype.getChildContext = function getChildContext () {
    return {
      scrollPane: this
    }
  };

  BodyScrollPane.prototype.getName = function getName () {
    return 'body'
  };

  BodyScrollPane.prototype.render = function render ($$) {
    var el = $$('div');
    if (this.props.contextMenu === 'custom') {
      el.on('contextmenu', this._onContextMenu);
    }
    el.append(this.props.children);
    return el
  };

  /**
    Returns the height of scrollPane (inner content overflows)
  */
  BodyScrollPane.prototype.getHeight = function getHeight () {
    return window.innerHeight
  };

  /**
    Returns the cumulated height of a panel's content
  */
  BodyScrollPane.prototype.getContentHeight = function getContentHeight () {
    return document.body.scrollHeight
  };

  BodyScrollPane.prototype.getContentElement = function getContentElement () {
    return DefaultDOMElement.wrapNativeElement(window.document.body)
  };

  // /**
  //   Get the `.se-scrollable` element
  // */
  BodyScrollPane.prototype.getScrollableElement = function getScrollableElement () {
    return document.body
  };

  /**
    Get current scroll position (scrollTop) of `.se-scrollable` element
  */
  BodyScrollPane.prototype.getScrollPosition = function getScrollPosition () {
    return document.body.scrollTop
  };

  BodyScrollPane.prototype.setScrollPosition = function setScrollPosition (scrollPos) {
    document.body.scrollTop = scrollPos;
  };

  /**
    Get offset relative to `.se-content`.

    @param {DOMNode} el DOM node that lives inside the
  */
  BodyScrollPane.prototype.getPanelOffsetForElement = function getPanelOffsetForElement (el) { // eslint-disable-line
    console.warn('TODO: implement');
  };

  /**
    Scroll to a given sub component.

    @param {String} componentId component id, must be present in data-id attribute
  */
  BodyScrollPane.prototype.scrollTo = function scrollTo (componentId, onlyIfNotVisible) { // eslint-disable-line
    console.warn('TODO: implement');
  };

  return BodyScrollPane;
}(AbstractScrollPane));

var BodyScrollPanePackage = {
  name: 'body-scroll-pane',
  configure: function(config) {
    config.addComponent('body-scroll-pane', BodyScrollPane);
  }
};

/**
  A split view layout component. Takes properties for configuration and 2 children via append.

  @class SplitPane
  @component

  @prop {String} splitType either 'vertical' (default) or 'horizontal'.
  @prop {String} sizeA size of the first pane (A). '40%' or '100px' or 'inherit' are valid values.
  @prop {String} sizeB size of second pane. sizeA and sizeB can not be combined.

  @example

  ```js
  $$(SplitPane, {
    sizeA: '30%',
    splitType: 'horizontal'
  }).append(
    $$('div').append('Pane A'),
    $$('div').append('Pane B')
  )
  ```
*/

var SplitPane = (function (Component$$1) {
  function SplitPane () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) SplitPane.__proto__ = Component$$1;
  SplitPane.prototype = Object.create( Component$$1 && Component$$1.prototype );
  SplitPane.prototype.constructor = SplitPane;

  SplitPane.prototype.render = function render ($$) {
    if (this.props.children.length !== 2) {
      throw new Error('SplitPane only works with exactly two child elements')
    }

    var el = $$('div').addClass('sc-split-pane');
    if (this.props.splitType === 'horizontal') {
      el.addClass('sm-horizontal');
    } else {
      el.addClass('sm-vertical');
    }

    var paneA = this.props.children[0];
    var paneB = this.props.children[1];

    // Apply configured size either to pane A or B.
    if (this.props.sizeB) {
      paneB.addClass('se-pane sm-sized');
      paneB.css(this.getSizedStyle(this.props.sizeB));
      paneA.addClass('se-pane sm-auto-fill');
    } else {
      paneA.addClass('se-pane sm-sized');
      paneA.css(this.getSizedStyle(this.props.sizeA));
      paneB.addClass('se-pane sm-auto-fill');
    }

    el.append(
      paneA,
      paneB
    );
    return el
  };

  // Accepts % and px units for size property
  SplitPane.prototype.getSizedStyle = function getSizedStyle (size) {
    if (!size || size === 'inherit') { return {} }
    if (this.props.splitType === 'horizontal') {
      return {'height': size}
    } else {
      return {'width': size}
    }
  };

  return SplitPane;
}(Component));

var SplitPanePackage = {
  name: 'split-pane',
  configure: function(config) {
    config.addComponent('split-pane', SplitPane);
  }
};

/*
  A tabbed pane layout component. The actual content is specified via append.

  @class TabbedPane
  @component

  @prop {Object[]} tabs an array of objects with id and name properties
  @prop {String} activeTab id of currently active tab

  @example

  ```js
  $$(TabbedPane, {
    tabs: [
      {id: 'tabA', 'A'},
      {id: 'tabB', 'B'},
    ],
    activeTab: 'tabA'
  }).ref('tabbedPane').append(
    tabAContent
  )
  ```
*/

var TabbedPane = (function (Component$$1) {
  function TabbedPane () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) TabbedPane.__proto__ = Component$$1;
  TabbedPane.prototype = Object.create( Component$$1 && Component$$1.prototype );
  TabbedPane.prototype.constructor = TabbedPane;

  TabbedPane.prototype.render = function render ($$) {
    var el = $$('div').addClass('sc-tabbed-pane');
    var tabsEl = $$('div').addClass('se-tabs');
    forEach(this.props.tabs, function(tab) {
      var tabEl = $$('a')
        .addClass("se-tab")
        .attr({
          href: "#",
          "data-id": tab.id,
        })
        .on('click', this.onTabClicked);
      if (tab.id === this.props.activeTab) {
        tabEl.addClass("sm-active");
      }
      tabEl.append(
        $$('span').addClass('label').append(tab.name)
      );
      tabsEl.append(tabEl);
    }.bind(this));

    el.append(tabsEl);
    // Active content
    el.append(
      $$('div').addClass('se-tab-content').ref('tabContent').append(
        this.props.children
      )
    );
    return el
  };

  TabbedPane.prototype.onTabClicked = function onTabClicked (e) {
    e.preventDefault();
    var tabId = e.currentTarget.dataset.id;
    this.send('switchTab', tabId);
  };

  return TabbedPane;
}(Component));

var TabbedPanePackage = {
  name: 'tabbed-pane',
  configure: function(config) {
    config.addComponent('tabbed-pane', TabbedPane);
  }
};

var FileNode = (function (DocumentNode$$1) {
  function FileNode() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    DocumentNode$$1.apply(this, args);
  }

  if ( DocumentNode$$1 ) FileNode.__proto__ = DocumentNode$$1;
  FileNode.prototype = Object.create( DocumentNode$$1 && DocumentNode$$1.prototype );
  FileNode.prototype.constructor = FileNode;

  FileNode.prototype.getUrl = function getUrl () {
    if (this.proxy) {
      return this.proxy.getUrl()
    } else {
      // this happens if no FileProxy is attached
      console.warn('No file proxy attached to ', this.id);
      return ''
    }
  };

  FileNode.prototype.setProxy = function setProxy (proxy) {
    this.proxy = proxy;
  };

  return FileNode;
}(DocumentNode));

FileNode.type = 'file';

FileNode.schema = {
  url: { type: 'string', optional: true },
  fileType: { type: 'string', optional: true },
  mimeType: { type: 'string', optional: true },
  sourceFile: { type: 'object', optional: true }
};

FileNode.prototype._isFileNode = true;
FileNode._isFileNode = true;

var FilePackage = {
  name: 'file',
  configure: function(config) {
    config.addNode(FileNode);
  }
};

/**
  Default Tool implementation

  A tool must be associated with a Command, which holds all the logic, while the tool
  is just the visual representation of the command state. You can use this component
  for simple button-like tools, or extend it to create your own UI.

  @class
  @component

  @example

  Usually instantiated in a Toolbar or an Overlay. Usage:

  ```
  $$(Tool, {
    icon: 'strong',
    label: 'strong',
    style: 'outline',
    active: false,
    disabled: false
  })
  ```


  ```
  config.addCommand('strong', AnnotationCommand, { nodeType: 'strong' })
  config.addTool('strong', AnnotationTool, {
    target: 'annotations'
  })
  ```
*/
var Tool = (function (Component$$1) {
  function Tool () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Tool.__proto__ = Component$$1;
  Tool.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Tool.prototype.constructor = Tool;

  var prototypeAccessors = { _isTool: {} };

  prototypeAccessors._isTool.get = function () {
    return true
  };

  /**
    Default tool rendering. You can override this method to provide your custom markup
  */
  Tool.prototype.render = function render ($$) {
    var el = $$('div')
      .addClass('se-tool');

    var customClassNames = this.getClassNames();
    if (customClassNames) {
      el.addClass(customClassNames);
    }

    var title = this.getTitle();
    if (title) {
      el.attr('title', title);
      el.attr('aria-label', title);
    }

    el.append(
      this.renderButton($$)
    );
    return el
  };

  Tool.prototype.renderButton = function renderButton ($$) {
    var Button = this.getComponent('button');
    var btn = $$(Button, {
      icon: this.props.showIcon ? this.props.name : null,
      label: this.props.showLabel ? this.props.name : null,
      hint: this.props.showHint ? this.props.name : null,
      active: this.props.active,
      disabled: this.props.disabled,
      style: this.props.style
    }).on('click', this.onClick);
    return btn
  };

  Tool.prototype.getClassNames = function getClassNames () {
    return ''
  };

  Tool.prototype.getTitle = function getTitle () {
    var labelProvider = this.context.labelProvider;
    var title = this.props.title || labelProvider.getLabel(this.getName());
    // Used only by annotation tool so far
    if (this.props.mode) {
      title = [capitalize(this.props.mode), title].join(' ');
    }
    return title
  };

  /*
    For now always same as tool name
  */
  Tool.prototype.getCommandName = function getCommandName () {
    return this.getName()
  };

  Tool.prototype.getName = function getName () {
    return this.props.name
  };

  Tool.prototype.onClick = function onClick (e) {
    e.preventDefault();
    e.stopPropagation();
    if (!this.props.disabled) { this.executeCommand(); }
  };

  /**
    Executes the associated command
  */
  Tool.prototype.executeCommand = function executeCommand (props) {
    this.context.commandManager.executeCommand(this.getCommandName(), extend({
      mode: this.props.mode
    }, props));
  };

  Object.defineProperties( Tool.prototype, prototypeAccessors );

  return Tool;
}(Component));

/**
  Commands are used to perform UI triggered actions on the document. For instance the
  {@link ui/AnnotationCommand} takes care of creating, expanding, truncating and
  deleting annotations such as strong and emphasis. It does so by determining a
  commandState by inspecting the current selection, which is used to parametrize
  the corresponding tool component. E.g. the strong tool gets active and clickable
  in create mode when a word in the text is selected. Triggered by a click on the tool,
  or a keyboard shortcut, the command gets executed by running the code specified in the
  execute method.

  @class Command
  @abstract

  @example

  ```
  class MyCommand extends Command {
    getCommandState(params, context) {
      // determine commandState based on params and context
    }

    execute(params, context) {
      // perform operations on the document
    }
  }
  ```
*/
var Command = function Command(config) {
  this.config = config || {};
  this.name = this.config.name;
  if (!this.name) {
    throw new Error("'name' is required");
  }
};

var prototypeAccessors$9 = { isAsync: {} };

prototypeAccessors$9.isAsync.get = function () {
  return false
};

/**
  Get the command name specified at command registration. See
  {@link util/Configurator#addCommand}
*/
Command.prototype.getName = function getName () {
  return this.name
};

/**
  Determines command state, based on passed params and context. The command
  state is usually used as props for tool components.

  @example

  This shows the implementation of {@link EditAnnotationCommand#getCommandState}

  ```
  getCommandState(params) {
    const sel = this._getSelection(params)
    const annos = params.selectionState.getAnnotationsForType(this.config.nodeType)
    const newState = {
      disabled: true,
    }

    if (annos.length === 1 && sel.isPropertySelection()) {
      newState.disabled = false
      newState.node = annos[0]
    }
  }
  ```

  @param {Object} params    Provides editorSession, selectionState, surface, selection
  @param {Object} context   Provides app-specific context.
*/
Command.prototype.getCommandState = function getCommandState (params, context) { // eslint-disable-line
  throw new Error('Command.getCommandState() is abstract.')
};

/**
  Execute command and perform operations on the document

  @param {Object} params    Provides commandState, editorSession, selectionState, surface, selection
  @param {Object} context   Provides app-specific context.

  @return {Object} info object with execution details
*/
Command.prototype.execute = function execute (params, context) { // eslint-disable-line
  throw new Error('Command.execute() is abstract.')
};

Command.prototype._getEditorSession = function _getEditorSession (params, context) {
  var editorSession = params.editorSession || context.editorSession;
  if (!editorSession) {
    throw new Error("'editorSession' is required.")
  }
  return editorSession
};

Command.prototype._getSelection = function _getSelection (params) {
  var sel = params.selection || params.selectionState.getSelection();
  if (!sel) {
    throw new Error("'selection' is required.")
  }
  return sel
};

Object.defineProperties( Command.prototype, prototypeAccessors$9 );

Command.prototype._isCommand = true;

var Undo = (function (Command$$1) {
  function Undo () {
    Command$$1.apply(this, arguments);
  }

  if ( Command$$1 ) Undo.__proto__ = Command$$1;
  Undo.prototype = Object.create( Command$$1 && Command$$1.prototype );
  Undo.prototype.constructor = Undo;

  Undo.prototype.getCommandState = function getCommandState (params) {
    var editorSession = params.editorSession;
    return {
      disabled: !editorSession.canUndo(),
      active: false
    }
  };

  Undo.prototype.execute = function execute (params) {
    var editorSession = params.editorSession;
    if (editorSession.canUndo()) {
      editorSession.undo();
      return true
    }
    return false
  };

  return Undo;
}(Command));

var Redo = (function (Command$$1) {
  function Redo () {
    Command$$1.apply(this, arguments);
  }

  if ( Command$$1 ) Redo.__proto__ = Command$$1;
  Redo.prototype = Object.create( Command$$1 && Command$$1.prototype );
  Redo.prototype.constructor = Redo;

  Redo.prototype.getCommandState = function getCommandState (params) {
    var editorSession = params.editorSession;
    return {
      disabled: !editorSession.canRedo(),
      active: false
    }
  };

  Redo.prototype.execute = function execute (params) {
    var editorSession = params.editorSession;
    if (editorSession.canRedo()) {
      editorSession.redo();
      return true
    } else {
      return false
    }
  };

  return Redo;
}(Command));

var SelectAll = (function (Command$$1) {
  function SelectAll () {
    Command$$1.apply(this, arguments);
  }

  if ( Command$$1 ) SelectAll.__proto__ = Command$$1;
  SelectAll.prototype = Object.create( Command$$1 && Command$$1.prototype );
  SelectAll.prototype.constructor = SelectAll;

  SelectAll.prototype.getCommandState = function getCommandState (params) {
    var editorSession = params.editorSession;
    return {
      disabled: editorSession.getSelection().isNull()
    }
  };

  SelectAll.prototype.execute = function execute (params) {
    var editorSession = params.editorSession;
    var doc = editorSession.getDocument();
    var surface = params.surface || editorSession.getFocusedSurface();
    if (surface) {
      var sel;
      // TODO: we should move the logic out of the surfaces
      if (surface._isContainerEditor) {
        var container = surface.getContainer();
        if (container.nodes.length === 0) {
          return false
        }
        var firstNodeId = container.nodes[0];
        var lastNodeId = last$2(container.nodes);
        sel = editorSession.createSelection({
          type: 'container',
          startPath: [firstNodeId],
          startOffset: 0,
          endPath: [lastNodeId],
          endOffset: 1,
          containerId: container.id,
          surfaceId: surface.id
        });
      } else if (surface._isTextPropertyEditor) {
        var path = surface.getPath();
        var text = doc.get(path);
        sel = editorSession.createSelection({
          type: 'property',
          path: path,
          startOffset: 0,
          endOffset: text.length,
          surfaceId: surface.id
        });
      }
      editorSession.setSelection(sel);
      return true
    }
    return false
  };

  return SelectAll;
}(Command));

var BasePackage = {
  name: 'base',
  configure: function(config) {
    config.import(FilePackage);
    config.import(ScrollPanePackage);
    config.import(BodyScrollPanePackage);
    config.import(SplitPanePackage);
    config.import(TabbedPanePackage);
    config.import(ScrollbarPackage);
    config.import(GridPackage);
    config.import(ModalPackage);
    config.import(InputPackage);
    config.import(ButtonPackage);
    config.import(LayoutPackage);
    config.import(ContextMenuPackage);
    config.import(OverlayPackage);
    config.import(DropzonesPackage);
    config.import(GutterPackage);

    // Setup base toolgroups
    config.addToolGroup('document');
    config.addToolGroup('annotations');
    config.addToolGroup('default');
    config.addToolGroup('context-menu-primary');
    config.addToolGroup('context-menu-document');
    config.addToolGroup('insert');

    // Commands
    config.addCommand('undo', Undo);
    config.addCommand('redo', Redo);
    config.addCommand('select-all', SelectAll);

    // Tools
    config.addTool('undo', Tool, {toolGroup: ['document', 'context-menu-document']});
    config.addTool('redo', Tool, {toolGroup: ['document', 'context-menu-document']});
    config.addTool('select-all', Tool, {toolGroup: ['context-menu-document']});

    // Icons
    config.addIcon('undo', { 'fontawesome': 'fa-undo' });
    config.addIcon('redo', { 'fontawesome': 'fa-repeat' });
    config.addIcon('edit', { 'fontawesome': 'fa-cog' });
    config.addIcon('delete', { 'fontawesome': 'fa-times' });
    config.addIcon('expand', { 'fontawesome': 'fa-arrows-h' });
    config.addIcon('truncate', { 'fontawesome': 'fa-arrows-h' });

    // Labels
    config.addLabel('undo', {
      en: 'Undo',
      de: 'Rückgängig'
    });
    config.addLabel('redo', {
      en: 'Redo',
      de: 'Wiederherstellen'
    });
    config.addLabel('select-all', {
      en: 'Select All',
      de: 'Alles Auswählen'
    });
    config.addLabel('container-selection', {
      en: 'Container',
      de: 'Container'
    });
    config.addLabel('container', {
      en: 'Container',
      de: 'Container'
    });
    config.addLabel('insert-container', {
      en: 'Insert Container',
      de: 'Container einfügen'
    });

    if (platform.isMac) {
      config.addKeyboardShortcut('cmd+z', { command: 'undo' });
      config.addKeyboardShortcut('cmd+shift+z', { command: 'redo' });
      config.addKeyboardShortcut('cmd+a', { command: 'select-all' });
    } else {
      config.addKeyboardShortcut('ctrl+z', { command: 'undo' });
      config.addKeyboardShortcut('ctrl+shift+z', { command: 'redo' });
      config.addKeyboardShortcut('ctrl+a', { command: 'select-all' });
    }
  }
};

var Blockquote = (function (TextBlock$$1) {
	function Blockquote () {
		TextBlock$$1.apply(this, arguments);
	}if ( TextBlock$$1 ) Blockquote.__proto__ = TextBlock$$1;
	Blockquote.prototype = Object.create( TextBlock$$1 && TextBlock$$1.prototype );
	Blockquote.prototype.constructor = Blockquote;

	

	return Blockquote;
}(TextBlock));

Blockquote.type = "blockquote";

var NodeComponent = (function (Component$$1) {
  function NodeComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) NodeComponent.__proto__ = Component$$1;
  NodeComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  NodeComponent.prototype.constructor = NodeComponent;

  NodeComponent.prototype.render = function render ($$) {
    var tagName = this.getTagName();
    var el = $$(tagName)
      .attr('data-id', this.props.node.id)
      .addClass(this.getClassNames());
    return el
  };

  NodeComponent.prototype.getTagName = function getTagName () {
    return 'div'
  };

  NodeComponent.prototype.getClassNames = function getClassNames () {
    return ''
  };

  return NodeComponent;
}(Component));

function levenshtein(a, b){
  var m = [];
  for(var i = 0; i <= b.length; i++) {
    m[i] = [i];
    if(i === 0) { continue; }
    var ib = i-1;
    for(var j = 0; j <= a.length; j++){
      m[0][j] = j;
      if(j === 0) { continue; }
      var jb = j-1;
      m[i][j] = b.charAt(ib) === a.charAt(jb) ? m[ib][jb] : Math.min(
        m[ib][jb]+1,
        m[i][jb]+1,
        m[ib][j]+1
      );
    }
  }
  return m
}

/*
  Determines a list of changes to transform String a into String b.

  @param {String} a
  @param {String} b
*/
function diff(a, b, offset) {
  if (!isString(a) || !isString(b)) {
    throw new Error('Illegal arguments.')
  }
  offset = offset || 0;
  var changes = [];
  if (a || b) {
    if (!a && b) {
      changes.push({ type:'insert', start:offset, text:b });
    } else if (a && !b) {
      changes.push({ type:'delete', start:offset, end:offset+a.length });
    } else {
      var m = levenshtein(a, b);
      changes = _diff(a, b, m, offset);
    }
  }
  return changes
}

function _diff(a, b, m, offset) {
  var i = b.length;
  var j = a.length;
  var changes = [];
  var current;
  while (i>0 && j>0) {
    _next();
  }
  _commit();
  return changes

  function _next() {
    var d = m[i][j];
    var ib = i-1;
    var jb = j-1;
    // substitute
    if (m[ib][jb]<d) {
      if (current && current.type === 'replace') {
        current.start--;
        current.text.unshift(b.charAt(ib));
      } else {
        _commit();
        current = { type:'replace', start:jb, end:j, text:[b.charAt(ib)] };
      }
      i--;
      j--;
    }
    // insert
    else if (m[ib][j]<d) {
      if (current && current.type === 'insert') {
        current.start--;
        current.text.unshift(b.charAt(ib));
      } else {
        _commit();
        current = { type:'insert', start:jb, text:[b.charAt(ib)] };
      }
      i--;
    }
    // delete char
    else if (m[i][jb]<d) {
      if (current && current.type === 'delete') {
        current.start--;
      } else {
        _commit();
        current = { type:'delete', start:jb, end:j };
      }
      j--;
    }
    // preserve
    else {
      _commit();
      i--;
      j--;
    }
  }

  function _commit() {
    if (current) {
      switch (current.type) {
        case 'insert':
          current.start += offset;
          current.text = current.text.join('');
          break
        case 'delete':
          current.start += offset;
          current.end += offset;
          break
        case 'replace':
          current.start += offset;
          current.end += offset;
          current.text = current.text.join('');
          break
        default:
          throw new Error('Invalid state')
      }
      changes.push(current);
      current = null;
    }
  }

}

/**
  Renders an annotation. Used internally by different components (e.g. ui/AnnotatedTextComponent)

  @class
  @component
  @extends ui/Component

  @prop {Object} doc document
  @prop {Object} node node which describes annotation

  @example

  ```js
  $$(AnnotationComponent, {
    doc: doc,
    node: node
  })
  ```
*/

var AnnotationComponent = (function (Component$$1) {
  function AnnotationComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) AnnotationComponent.__proto__ = Component$$1;
  AnnotationComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  AnnotationComponent.prototype.constructor = AnnotationComponent;

  AnnotationComponent.prototype.didMount = function didMount () {
    var node = this.props.node;
    node.on('highlighted', this.onHighlightedChanged, this);
  };

  // TODO: we should avoid to have a didMount hook on an abstract base class
  AnnotationComponent.prototype.dispose = function dispose () {
    var node = this.props.node;
    node.off(this);
  };

  AnnotationComponent.prototype.render = function render ($$) {
    var el = $$(this.getTagName())
      .attr("data-id", this.props.node.id)
      .addClass(this.getClassNames());
    if (this.props.node.highlighted) {
      el.addClass('sm-highlighted');
    }
    el.append(this.props.children);
    return el
  };

  AnnotationComponent.prototype.getClassNames = function getClassNames () {
    return 'sc-'+this.props.node.type
  };

  AnnotationComponent.prototype.onHighlightedChanged = function onHighlightedChanged () {
    if (this.props.node.highlighted) {
      this.el.addClass('sm-highlighted');
    } else {
      this.el.removeClass('sm-highlighted');
    }
  };

  AnnotationComponent.prototype.getTagName = function getTagName () {
    return 'span'
  };

  return AnnotationComponent;
}(Component));

var AbstractIsolatedNodeComponent = (function (Component$$1) {
  function AbstractIsolatedNodeComponent() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Component$$1.apply(this, args);

    this.name = this.props.node.id;
    this._id = this.context.surface.id +'/'+this.name;
    this._state = {
      selectionFragment: null
    };

    this.handleAction('escape', this.escape);
    this.ContentClass = this._getContentClass(this.props.node) || Component$$1;

    // NOTE: FF does not allow to navigate contenteditable isles
    var useBlocker = platform.isFF || !this.ContentClass.noBlocker;
    this.blockingMode = useBlocker ? 'closed' : 'open';
  }

  if ( Component$$1 ) AbstractIsolatedNodeComponent.__proto__ = Component$$1;
  AbstractIsolatedNodeComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  AbstractIsolatedNodeComponent.prototype.constructor = AbstractIsolatedNodeComponent;

  var prototypeAccessors = { id: {} };

  AbstractIsolatedNodeComponent.prototype.getChildContext = function getChildContext () {
    return {
      isolatedNodeComponent: this,
      // TODO: we should clear 'surface' here
      // so that we know that we are not controlled by a surface
      surface: undefined
    }
  };

  AbstractIsolatedNodeComponent.prototype.getInitialState = function getInitialState () {
    var selState = this.context.editorSession.getSelectionState();
    return this._deriveStateFromSelectionState(selState)
  };

  AbstractIsolatedNodeComponent.prototype.didMount = function didMount () {
    Component$$1.prototype.didMount.call(this);

    var editorSession = this.context.editorSession;
    editorSession.onRender('selection', this._onSelectionChanged, this);
  };

  AbstractIsolatedNodeComponent.prototype.dispose = function dispose () {
    Component$$1.prototype.dispose.call(this);

    var editorSession = this.context.editorSession;
    editorSession.off(this);
  };

  AbstractIsolatedNodeComponent.prototype.renderContent = function renderContent ($$, node, options) {
    if ( options === void 0 ) options = {};

    var ComponentClass = this.ContentClass;
    if (!ComponentClass) {
      console.error('Could not resolve a component for type: ' + node.type);
      return $$(this.__elementTag)
    } else {
      var props = Object.assign({
        disabled: this.props.disabled,
        node: node,
        isolatedNodeState: this.state.mode,
        focused: (this.state.mode === 'focused')
      }, options);
      return $$(ComponentClass, props)
    }
  };

  AbstractIsolatedNodeComponent.prototype.getId = function getId () {
    return this._id
  };

  prototypeAccessors.id.get = function () { return this.getId() };

  AbstractIsolatedNodeComponent.prototype.getMode = function getMode () {
    return this.state.mode
  };

  AbstractIsolatedNodeComponent.prototype.isOpen = function isOpen () {
    return this.blockingMode === 'open'
  };

  AbstractIsolatedNodeComponent.prototype.isClosed = function isClosed () {
    return this.blockingMode === 'closed'
  };

  AbstractIsolatedNodeComponent.prototype.isNotSelected = function isNotSelected () {
    return !this.state.mode
  };

  AbstractIsolatedNodeComponent.prototype.isSelected = function isSelected () {
    return this.state.mode === 'selected'
  };

  AbstractIsolatedNodeComponent.prototype.isCoSelected = function isCoSelected () {
    return this.state.mode === 'co-selected'
  };

  AbstractIsolatedNodeComponent.prototype.isFocused = function isFocused () {
    return this.state.mode === 'focused'
  };

  AbstractIsolatedNodeComponent.prototype.isCoFocused = function isCoFocused () {
    return this.state.mode === 'co-focused'
  };

  AbstractIsolatedNodeComponent.prototype.escape = function escape () {
    // console.log('Escaping from IsolatedNode', this.id)
    this.selectNode();
  };

  AbstractIsolatedNodeComponent.prototype._onSelectionChanged = function _onSelectionChanged () {
    var editorSession = this.context.editorSession;
    var newState = this._deriveStateFromSelectionState(editorSession.getSelectionState());
    if (!newState && this.state.mode) {
      this.extendState({ mode: null });
    } else if (newState && newState.mode !== this.state.mode) {
      this.extendState(newState);
    }
  };

  AbstractIsolatedNodeComponent.prototype.onKeydown = function onKeydown (event) {
    // console.log('####', event.keyCode, event.metaKey, event.ctrlKey, event.shiftKey);
    // TODO: while this works when we have an isolated node with input or CE,
    // there is no built-in way of receiving key events in other cases
    // We need a global event listener for keyboard events which dispatches to the current isolated node
    if (event.keyCode === keys.ESCAPE && this.state.mode === 'focused') {
      event.stopPropagation();
      event.preventDefault();
      this.escape();
    }
  };

  AbstractIsolatedNodeComponent.prototype._getContentClass = function _getContentClass (node) {
    var componentRegistry = this.context.componentRegistry;
    var ComponentClass = componentRegistry.get(node.type);
    return ComponentClass
  };

  AbstractIsolatedNodeComponent.prototype._getSurface = function _getSurface (selState) {
    var surface = selState.get('surface');
    if (surface === undefined) {
      var sel = selState.getSelection();
      if (sel && sel.surfaceId) {
        var surfaceManager = this.context.surfaceManager;
        surface = surfaceManager.getSurface(sel.surfaceId);
      } else {
        surface = null;
      }
      selState.set('surface', surface);
    }
    return surface
  };

  // compute the list of surfaces and isolated nodes
  // for the given selection
  AbstractIsolatedNodeComponent.prototype._getIsolatedNodes = function _getIsolatedNodes (selState) {
    var isolatedNodes = selState.get('isolatedNodes');
    if (!isolatedNodes) {
      var sel = selState.getSelection();
      isolatedNodes = [];
      if (sel && sel.surfaceId) {
        var surfaceManager = this.context.surfaceManager;
        var surface = surfaceManager.getSurface(sel.surfaceId);
        isolatedNodes = surface.getComponentPath().filter(function (comp) { return comp._isAbstractIsolatedNodeComponent; });
      }
      selState.set('isolatedNodes', isolatedNodes);
    }
    return isolatedNodes
  };

  AbstractIsolatedNodeComponent.prototype._shouldConsumeEvent = function _shouldConsumeEvent (event) {
    var comp = Component$$1.unwrap(event.target);
    return (comp && (comp === this || comp.context.isolatedNodeComponent === this))
  };

  Object.defineProperties( AbstractIsolatedNodeComponent.prototype, prototypeAccessors );

  return AbstractIsolatedNodeComponent;
}(Component));

AbstractIsolatedNodeComponent.prototype._isAbstractIsolatedNodeComponent = true;

var InlineNodeComponent = (function (AbstractIsolatedNodeComponent$$1) {
  function InlineNodeComponent () {
    AbstractIsolatedNodeComponent$$1.apply(this, arguments);
  }

  if ( AbstractIsolatedNodeComponent$$1 ) InlineNodeComponent.__proto__ = AbstractIsolatedNodeComponent$$1;
  InlineNodeComponent.prototype = Object.create( AbstractIsolatedNodeComponent$$1 && AbstractIsolatedNodeComponent$$1.prototype );
  InlineNodeComponent.prototype.constructor = InlineNodeComponent;

  InlineNodeComponent.prototype.render = function render ($$) {
    var node = this.props.node;
    var ContentClass = this.ContentClass;

    var el = $$('span');
    el.addClass(this.getClassNames())
      .addClass('sc-inline-node')
      .addClass('sm-'+this.props.node.type)
      .attr("data-id", node.id)
      .attr('data-inline', '1');

    var disabled = this.isDisabled();

    if (this.state.mode) {
      el.addClass('sm-'+this.state.mode);
    } else {
      el.addClass('sm-not-selected');
    }

    if (!ContentClass.noStyle) {
      el.addClass('sm-default-style');
    }

    // shadowing handlers of the parent surface
    // TODO: extract this into a helper so that we can reuse it anywhere where we want
    // to prevent propagation to the parent surface
    el.on('keydown', this.onKeydown);

    el.append(
      this.renderContent($$, node)
        .ref('content')
        .addClass('se-content')
    );

    if (disabled) {
      el.addClass('sm-disabled')
         .attr('contenteditable', false)
         .on('click', this.onClick);
    }

    el.attr('draggable', true);
    return el
  };

  InlineNodeComponent.prototype.isDisabled = function isDisabled () {
    return !this.state.mode || ['co-selected', 'cursor'].indexOf(this.state.mode) > -1;
  };

  InlineNodeComponent.prototype.getClassNames = function getClassNames () {
    return ''
  };

  InlineNodeComponent.prototype.onClick = function onClick (event) {
    if (!this._shouldConsumeEvent(event)) { return }
    this.selectNode();
  };

  InlineNodeComponent.prototype.selectNode = function selectNode () {
    // console.log('IsolatedNodeComponent: selecting node.');
    var editorSession = this.context.editorSession;
    var surface = this.context.surface;
    var node = this.props.node;
    editorSession.setSelection({
      type: 'property',
      path: node.start.path,
      startOffset: node.start.offset,
      endOffset: node.end.offset,
      containerId: surface.getContainerId(),
      surfaceId: surface.id
    });
  };

  // TODO: this is almost the same as in InlineNodeComponent
  // We should try to consolidate this
  InlineNodeComponent.prototype._deriveStateFromSelectionState = function _deriveStateFromSelectionState (selState) {
    var surface = this._getSurface(selState);
    if (!surface) { return null }
    // detect cases where this node is selected or co-selected by inspecting the selection
    if (surface === this.context.surface) {
      var sel = selState.getSelection();
      var node = this.props.node;
      if (sel.isPropertySelection() && !sel.isCollapsed() && isEqual(sel.path, node.path)) {
        var nodeSel = node.getSelection();
        if(nodeSel.equals(sel)) {
          return { mode: 'selected' }
        }
        if (sel.contains(nodeSel)) {
          return { mode: 'co-selected' }
        }
      }
    }
    var isolatedNodeComponent = surface.context.isolatedNodeComponent;
    if (!isolatedNodeComponent) { return null }
    if (isolatedNodeComponent === this) {
      return { mode: 'focused' }
    }
    var isolatedNodes = this._getIsolatedNodes(selState);
    if (isolatedNodes.indexOf(this) > -1) {
      return { mode: 'co-focused' }
    }
    return null
  };

  return InlineNodeComponent;
}(AbstractIsolatedNodeComponent));

InlineNodeComponent.prototype._isInlineNodeComponent = true;

/**
  Renders an anotated text. Used internally by {@link ui/TextPropertyComponent}.

  @class
  @component
  @extends ui/Component

  @prop {String[]} path The property to be rendered.
*/

var AnnotatedTextComponent = (function (Component$$1) {
  function AnnotatedTextComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) AnnotatedTextComponent.__proto__ = Component$$1;
  AnnotatedTextComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  AnnotatedTextComponent.prototype.constructor = AnnotatedTextComponent;

  AnnotatedTextComponent.prototype.render = function render ($$) {
    var el = this._renderContent($$)
      .addClass('sc-annotated-text')
      .css({ whiteSpace: "pre-wrap" });
    return el
  };

  AnnotatedTextComponent.prototype.getText = function getText () {
    return this.getDocument().get(this.props.path) || ''
  };

  AnnotatedTextComponent.prototype.getAnnotations = function getAnnotations () {
    return this.getDocument().getIndex('annotations').get(this.props.path)
  };

  AnnotatedTextComponent.prototype._getTagName = function _getTagName () {
    return this.props.tagName
  };

  AnnotatedTextComponent.prototype._onDocumentChange = function _onDocumentChange (update) {
    if (update.change && update.change.updated[this.getPath()]) {
      this.rerender();
    }
  };

  AnnotatedTextComponent.prototype._renderContent = function _renderContent ($$) {
    var text = this.getText();
    var annotations = this.getAnnotations();
    var el = $$(this._getTagName() || 'span');
    if (annotations && annotations.length > 0) {
      var fragmenter = new Fragmenter({
        onText: this._renderTextNode.bind(this),
        onEnter: this._renderFragment.bind(this, $$),
        onExit: this._finishFragment.bind(this)
      });
      fragmenter.start(el, text, annotations);
    } else {
      el.append(text);
    }
    return el
  };

  AnnotatedTextComponent.prototype._renderTextNode = function _renderTextNode (context, text) {
    if (text && text.length > 0) {
      context.append(text);
    }
  };

  AnnotatedTextComponent.prototype._renderFragment = function _renderFragment ($$, fragment) {
    var doc = this.getDocument();
    var componentRegistry = this.getComponentRegistry();
    var node = fragment.node;
    // TODO: fix support for container annotations
    if (node.type === "container-annotation-fragment") {
      // return $$(AnnotationComponent, { doc: doc, node: node })
      //   .addClass("se-annotation-fragment")
      //   .addClass(node.anno.getTypeNames().join(' ').replace(/_/g, "-"));
    } else if (node.type === "container-annotation-anchor") {
      // return $$(AnnotationComponent, { doc: doc, node: node })
      //   .addClass("se-anchor")
      //   .addClass(node.anno.getTypeNames().join(' ').replace(/_/g, "-"))
      //   .addClass(node.isStart?"start-anchor":"end-anchor")
    } else {
      var ComponentClass = componentRegistry.get(node.type) || AnnotationComponent;
      if (node.constructor.isInline &&
          // also no extra wrapping if the node is already an inline node
          !ComponentClass.prototype._isInlineNodeComponent &&
          // opt-out for custom implementations
          !ComponentClass.isCustom) {
        ComponentClass = InlineNodeComponent;
      }
      var el = $$(ComponentClass, { doc: doc, node: node });
      return el
    }
  };

  AnnotatedTextComponent.prototype._finishFragment = function _finishFragment (fragment, context, parentContext) {
    parentContext.append(context);
  };

  /**
    Gets document instance.

    @return {Document} The document instance
   */
  AnnotatedTextComponent.prototype.getDocument = function getDocument () {
    return this.props.doc || this.context.doc
  };

  return AnnotatedTextComponent;
}(Component));

var CursorComponent = (function (Component$$1) {
  function CursorComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) CursorComponent.__proto__ = Component$$1;
  CursorComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  CursorComponent.prototype.constructor = CursorComponent;

  CursorComponent.prototype.render = function render ($$) {
    // TODO: we should rename se-cursor to sc-cursor
    var el = $$('span').addClass('se-cursor');
    // Add zero-width character. Since we have a non-empty element, the
    // outline style set on the cursor would not be visible in certain
    // scenarios (e.g. when cursor is at the very beginning of a text.
    el.append("\uFEFF");
    el.append($$('div').addClass('se-cursor-inner'));

    if (this.props.collaborator) {
      var collaboratorIndex = this.props.collaborator.colorIndex;
      el.addClass('sm-collaborator-'+collaboratorIndex);
    } else {
      el.addClass('sm-local-user');
    }

    return el
  };

  return CursorComponent;
}(Component));

var SelectionFragmentComponent = (function (Component$$1) {
  function SelectionFragmentComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) SelectionFragmentComponent.__proto__ = Component$$1;
  SelectionFragmentComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  SelectionFragmentComponent.prototype.constructor = SelectionFragmentComponent;

  SelectionFragmentComponent.prototype.render = function render ($$) {
    // TODO: we should rename se-cursor to sc-cursor
    var el = $$('span').addClass('se-selection-fragment');
    if (this.props.collaborator) {
      var collaboratorIndex = this.props.collaborator.colorIndex;
      el.addClass('sm-collaborator-'+collaboratorIndex);
    } else {
      el.addClass('sm-local-user');
    }
    el.append(this.props.children);
    return el
  };

  return SelectionFragmentComponent;
}(Component));

/**
  Renders a text property. Used internally by different components to render
  editable text.

  @class
  @component
  @extends ui/AnnotatedTextComponent

  @prop {String[]} path path to a text property
  @prop {String} [tagName] specifies which tag should be used - defaults to `div`

  @example

  ```js
  $$(TextProperty, {
    path: [ 'paragraph-1', 'content']
  })
  ```
*/

var TextPropertyComponent = (function (AnnotatedTextComponent$$1) {
  function TextPropertyComponent () {
    AnnotatedTextComponent$$1.apply(this, arguments);
  }

  if ( AnnotatedTextComponent$$1 ) TextPropertyComponent.__proto__ = AnnotatedTextComponent$$1;
  TextPropertyComponent.prototype = Object.create( AnnotatedTextComponent$$1 && AnnotatedTextComponent$$1.prototype );
  TextPropertyComponent.prototype.constructor = TextPropertyComponent;

  TextPropertyComponent.prototype.getInitialState = function getInitialState () {
    var markersManager = this.context.markersManager;
    var path = this.props.path;
    var markers;
    if (markersManager) {
      // register and get initial set of markers
      markersManager.register(this);
      markers = markersManager.getMarkers(path, {
        surfaceId: this.getSurfaceId(),
        containerId: this.getContainerId()
      });
    } else {
      var doc = this.getDocument();
      markers = doc.getAnnotations(path);
    }
    return {
      markers: markers
    }
  };

  TextPropertyComponent.prototype.didMount = function didMount () {
    if (this.context.surface && this.context.surface.hasNativeSpellcheck()) {
      this.domObserver = new window.MutationObserver(this._onDomMutations.bind(this));
      this.domObserver.observe(this.el.getNativeElement(), { subtree: true, characterData: true, characterDataOldValue: true });
    }
  };

  TextPropertyComponent.prototype.dispose = function dispose () {
    if (this.context.markersManager) {
      this.context.markersManager.deregister(this);
    }
  };

  TextPropertyComponent.prototype.render = function render ($$) {
    var path = this.getPath();

    var el = this._renderContent($$)
      .addClass('sc-text-property')
      .attr({
        'data-path': path.join('.')
      })
      .css({
        'white-space': 'pre-wrap'
      });

    if (!this.props.withoutBreak) {
      el.append($$('br'));
    }
    return el
  };

  TextPropertyComponent.prototype.getAnnotations = function getAnnotations () {
    return this.state.markers
  };

  TextPropertyComponent.prototype._renderFragment = function _renderFragment ($$, fragment) {
    var node = fragment.node;
    var id = node.id;
    var el;
    if (node.type === 'cursor') {
      el = $$(CursorComponent, { collaborator: node.collaborator });
    } else if (node.type === 'selection-fragment') {
      el = $$(SelectionFragmentComponent, { collaborator: node.collaborator });
    } else {
      el = AnnotatedTextComponent$$1.prototype._renderFragment.apply(this, arguments);
      el.ref(id + '@' + fragment.counter);
      // NOTE: before we only preserved inline nodes, or if configured explicitly
      // now the performance seems good enough to do this all the time.
      // if (node.constructor.isInline) {
      //   el.ref(id)
      // }
      // Adding refs here, enables preservative rerendering
      // TODO: while this solves problems with rerendering inline nodes
      // with external content, it decreases the overall performance too much.
      // We should optimize the component first before we can enable this.
      // else if (this.context.config && this.context.config.preservativeTextPropertyRendering) {
      //   el.ref(id + '@' + fragment.counter)
      // }
    }
    el.attr('data-offset', fragment.pos);
    return el
  };

  TextPropertyComponent.prototype._onDomMutations = function _onDomMutations (mutations) {
    // HACK: only detecting mutations that are coming from the native spell-correction
    if (mutations.length === 2 && mutations[0].target === mutations[1].target) {
      var textEl = mutations[0].target._wrapper;
      if (textEl) {
        this._applyTextMutation(textEl, mutations[0].oldValue);
        return
      }
    }
    // in all other cases, revert the change by rerendering
    this.rerender();
  };

  TextPropertyComponent.prototype._applyTextMutation = function _applyTextMutation (textEl, oldText) {
    // find the offset
    var offset = _getCharPos(textEl, 0);
    var newText = textEl.textContent;
    var changes = diff(oldText, newText, offset);

    var editorSession = this.context.editorSession;
    var path = this.getPath();
    editorSession.transaction(function(tx) {
      changes.forEach(function(change) {
        // NOTE: atomic text replace is not supported currently
        if (change.type === 'replace') {
          tx.update(path, { type: 'delete', start: change.start, end: change.end });
          tx.update(path, { type: 'insert', start: change.start, text: change.text });
        } else {
          tx.update(path, change);
        }
      });
    });
  };

  TextPropertyComponent.prototype.getPath = function getPath () {
    return this.props.path
  };

  TextPropertyComponent.prototype.getText = function getText () {
    return this.getDocument().get(this.getPath())
  };

  TextPropertyComponent.prototype.getDocument = function getDocument () {
    return this.props.doc ||this.context.doc
  };

  TextPropertyComponent.prototype.getSurface = function getSurface () {
    return this.props.surface || this.context.surface
  };

  TextPropertyComponent.prototype.getSurfaceId = function getSurfaceId () {
    var surface = this.getSurface();
    return surface ? surface.id : null
  };

  TextPropertyComponent.prototype.getContainerId = function getContainerId () {
    var surface = this.getSurface();
    return surface ? surface.getContainerId() : null
  };

  TextPropertyComponent.prototype.isEditable = function isEditable () {
    return this.getSurface().isEditable()
  };

  TextPropertyComponent.prototype.isReadonly = function isReadonly () {
    return this.getSurface().isReadonly()
  };

  TextPropertyComponent.prototype.getDOMCoordinate = function getDOMCoordinate (charPos) {
    return this._getDOMCoordinate(this.el, charPos)
  };


  TextPropertyComponent.prototype._finishFragment = function _finishFragment (fragment, context, parentContext) {
    context.attr('data-length', fragment.length);
    parentContext.append(context);
  };

  TextPropertyComponent.prototype._getDOMCoordinate = function _getDOMCoordinate (el, charPos) {
    var this$1 = this;

    var l;
    var idx = 0;
    if (charPos === 0) {
      return {
        container: el.getNativeElement(),
        offset: 0
      }
    }
    for (var child = el.getFirstChild(); child; child = child.getNextSibling(), idx++) {
      if (child.isTextNode()) {
        l = child.textContent.length;
        if (l >= charPos) {
          return {
            container: child.getNativeElement(),
            offset: charPos
          }
        } else {
          charPos -= l;
        }
      } else if (child.isElementNode()) {
        var length = child.getAttribute('data-length');
        if (length) {
          l = parseInt(length, 10);
          if (l >= charPos) {
            // special handling for InlineNodes
            if (child.attr('data-inline')) {
              var nextSibling = child.getNextSibling();
              if (nextSibling && nextSibling.isTextNode()) {
                return {
                  container: nextSibling.getNativeElement(),
                  offset: 0
                }
              } else {
                return {
                  container: el.getNativeElement(),
                  offset: el.getChildIndex(child) + 1
                }
              }
            }
            return this$1._getDOMCoordinate(child, charPos, idx)
          } else {
            charPos -= l;
          }
        } else {
          console.error('FIXME: Can not map to DOM coordinates.');
          return null
        }
      }
    }
  };

  return TextPropertyComponent;
}(AnnotatedTextComponent));

TextPropertyComponent.prototype._isTextPropertyComponent = true;


// Helpers for DOM selection mapping

/*
  Used to map from DOM to model.
  Given a root element and a DOM element - which is typically somewhere inside a surface
  it tries to find the next TextProperty by walking up the DOM.
  If found it computes the character position, counting chars and using the hints, data-length and data-offset,
  rendered by the TextPropertyComponent
*/
TextPropertyComponent.getCoordinate = function(root, el, offset) {
  var context = _getPropertyContext(root, el, offset);
  if (!context) {
    return null
  }
  // in some cases we need to normalize the DOM coordinate
  // before we can use it for retrieving charPos
  // E.g. observed with #273
  var charPos = _getCharPos(context.node, context.offset);
  if (isNumber(charPos)) {
    var coor = new Coordinate(context.path, charPos);
    coor._comp = context.comp;
    return coor
  } else {
    return null
  }
};

function _getPropertyContext(root, node, offset) {
  var result = {
    comp: null,
    el: null,
    path: null,
    node: node,
    offset: offset
  };
  while (node && node !== root) {
    if (node.isElementNode()) {
      var comp = Component.unwrap(node);
      if (comp && comp._isTextPropertyComponent) {
        result.comp = comp;
        result.el = node;
        result.path = comp.getPath();
        return result;
      }
      // we need to normalize situations where the DOM coordinate
      // is inside an inline node, which we have observed
      // can actually happen.
      if (node.getAttribute('data-inline')) {
        result.node = node;
        if (offset > 0) {
          result.offset = 1;
        }
      }
    }
    node = node.getParent();
  }
  return null
}

function _getCharPos(node, offset) {
  var charPos = offset;
  var parent, childIdx;

  /*
    In the following implementation we are exploiting two facts
    for optimization:
    - an element with data-path is assumed to be the text property element
    - an element with data-offset is assumed to be an annotation element

    Particularly, the data-offset property is helpful to get the character position
    in just one iteration.
  */

  parent = node.getParent();
  if (node.isTextNode()) {
    // TextNode is first child
    if (node === parent.firstChild) {
      // ... we can stop if parent is text property
      var parentPath = parent.getAttribute('data-path');
      var parentOffset = parent.getAttribute('data-offset');
      if (parentPath) {
        charPos = offset;
      }
      // ... and we can stop if parent has an offset hint
      else if (parentOffset) {
        charPos = parseInt(parentOffset, 10) + offset;
      }
      // ... otherwise we count the charPos by recursing up-tree
      else {
        charPos = _getCharPos(parent, 0) + offset;
      }
    } else {
      // the node has a predecessor so we can apply recurse using the child index
      childIdx = parent.getChildIndex(node);
      charPos = _getCharPos(parent, childIdx) + offset;
    }
  } else if (node.isElementNode()) {
    var pathStr = node.getAttribute('data-path');
    var offsetStr = node.getAttribute('data-offset');
    // if node is the element of a text property, then offset is a child index
    // up to which we need to sum up all lengths
    if (pathStr) {
      charPos = _countCharacters(node, offset);
    }
    // similar if node is the element of an annotation, and we can use the
    // element's offset
    else if (offsetStr) {
      childIdx = parent.getChildIndex(node);
      charPos = parseInt(offsetStr, 10) + _countCharacters(node, offset);
    }
    // for other elements we need to count characters in the child tree
    // adding the offset of this element which needs to be computed by recursing up-tree
    else {
      childIdx = parent.getChildIndex(node);
      charPos = _getCharPos(parent, childIdx) + _countCharacters(node, offset);
    }
  } else {
    // Unsupported case
    return null
  }
  return charPos;
}

function _countCharacters(el, maxIdx) {
  var charPos = 0;
  // inline elements have a length of 1
  if (el.getAttribute('data-inline')) {
    return maxIdx === 0 ? 0 : 1;
  }
  var l = el.getChildCount();
  if (arguments.length === 1) {
    maxIdx = l;
  }
  maxIdx = Math.min(l, maxIdx);
  for (var i=0, child = el.getFirstChild(); i < maxIdx; child = child.getNextSibling(), i++) {
    if (child.isTextNode()) {
      charPos += child.getTextContent().length;
    } else if (child.isElementNode()) {
      var length = child.getAttribute('data-length');
      if (child.getAttribute('data-inline')) {
        charPos += 1;
      } else if (length) {
        charPos += parseInt(length, 10);
      } else {
        charPos += _countCharacters(child);
      }
    }
  }
  return charPos
}

var TextBlockComponent = (function (NodeComponent$$1) {
  function TextBlockComponent () {
    NodeComponent$$1.apply(this, arguments);
  }

  if ( NodeComponent$$1 ) TextBlockComponent.__proto__ = NodeComponent$$1;
  TextBlockComponent.prototype = Object.create( NodeComponent$$1 && NodeComponent$$1.prototype );
  TextBlockComponent.prototype.constructor = TextBlockComponent;

  TextBlockComponent.prototype.render = function render ($$) {
    var el = NodeComponent$$1.prototype.render.call(this, $$);
    el.addClass('sc-text-block');

    var node = this.props.node;
    // NOTE: we are not using the native text direction support as it changes the contenteditable behavior in a weird way
    // instead rtl text is supported on model level
    if (node.direction) {
      // el.attr('data-direction', node.direction)
      el.attr('dir', node.direction);
    }
    el.append($$(TextPropertyComponent, {
      path: node.getTextPath(),
      direction: node.direction
    }));
    return el
  };

  return TextBlockComponent;
}(NodeComponent));

/*
 * HTML converter for Blockquote.
 */

var Code = (function (PropertyAnnotation$$1) {
	function Code () {
		PropertyAnnotation$$1.apply(this, arguments);
	}if ( PropertyAnnotation$$1 ) Code.__proto__ = PropertyAnnotation$$1;
	Code.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
	Code.prototype.constructor = Code;

	

	return Code;
}(PropertyAnnotation));

Code.type = 'code';

/*
 * HTML converter for Code.
 */

/**
  A class for commands intended to be executed on the annotations.

  See the example below to learn how to register an `AnnotationCommand`
  for a strong annotation.

  @class AnnotationCommand
  @extends ui/Command

  @example

  ```js
  import { AnnotationCommand } from 'substance'

  config.addCommand('strong', AnnotationCommand, {nodeType: 'strong'})
  // Disable, when cursor is collapsed
  config.addCommand('strong', AnnotationCommand, {
    nodeType: 'strong',
    disableCollapsedCursor: true
  })
  ```
*/

var AnnotationCommand = (function (Command$$1) {
  function AnnotationCommand() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Command$$1.apply(this, args);

    if (!this.config.nodeType) {
      throw new Error("'nodeType' is required")
    }
  }

  if ( Command$$1 ) AnnotationCommand.__proto__ = Command$$1;
  AnnotationCommand.prototype = Object.create( Command$$1 && Command$$1.prototype );
  AnnotationCommand.prototype.constructor = AnnotationCommand;

  /**
    Get the type of an annotation.

    @returns {String} The annotation's type.
   */
  AnnotationCommand.prototype.getAnnotationType = function getAnnotationType () {
    return this.config.nodeType
  };

  /**
    Get the annotation's data.

    @returns {Object} The annotation's data.
   */
  AnnotationCommand.prototype.getAnnotationData = function getAnnotationData () {
    return {}
  };

  /**
    Checks if command couldn't be executed with current selection.

    @param {Array} annos annotations
    @param {Object} sel selection

    @returns {Boolean} Whether or not command could be executed.
   */
  AnnotationCommand.prototype.isDisabled = function isDisabled (sel) {
    // TODO: Container selections should be valid if the annotation type
    // is a container annotation. Currently we only allow property selections.
    if (!sel || sel.isNull() || !sel.isAttached() || sel.isCustomSelection()||
        sel.isNodeSelection() || sel.isContainerSelection()) {
      return true
    }

    if (this.config.disableCollapsedCursor && sel.isCollapsed()) {
      return true
    }

    return false
  };

  /**
    Checks if new annotations could be created.
    There should be no annotation overlapping, selection must be not collapsed.

    @param {Array} annos annotations
    @param {Object} sel selection

    @returns {Boolean} Whether or not annotation could be created.
   */
  // When there's no existing annotation overlapping, we create a new one.
  AnnotationCommand.prototype.canCreate = function canCreate (annos, sel) {
    return (annos.length === 0 && !sel.isCollapsed())
  };

  /**
    Checks if annotations could be fused.
    There should be more than one annotation overlaped by current selection.

    @param {Array} annos annotations
    @param {Object} sel selection

    @returns {Boolean} Whether or not annotations could be fused.
   */
  AnnotationCommand.prototype.canFuse = function canFuse (annos, sel) {
    // When more than one annotation overlaps with the current selection
    return (annos.length >= 2 && !sel.isCollapsed())
  };

  /**
    Checks if annotation could be deleted.
    Cursor or selection must be inside an existing annotation.

    @param {Array} annos annotations
    @param {Object} sel selection

    @returns {Boolean} Whether or not annotation could be deleted.
   */
  AnnotationCommand.prototype.canDelete = function canDelete (annos, sel) {
    // When the cursor or selection is inside an existing annotation
    if (annos.length !== 1) { return false }
    var annoSel = annos[0].getSelection();
    return sel.isInsideOf(annoSel)
  };

  /**
    Checks if annotation could be expanded.
    There should be overlap with only a single annotation,
    selection should be also outside of this annotation.

    @param {Array} annos annotations
    @param {Object} sel selection

    @returns {Boolean} Whether or not annotation could be expanded.
   */
  AnnotationCommand.prototype.canExpand = function canExpand (annos, sel) {
    // When there's some overlap with only a single annotation we do an expand
    if (annos.length !== 1) { return false }
    var annoSel = annos[0].getSelection();
    return sel.overlaps(annoSel) && !sel.isInsideOf(annoSel)
  };

  /**
    Checks if annotation could be truncated.
    There should be overlap with only a single annotation,
    selection should also have boundary in common with this annotation.

    @param {Array} annos annotations
    @param {Object} sel selection

    @returns {Boolean} Whether or not annotation could be truncated.
   */
  AnnotationCommand.prototype.canTruncate = function canTruncate (annos, sel) {
    if (annos.length !== 1) { return false }
    var annoSel = annos[0].getSelection();

    return (sel.isLeftAlignedWith(annoSel) || sel.isRightAlignedWith(annoSel)) &&
           !sel.contains(annoSel) &&
           !sel.isCollapsed()
  };

  /**
    Gets command state object.

    @param {Object} state.selection the current selection
    @returns {Object} info object with command details.
  */
  AnnotationCommand.prototype.getCommandState = function getCommandState (params) { // eslint-disable-line

    var sel = this._getSelection(params);
    // We can skip all checking if a disabled condition is met
    // E.g. we don't allow toggling of property annotations when current
    // selection is a container selection
    if (this.isDisabled(sel)) {
      return {
        disabled: true
      }
    }
    var annos = this._getAnnotationsForSelection(params);
    var newState = {
      disabled: false,
      active: false,
      mode: null
    };
    if (this.canCreate(annos, sel)) {
      newState.mode = 'create';
    } else if (this.canFuse(annos, sel)) {
      newState.mode = 'fuse';
    } else if (this.canTruncate(annos, sel)) {
      newState.active = true;
      newState.mode = 'truncate';
    } else if (this.canExpand(annos, sel)) {
      newState.mode = 'expand';
    } else if (this.canDelete(annos, sel)) {
      newState.active = true;
      newState.mode = 'delete';
    } else {
      newState.disabled = true;
    }
    return newState
  };

  /**
    Execute command and trigger transformation.

    @returns {Object} info object with execution details.
  */
  // Execute command and trigger transformations
  AnnotationCommand.prototype.execute = function execute (params) {
    // Disabled the next line as I believe it is
    // always passed via params already
    // params.selection = this._getSelection(params)
    var commandState = params.commandState;

    if (commandState.disabled) { return false }
    switch(commandState.mode) {
      case 'create':
        return this.executeCreate(params)
      case 'fuse':
        return this.executeFuse(params)
      case 'truncate':
        return this.executeTruncate(params)
      case 'expand':
        return this.executeExpand(params)
      case 'delete':
        return this.executeDelete(params)
      default:
        console.warn('Command.execute(): unknown mode', commandState.mode);
        return false
    }
  };

  AnnotationCommand.prototype.executeCreate = function executeCreate (params) {
    var annos = this._getAnnotationsForSelection(params);
    this._checkPrecondition(params, annos, this.canCreate);
    var editorSession = this._getEditorSession(params);
    var annoData = this.getAnnotationData();
    annoData.type = this.getAnnotationType();
    var anno;
    editorSession.transaction(function (tx) {
      anno = tx.annotate(annoData);
    });
    return {
      mode: 'create',
      anno: anno
    }
  };

  AnnotationCommand.prototype.executeFuse = function executeFuse (params) {
    var annos = this._getAnnotationsForSelection(params);
    this._checkPrecondition(params, annos, this.canFuse);
    this._applyTransform(params, function(tx) {
      annotationHelpers.fuseAnnotation(tx, annos);
    });
    return {
      mode: 'fuse',
      anno: annos[0]
    }
  };

  AnnotationCommand.prototype.executeTruncate = function executeTruncate (params) {
    var annos = this._getAnnotationsForSelection(params);
    var anno = annos[0];
    this._checkPrecondition(params, annos, this.canTruncate);
    this._applyTransform(params, function(tx) {
      annotationHelpers.truncateAnnotation(tx, anno, params.selection);
    });
    return {
      mode: 'truncate',
      anno: anno
    }
  };

  AnnotationCommand.prototype.executeExpand = function executeExpand (params) {
    var annos = this._getAnnotationsForSelection(params);
    var anno = annos[0];
    this._checkPrecondition(params, annos, this.canExpand);
    this._applyTransform(params, function(tx) {
      annotationHelpers.expandAnnotation(tx, anno, params.selection);
    });
    return {
      mode: 'expand',
      anno: anno
    }
  };

  AnnotationCommand.prototype.executeDelete = function executeDelete (params) {
    var annos = this._getAnnotationsForSelection(params);
    var anno = annos[0];
    this._checkPrecondition(params, annos, this.canDelete);
    this._applyTransform(params, function(tx) {
      return tx.delete(anno.id)
    });
    return {
      mode: 'delete',
      annoId: anno.id
    }
  };

  AnnotationCommand.prototype._checkPrecondition = function _checkPrecondition (params, annos, checker) {
    var sel = this._getSelection(params);
    if (!checker.call(this, annos, sel)) {
      throw new Error("AnnotationCommand: can't execute command for selection " + sel.toString())
    }
  };

  AnnotationCommand.prototype._getAnnotationsForSelection = function _getAnnotationsForSelection (params) {
    return params.selectionState.getAnnotationsForType(this.getAnnotationType())
  };

  /**
    Apply an annotation transformation.

    @returns {Object} transformed annotations.
   */
  AnnotationCommand.prototype._applyTransform = function _applyTransform (params, transformFn) {
    var sel = this._getSelection(params);
    if (sel.isNull()) { return }

    var editorSession = this._getEditorSession(params);
    var result; // to store transform result
    editorSession.setSelection(sel);
    editorSession.transaction(function(tx) {
      var out = transformFn(tx, params);
      if (out) { result = out.result; }
    });
    return result
  };

  return AnnotationCommand;
}(Command));

/**

  Reuseable AnnotationTool component. Can be used without modification
  for pure marker annotations that don't carry data. E.g. strong, emphasis,
  superscript, etc.

  @class
  @component

  @example

  ```
  config.addTool('strong', AnnotationTool, {
    target: 'annotations'
  })
  ```
*/

var AnnotationTool = (function (Tool$$1) {
  function AnnotationTool () {
    Tool$$1.apply(this, arguments);
  }

  if ( Tool$$1 ) AnnotationTool.__proto__ = Tool$$1;
  AnnotationTool.prototype = Object.create( Tool$$1 && Tool$$1.prototype );
  AnnotationTool.prototype.constructor = AnnotationTool;

  AnnotationTool.prototype.render = function render ($$) {
    var el = Tool$$1.prototype.render.call(this, $$);
    el.addClass('sm-annotation-tool');
    return el
  };

  AnnotationTool.prototype.renderButton = function renderButton ($$) {
    var el = Tool$$1.prototype.renderButton.call(this, $$);
    el.append(this.renderMode($$));
    return el
  };

  /*
    Renders a small hint for the mode (expand, truncate, edit, etc)
  */
  AnnotationTool.prototype.renderMode = function renderMode ($$) {
    var mode = this.props.mode;
    var el = $$('div').addClass('se-mode');

    var iconEl = this.context.iconProvider.renderIcon($$, mode);
    if (iconEl) {
      el.append(iconEl);
    }
    return el
  };

  return AnnotationTool;
}(Tool));

var Codeblock = (function (TextBlock$$1) {
	function Codeblock () {
		TextBlock$$1.apply(this, arguments);
	}if ( TextBlock$$1 ) Codeblock.__proto__ = TextBlock$$1;
	Codeblock.prototype = Object.create( TextBlock$$1 && TextBlock$$1.prototype );
	Codeblock.prototype.constructor = Codeblock;

	

	return Codeblock;
}(TextBlock));

Codeblock.type = "codeblock";

var CodeblockComponent = (function (TextBlockComponent$$1) {
  function CodeblockComponent () {
    TextBlockComponent$$1.apply(this, arguments);
  }

  if ( TextBlockComponent$$1 ) CodeblockComponent.__proto__ = TextBlockComponent$$1;
  CodeblockComponent.prototype = Object.create( TextBlockComponent$$1 && TextBlockComponent$$1.prototype );
  CodeblockComponent.prototype.constructor = CodeblockComponent;

  CodeblockComponent.prototype.render = function render ($$) {
    var el = TextBlockComponent$$1.prototype.render.call(this, $$);
    return el.addClass('sc-codeblock')
  };

  return CodeblockComponent;
}(TextBlockComponent));

/*
 * HTML converter for Codeblock.
 */
var CodeblockHTMLConverter = {

  type: 'codeblock',
  tagName: 'pre',

  import: function(el, node, converter) {
    var codeEl = el.find('code');
    if (codeEl) {
      node.content = converter.annotatedText(codeEl, [node.id, 'content'], { preserveWhitespace: true });
    }
  },

  export: function(node, el, converter) {
    var $$ = converter.$$;
    el.append(
      $$('code').append(
        converter.annotatedText([node.id, 'content'])
      )
    );
  }

};

var CodeblockPackage = {
  name: 'codeblock',
  configure: function(config) {
    config.addNode(Codeblock);
    config.addComponent('codeblock', CodeblockComponent);
    config.addConverter('html', CodeblockHTMLConverter);
    config.addConverter('xml', CodeblockHTMLConverter);
    config.addTextType({
      name: 'codeblock',
      data: {type: 'codeblock'}
    });
    config.addLabel('codeblock', {
      en: 'Codeblock',
      de: 'Codeblock'
    });
  },
  Codeblock: Codeblock,
  CodeblockComponent: CodeblockComponent,
  CodeblockHTMLConverter: CodeblockHTMLConverter
};

var Emphasis = (function (PropertyAnnotation$$1) {
	function Emphasis () {
		PropertyAnnotation$$1.apply(this, arguments);
	}if ( PropertyAnnotation$$1 ) Emphasis.__proto__ = PropertyAnnotation$$1;
	Emphasis.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
	Emphasis.prototype.constructor = Emphasis;

	

	return Emphasis;
}(PropertyAnnotation));

Emphasis.type = "emphasis";

// hint for rendering in presence of overlapping annotations
Emphasis.fragmentation = Fragmenter.ANY;

/*
 * HTML converter for Blockquote.
 */
var EmphasisHTMLConverter = {

  type: 'emphasis',
  tagName: 'em',

  matchElement: function(el) {
    return el.is('em, i')
  }

};

var EmphasisComponent = (function (AnnotationComponent$$1) {
  function EmphasisComponent () {
    AnnotationComponent$$1.apply(this, arguments);
  }

  if ( AnnotationComponent$$1 ) EmphasisComponent.__proto__ = AnnotationComponent$$1;
  EmphasisComponent.prototype = Object.create( AnnotationComponent$$1 && AnnotationComponent$$1.prototype );
  EmphasisComponent.prototype.constructor = EmphasisComponent;

  EmphasisComponent.prototype.getTagName = function getTagName () {
    return 'em'
  };

  return EmphasisComponent;
}(AnnotationComponent));

var EmphasisPackage = {
  name: 'emphasis',
  configure: function(config, ref) {
    var toolGroup = ref.toolGroup;
    var disableCollapsedCursor = ref.disableCollapsedCursor;

    config.addNode(Emphasis);
    config.addConverter('html', EmphasisHTMLConverter);
    config.addConverter('xml', EmphasisHTMLConverter);
    config.addComponent('emphasis', EmphasisComponent);
    config.addCommand('emphasis', AnnotationCommand, {
      nodeType: Emphasis.type,
      disableCollapsedCursor: disableCollapsedCursor
    });
    config.addTool('emphasis', AnnotationTool, {
      toolGroup: toolGroup || 'annotations'
    });
    config.addIcon('emphasis', { 'fontawesome': 'fa-italic' });
    config.addLabel('emphasis', {
      en: 'Emphasis',
      de: 'Betonung'
    });
    if (platform.isMac) {
      config.addKeyboardShortcut('cmd+i', { command: 'emphasis' });
    } else {
      config.addKeyboardShortcut('ctrl+i', { command: 'emphasis' });
    }
  },
  Emphasis: Emphasis,
  EmphasisHTMLConverter: EmphasisHTMLConverter
};

var ImageNode = (function (DocumentNode$$1) {
  function ImageNode () {
    DocumentNode$$1.apply(this, arguments);
  }

  if ( DocumentNode$$1 ) ImageNode.__proto__ = DocumentNode$$1;
  ImageNode.prototype = Object.create( DocumentNode$$1 && DocumentNode$$1.prototype );
  ImageNode.prototype.constructor = ImageNode;

  ImageNode.prototype.getImageFile = function getImageFile () {
    if (this.imageFile) {
      return this.document.get(this.imageFile)
    }
  };

  ImageNode.prototype.getUrl = function getUrl () {
    var imageFile = this.getImageFile();
    if (imageFile) {
      return imageFile.getUrl()
    }
  };

  return ImageNode;
}(DocumentNode));

ImageNode.schema = {
  type: 'image',
  imageFile: { type: 'file' }
};

/*
 * HTML converter for Paragraphs.
 */

/*
  Generic implementation of a file proxy that works with
  any file type
*/
var DefaultFileProxy = (function (FileProxy$$1) {
  function DefaultFileProxy(fileNode, context) {
    FileProxy$$1.call(this, fileNode, context);

    // used locally e.g. after drop or file dialog
    this.file = fileNode.sourceFile;
    if (this.file) {
      this._fileUrl = URL.createObjectURL(this.file);
    }
    this.url = fileNode.url;
  }

  if ( FileProxy$$1 ) DefaultFileProxy.__proto__ = FileProxy$$1;
  DefaultFileProxy.prototype = Object.create( FileProxy$$1 && FileProxy$$1.prototype );
  DefaultFileProxy.prototype.constructor = DefaultFileProxy;

  DefaultFileProxy.prototype.getUrl = function getUrl () {
    // if we have fetched the url already, just serve it here
    if (this.url) {
      return this.url
    }
    // if we have a local file, use it's data URL
    if (this._fileUrl) {
      return this._fileUrl
    }
    // no URL available
    return ''
  };

  DefaultFileProxy.prototype.sync = function sync () {
    if (!this.url) {
      console.info('Simulating file upload. Creating blob url instead.', this._fileUrl);
      this.url = this._fileUrl;
    }
    return Promise.resolve()
  };

  return DefaultFileProxy;
}(FileProxy));

var ImageProxy = (function (DefaultFileProxy$$1) {
  function ImageProxy () {
    DefaultFileProxy$$1.apply(this, arguments);
  }if ( DefaultFileProxy$$1 ) ImageProxy.__proto__ = DefaultFileProxy$$1;
  ImageProxy.prototype = Object.create( DefaultFileProxy$$1 && DefaultFileProxy$$1.prototype );
  ImageProxy.prototype.constructor = ImageProxy;

  

  return ImageProxy;
}(DefaultFileProxy));

// to detect that this class should take responsibility for a fileNode
ImageProxy.match = function(fileNode) {
  return fileNode.fileType === 'image'
};

var InlineWrapper = (function (InlineNode$$1) {
  function InlineWrapper () {
    InlineNode$$1.apply(this, arguments);
  }

  if ( InlineNode$$1 ) InlineWrapper.__proto__ = InlineNode$$1;
  InlineWrapper.prototype = Object.create( InlineNode$$1 && InlineNode$$1.prototype );
  InlineWrapper.prototype.constructor = InlineWrapper;

  InlineWrapper.prototype.getWrappedNode = function getWrappedNode () {
    return this.getDocument().get(this.wrappedNode)
  };

  return InlineWrapper;
}(InlineNode));

InlineWrapper.schema = {
  type: 'inline-wrapper',
  wrappedNode: 'id'
};

/*
  This package adds a node to the model which can be used
  to use a block-level node within an inline context.

    The quick brown fox jumps over the lazy <fig><img src='./dog.jpg'/></fig>.

  To register the converter you must provide `config.converters` which is
  an array of names of the converters you want this to be registered in.
*/

var Paragraph = (function (TextBlock$$1) {
	function Paragraph () {
		TextBlock$$1.apply(this, arguments);
	}if ( TextBlock$$1 ) Paragraph.__proto__ = TextBlock$$1;
	Paragraph.prototype = Object.create( TextBlock$$1 && TextBlock$$1.prototype );
	Paragraph.prototype.constructor = Paragraph;

	

	return Paragraph;
}(TextBlock));

Paragraph.type = "paragraph";

var ParagraphComponent = (function (TextBlockComponent$$1) {
  function ParagraphComponent () {
    TextBlockComponent$$1.apply(this, arguments);
  }

  if ( TextBlockComponent$$1 ) ParagraphComponent.__proto__ = TextBlockComponent$$1;
  ParagraphComponent.prototype = Object.create( TextBlockComponent$$1 && TextBlockComponent$$1.prototype );
  ParagraphComponent.prototype.constructor = ParagraphComponent;

  ParagraphComponent.prototype.render = function render ($$) {
    var el = TextBlockComponent$$1.prototype.render.call(this, $$);
    return el.addClass('sc-paragraph')
  };

  ParagraphComponent.prototype.getTagName = function getTagName () {
    return 'p'
  };

  return ParagraphComponent;
}(TextBlockComponent));

/*
 * HTML converter for Paragraph.
 */
var ParagraphHTMLConverter = {

  type: 'paragraph',
  tagName: 'p',

  import: function(el, node, converter) {
    node.content = converter.annotatedText(el, [node.id, 'content']);
  },

  export: function(node, el, converter) {
    el.append(converter.annotatedText([node.id, 'content']));
  }

};

var ParagraphPackage = {
  name: 'paragraph',
  configure: function(config) {
    config.addNode(Paragraph);
    config.addComponent(Paragraph.type, ParagraphComponent);
    config.addConverter('html', ParagraphHTMLConverter);
    config.addConverter('xml', ParagraphHTMLConverter);
    config.addTextType({
      name: 'paragraph',
      data: {type: 'paragraph'}
    });
    config.addLabel('paragraph', {
      en: 'Paragraph',
      de: 'Paragraph'
    });
    config.addLabel('paragraph.content', {
      en: 'Paragraph',
      de: 'Paragraph'
    });
  },
  Paragraph: Paragraph,
  ParagraphComponent: ParagraphComponent,
  ParagraphHTMLConverter: ParagraphHTMLConverter
};

var Strong = (function (PropertyAnnotation$$1) {
	function Strong () {
		PropertyAnnotation$$1.apply(this, arguments);
	}if ( PropertyAnnotation$$1 ) Strong.__proto__ = PropertyAnnotation$$1;
	Strong.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
	Strong.prototype.constructor = Strong;

	

	return Strong;
}(PropertyAnnotation));

Strong.type = "strong";

// a hint that makes in case of overlapping annotations that this
// annotation gets fragmented more often
Strong.fragmentation = Fragmenter.ANY;

/*
 * HTML converter for Strong.
 */
var StrongHTMLConverter = {

  type: "strong",
  tagName: "strong",

  matchElement: function(el) {
    return el.is("strong, b")
  }

};

var StrongComponent = (function (AnnotationComponent$$1) {
  function StrongComponent () {
    AnnotationComponent$$1.apply(this, arguments);
  }

  if ( AnnotationComponent$$1 ) StrongComponent.__proto__ = AnnotationComponent$$1;
  StrongComponent.prototype = Object.create( AnnotationComponent$$1 && AnnotationComponent$$1.prototype );
  StrongComponent.prototype.constructor = StrongComponent;

  StrongComponent.prototype.getTagName = function getTagName () {
    return 'strong'
  };

  return StrongComponent;
}(AnnotationComponent));

var StrongPackage = {
  name: 'strong',
  configure: function(config, ref) {
    var toolGroup = ref.toolGroup;
    var disableCollapsedCursor = ref.disableCollapsedCursor;

    config.addNode(Strong);
    config.addConverter('html', StrongHTMLConverter);
    config.addConverter('xml', StrongHTMLConverter);
    config.addComponent('strong', StrongComponent);

    config.addCommand('strong', AnnotationCommand, {
      nodeType: 'strong',
      disableCollapsedCursor: disableCollapsedCursor
    });
    config.addTool('strong', AnnotationTool, {
      toolGroup: toolGroup || 'annotations'
    });
    config.addIcon('strong', { 'fontawesome': 'fa-bold' });
    config.addLabel('strong', {
      en: 'Strong',
      de: 'Fett'
    });
    if (platform.isMac) {
      config.addKeyboardShortcut('cmd+b', { command: 'strong' });
    } else {
      config.addKeyboardShortcut('ctrl+b', { command: 'strong' });
    }
  },
  Strong: Strong,
  StrongHTMLConverter: StrongHTMLConverter
};

var Subscript = (function (PropertyAnnotation$$1) {
	function Subscript () {
		PropertyAnnotation$$1.apply(this, arguments);
	}if ( PropertyAnnotation$$1 ) Subscript.__proto__ = PropertyAnnotation$$1;
	Subscript.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
	Subscript.prototype.constructor = Subscript;

	

	return Subscript;
}(PropertyAnnotation));

Subscript.type = 'subscript';

// hint for rendering in presence of overlapping annotations
Subscript.fragmentation = Fragmenter.ANY;

/*
   HTML converter for Subscript.
*/

var Superscript = (function (PropertyAnnotation$$1) {
	function Superscript () {
		PropertyAnnotation$$1.apply(this, arguments);
	}if ( PropertyAnnotation$$1 ) Superscript.__proto__ = PropertyAnnotation$$1;
	Superscript.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
	Superscript.prototype.constructor = Superscript;

	

	return Superscript;
}(PropertyAnnotation));

Superscript.type = 'superscript';

// hint for rendering in presence of overlapping annotations
Superscript.fragmentation = Fragmenter.ANY;

/*
 * HTML converter for Superscript.
 */

var Heading = (function (TextBlock$$1) {
  function Heading () {
    TextBlock$$1.apply(this, arguments);
  }if ( TextBlock$$1 ) Heading.__proto__ = TextBlock$$1;
  Heading.prototype = Object.create( TextBlock$$1 && TextBlock$$1.prototype );
  Heading.prototype.constructor = Heading;

  

  return Heading;
}(TextBlock));

Heading.schema = {
  type: "heading",
  level: { type: "number", default: 1 }
};

var HeadingComponent = (function (TextBlockComponent$$1) {
  function HeadingComponent () {
    TextBlockComponent$$1.apply(this, arguments);
  }

  if ( TextBlockComponent$$1 ) HeadingComponent.__proto__ = TextBlockComponent$$1;
  HeadingComponent.prototype = Object.create( TextBlockComponent$$1 && TextBlockComponent$$1.prototype );
  HeadingComponent.prototype.constructor = HeadingComponent;

  HeadingComponent.prototype.render = function render ($$) {
    var el = TextBlockComponent$$1.prototype.render.call(this, $$);
    return el.addClass("sc-heading sm-level-"+this.props.node.level)
  };

  HeadingComponent.prototype.getTagName = function getTagName () {
    return 'h'+this.props.node.level
  };

  return HeadingComponent;
}(TextBlockComponent));

/*
 * HTML converter for Paragraphs.
 */
var HeadingHTMLConverter = {

  type: "heading",

  matchElement: function(el) {
    return /^h\d$/.exec(el.tagName)
  },

  import: function(el, node, converter) {
    node.level = Number(el.tagName[1]);
    node.content = converter.annotatedText(el, [node.id, 'content']);
  },

  export: function(node, el, converter) {
    el.tagName = 'h'+node.level;
    el.append(
      converter.annotatedText([node.id, 'content'])
    );
  }

};

var HeadingPackage = {
  name: 'heading',
  configure: function(config) {
    config.addNode(Heading);
    config.addComponent(Heading.type, HeadingComponent);
    config.addConverter('html', HeadingHTMLConverter);
    config.addConverter('xml', HeadingHTMLConverter);
    config.addTextType({
      name: 'heading1',
      data: {type: 'heading', level: 1}
    });
    config.addTextType({
      name: 'heading2',
      data: {type: 'heading', level: 2}
    });
    config.addTextType({
      name: 'heading3',
      data: {type: 'heading', level: 3}
    });
    config.addLabel('heading1', {
      en: 'Heading 1',
      de: 'Überschrift 1'
    });
    config.addLabel('heading2', {
      en: 'Heading 2',
      de: 'Überschrift 2'
    });
    config.addLabel('heading3', {
      en: 'Heading 3',
      de: 'Überschrift 3'
    });
  },
  Heading: Heading,
  HeadingComponent: HeadingComponent,
  HeadingHTMLConverter: HeadingHTMLConverter
};

/**
  SwitchTextTypeTool. Implements the SurfaceTool API.

  @class
  @component
*/
var SwitchTextTypeTool = (function (Tool$$1) {
  function SwitchTextTypeTool() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Tool$$1.apply(this, args);

    // cursor for keyboard navigation
    this._navIdx = -1;
  }

  if ( Tool$$1 ) SwitchTextTypeTool.__proto__ = Tool$$1;
  SwitchTextTypeTool.prototype = Object.create( Tool$$1 && Tool$$1.prototype );
  SwitchTextTypeTool.prototype.constructor = SwitchTextTypeTool;

  // UI Specific parts
  // ----------------

  SwitchTextTypeTool.prototype.didMount = function didMount () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Tool$$1.prototype.didMount.apply(this, args);
    this._focusToggle();
  };

  SwitchTextTypeTool.prototype.render = function render ($$) {
    var labelProvider = this.context.labelProvider;
    var textTypeName = 'No selection';

    if (this.props.currentTextType) {
      textTypeName = this.props.currentTextType.name;
    }
    var el = $$('div').addClass('sc-switch-text-type');

    var toggleButton = $$('button').ref('toggle')
      .addClass('se-toggle')
      .attr('title', labelProvider.getLabel('switch_text'))
      .append(labelProvider.getLabel(textTypeName))
      .on('click', this.toggleAvailableTextTypes);

    if (this.props.disabled || !this.props.currentTextType) {
      el.addClass('sm-disabled');
      toggleButton.attr('tabindex', -1);
    } else {
      toggleButton.attr('tabindex', 1);
    }

    el.append(toggleButton);

    if (this.state.open) {
      el.addClass('sm-open');

      // dropdown options
      var options = $$('div').addClass("se-options").ref('options');
      forEach(this.props.textTypes, function(textType) {
        var button = $$('button')
            .addClass('se-option sm-'+textType.name)
            .attr('data-type', textType.name)
            .append(labelProvider.getLabel(textType.name))
            .on('click', this.handleClick);
        options.append(button);
      }.bind(this));
      el.append(options);
      el.on('keydown', this.onKeydown);
    }

    return el
  };

  SwitchTextTypeTool.prototype.didUpdate = function didUpdate () {
    this._focusToggle();
  };

  SwitchTextTypeTool.prototype._focusToggle = function _focusToggle () {
    if (this.state.open) {
      this.refs.toggle.el.focus();
    }
  };

  SwitchTextTypeTool.prototype.executeCommand = function executeCommand (textType) {
    this.context.commandManager.executeCommand(this.getCommandName(), {
      textType: textType
    });
  };

  SwitchTextTypeTool.prototype.getTextCommands = function getTextCommands () {
    var surface = this.getSurface();
    if (!this.textCommands && surface) {
      this.textCommands = surface.getTextCommands();
    }
    return this.textCommands || {}
  };

  SwitchTextTypeTool.prototype.handleClick = function handleClick (e) {
    e.preventDefault();
    // Modifies the tool's state so that state.open is undefined, which is nice
    // because it means the dropdown will be closed automatically
    this.executeCommand(e.currentTarget.dataset.type);
  };

  SwitchTextTypeTool.prototype.onKeydown = function onKeydown (event) {
    var handled = false;
    switch (event.keyCode) {
      case keys.UP:
        this._nav(-1);
        handled = true;
        break
      case keys.DOWN:
        this._nav(1);
        handled = true;
        break
      case keys.ESCAPE:
        this.toggleDropdown();
        handled = true;
        break
      default:
        // nothing
    }
    if (handled) {
      event.preventDefault();
      event.stopPropagation();
    }
  };

  SwitchTextTypeTool.prototype.toggleAvailableTextTypes = function toggleAvailableTextTypes (e) {
    e.preventDefault();
    e.stopPropagation();
    if (this.props.disabled) { return }

    // HACK: This only updates the view state state.open is not set on the tool itself
    // That way the dropdown automatically closes when the selection changes
    this.toggleDropdown();
  };

  SwitchTextTypeTool.prototype.toggleDropdown = function toggleDropdown () {
    // reset index for keyboard navigation
    this._navIdx = -1;
    this.extendState({
      open: !this.state.open
    });
  };

  SwitchTextTypeTool.prototype._nav = function _nav (step) {
    this._navIdx += step;
    this._navIdx = Math.max(0, this._navIdx);
    this._navIdx = Math.min(this._getOptionsCount()-1, this._navIdx);

    if (this._navIdx >= 0) {
      var option = this.refs.options.children[this._navIdx];
      option.focus();
    }
  };

  SwitchTextTypeTool.prototype._getOptionsCount = function _getOptionsCount () {
    return this.refs.options.children.length
  };

  return SwitchTextTypeTool;
}(Tool));

SwitchTextTypeTool.command = 'switch-text-type';

var SwitchTextTypeCommand = (function (Command$$1) {
  function SwitchTextTypeCommand () {
    Command$$1.apply(this, arguments);
  }

  if ( Command$$1 ) SwitchTextTypeCommand.__proto__ = Command$$1;
  SwitchTextTypeCommand.prototype = Object.create( Command$$1 && Command$$1.prototype );
  SwitchTextTypeCommand.prototype.constructor = SwitchTextTypeCommand;

  SwitchTextTypeCommand.prototype.getTextTypes = function getTextTypes (params) {
    var surface = params.surface;
    if (surface && surface.isContainerEditor()) {
      return surface.getTextTypes()
    } else {
      return []
    }
  };

  SwitchTextTypeCommand.prototype.getTextType = function getTextType (params) {
    var textTypes = this.getTextTypes(params);
    return find$1(textTypes, function(t) {
      return t.name === params.textType
    })
  };

  // Search which textType matches the current node
  // E.g. {type: 'heading', level: 1} => heading1
  SwitchTextTypeCommand.prototype.getCurrentTextType = function getCurrentTextType (params, node) {
    var textTypes = this.getTextTypes(params);
    var currentTextType;
    textTypes.forEach(function(textType) {
      var nodeProps = clone(textType.data);
      delete nodeProps.type;
      if (isMatch(node, nodeProps) && node.type === textType.data.type) {
        currentTextType = textType;
      }
    });
    return currentTextType
  };

  SwitchTextTypeCommand.prototype.isDisabled = function isDisabled (ref) {
    var selection = ref.selection;
    var surface = ref.surface;

    if (!surface || !surface.isEnabled() || selection.isNull()) {
      return true
    }
    // When command is configured to be disabled for collapsed cursor
    if (selection && this.config.disableCollapsedCursor && selection.isCollapsed()) {
      return true
    }
    return false
  };

  SwitchTextTypeCommand.prototype.getCommandState = function getCommandState (params) {
    var doc = params.editorSession.getDocument();
    var sel = params.selection;

    var node;
    var newState = {
      disabled: false,
      textTypes: this.getTextTypes(params)
    };
    // Set disabled when not a property selection
    if (this.isDisabled(params)) {
      newState.disabled = true;
    } else if (sel.isContainerSelection()) {
      newState.disabled = true;
      newState.currentTextType = {name: 'container-selection'};
    } else if (sel.isPropertySelection()) {
      var path = sel.getPath();
      node = doc.get(path[0]);
      // There are cases where path points to an already deleted node,
      // so we need to guard node
      if (node) {
        if (node.isText() && node.isBlock()) {
          newState.currentTextType = this.getCurrentTextType(params, node);
        }
        if (!newState.currentTextType) {
          // We 'abuse' the currentTextType field by providing a property
          // identifier that is translated into a name using an default label set.
          // E.g. this.getLabel('figure.caption') -> Figure Caption
          newState.currentTextType = {name: [node.type, path[1]].join('.')};
          newState.disabled = true;
        }
      }
    } else if (sel.isNodeSelection()) {
      node = doc.get(sel.getNodeId());
      newState.currentTextType = {name: node.type};
      newState.disabled = true;
    } else if (sel.isCustomSelection()) {
      newState.currentTextType = {name: 'custom'};
      newState.disabled = true;
    }
    return newState
  };

  /**
    Trigger a switchTextType transaction
   */
  SwitchTextTypeCommand.prototype.execute = function execute (params) {
    var textType = this.getTextType(params);
    var nodeData = textType.data;
    var surface = params.surface;
    var editorSession = params.editorSession;
    if (!surface) {
      console.warn('No focused surface. Stopping command execution.');
      return
    }
    editorSession.transaction(function(tx) {
      return tx.switchTextType(nodeData)
    });
    return nodeData
  };

  return SwitchTextTypeCommand;
}(Command));

var SwitchTextTypePackage = {
  name: 'switch-text-type',
  configure: function(config, options) {
    config.addToolGroup('text');
    config.addCommand('switch-text-type', SwitchTextTypeCommand);
    config.addTool('switch-text-type', SwitchTextTypeTool, {toolGroup: options.toolGroup || 'text'});
  }
};

var Link = (function (PropertyAnnotation$$1) {
  function Link () {
    PropertyAnnotation$$1.apply(this, arguments);
  }if ( PropertyAnnotation$$1 ) Link.__proto__ = PropertyAnnotation$$1;
  Link.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
  Link.prototype.constructor = Link;

  

  return Link;
}(PropertyAnnotation));

Link.schema = {
  type: "link",
  title: { type: 'string', optional: true },
  url: { type: 'string', 'default': ''}
};

// in presence of overlapping annotations will try to render this as one element
Link.fragmentation = Fragmenter.SHOULD_NOT_SPLIT;

var LinkComponent = (function (AnnotationComponent$$1) {
  function LinkComponent () {
    AnnotationComponent$$1.apply(this, arguments);
  }

  if ( AnnotationComponent$$1 ) LinkComponent.__proto__ = AnnotationComponent$$1;
  LinkComponent.prototype = Object.create( AnnotationComponent$$1 && AnnotationComponent$$1.prototype );
  LinkComponent.prototype.constructor = LinkComponent;

  LinkComponent.prototype.didMount = function didMount () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    AnnotationComponent$$1.prototype.didMount.apply(this, args);

    var node = this.props.node;
    this.context.editorSession.onRender('document', this.rerender, this, {
      path: [node.id, 'url']
    });
  };

  LinkComponent.prototype.dispose = function dispose () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    AnnotationComponent$$1.prototype.dispose.apply(this, args);

    this.context.editorSession.off(this);
  };

  LinkComponent.prototype.render = function render ($$) { // eslint-disable-line
    var el = AnnotationComponent$$1.prototype.render.call(this, $$);

    el.tagName = 'a';
    el.attr('href', this.props.node.url);

    var titleComps = [this.props.node.url];
    if (this.props.node.title) {
      titleComps.push(this.props.node.title);
    }

    return el.attr("title", titleComps.join(' | '))
  };

  return LinkComponent;
}(AnnotationComponent));

var LinkCommand = (function (AnnotationCommand$$1) {
  function LinkCommand () {
    AnnotationCommand$$1.apply(this, arguments);
  }

  if ( AnnotationCommand$$1 ) LinkCommand.__proto__ = AnnotationCommand$$1;
  LinkCommand.prototype = Object.create( AnnotationCommand$$1 && AnnotationCommand$$1.prototype );
  LinkCommand.prototype.constructor = LinkCommand;

  LinkCommand.prototype.canFuse = function canFuse () { return false };

  /*
    On link creation we collapse the selection, as this is a condition for the
    EditLinkTool to be shown (see EditAnnotationCommand)
  */
  LinkCommand.prototype.executeCreate = function executeCreate (params) {
    var result = AnnotationCommand$$1.prototype.executeCreate.call(this, params);
    var editorSession = this._getEditorSession(params);
    editorSession.transaction(function (tx) {
      tx.setSelection(tx.selection.collapse());
    });
    return result
  };

  return LinkCommand;
}(AnnotationCommand));

/*
 * HTML converter for Paragraphs.
 */
var LinkXMLConverter = {

  type: "link",
  tagName: 'a',

  import: function(el, node) {
    node.url = el.attr('href');
    node.title = el.attr('title');
  },

  export: function(link, el) {
    el.attr({
      href: link.url,
      title: link.title
    });
  }

};

/**
  Tool to edit an existing link.

  Designed so that it can be used either in a toolbar, or within
  an overlay on the Surface.

  @component
*/
var EditLinkTool = (function (Tool$$1) {
  function EditLinkTool () {
    Tool$$1.apply(this, arguments);
  }

  if ( Tool$$1 ) EditLinkTool.__proto__ = Tool$$1;
  EditLinkTool.prototype = Object.create( Tool$$1 && Tool$$1.prototype );
  EditLinkTool.prototype.constructor = EditLinkTool;

  EditLinkTool.prototype.getUrlPath = function getUrlPath () {
    var propPath = this.constructor.urlPropertyPath;
    return [this.props.node.id].concat(propPath)
  };

  EditLinkTool.prototype._openLink = function _openLink () {
    var doc = this.context.editorSession.getDocument();
    window.open(doc.get(this.getUrlPath()), '_blank');
  };

  EditLinkTool.prototype.render = function render ($$) {
    var Input = this.getComponent('input');
    var Button = this.getComponent('button');
    var el = $$('div').addClass('sc-edit-link-tool');

    // GUARD: Return if tool is disabled
    if (this.props.disabled) {
      console.warn('Tried to render EditLinkTool while disabled.');
      return el
    }

    var urlPath = this.getUrlPath();

    el.append(
      $$(Input, {
        type: 'url',
        path: urlPath,
        placeholder: 'Paste or type a link url'
      }),
      $$(Button, {
        icon: 'open-link',
        style: this.props.style
      }).attr('title', this.getLabel('open-link'))
        .on('click', this._openLink),

      $$(Button, {
        icon: 'delete',
        style: this.props.style
      }).attr('title', this.getLabel('delete-link'))
        .on('click', this.onDelete)
    );
    return el
  };

  EditLinkTool.prototype.onDelete = function onDelete (e) {
    e.preventDefault();
    var node = this.props.node;
    var sm = this.context.surfaceManager;
    var surface = sm.getFocusedSurface();
    if (!surface) {
      console.warn('No focused surface. Stopping command execution.');
      return
    }
    var editorSession = this.context.editorSession;
    editorSession.transaction(function(tx, args) {
      tx.delete(node.id);
      return args
    });
  };

  return EditLinkTool;
}(Tool));

EditLinkTool.urlPropertyPath = ['url'];

/**
  Used for edit tools or property annotations (e.g. EditLinkTool)

  @class
*/
var EditAnnotationCommand = (function (Command$$1) {
  function EditAnnotationCommand() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Command$$1.apply(this, args);

    if (!this.config.nodeType) {
      throw new Error("'nodeType' is required")
    }
  }

  if ( Command$$1 ) EditAnnotationCommand.__proto__ = Command$$1;
  EditAnnotationCommand.prototype = Object.create( Command$$1 && Command$$1.prototype );
  EditAnnotationCommand.prototype.constructor = EditAnnotationCommand;

  /**
    Get command state

    @return {Object} object with `disabled` and `node` properties
  */
  EditAnnotationCommand.prototype.getCommandState = function getCommandState (params) {
    var sel = this._getSelection(params);
    var annos = this._getAnnotationsForSelection(params);
    var newState = {
      disabled: true,
    };
    if (annos.length === 1 && sel.isPropertySelection() && sel.isCollapsed()) {
      newState.disabled = false;
      newState.node = annos[0];
    }
    return newState
  };

  EditAnnotationCommand.prototype.execute = function execute (params) { }; // eslint-disable-line

  EditAnnotationCommand.prototype._getAnnotationsForSelection = function _getAnnotationsForSelection (params) {
    return params.selectionState.getAnnotationsForType(this.config.nodeType)
  };

  return EditAnnotationCommand;
}(Command));

var LinkPackage = {
  name: 'link',
  configure: function(config, ref) {
    var toolGroup = ref.toolGroup;
    var editLinkToolGroup = ref.editLinkToolGroup;
    var disableCollapsedCursor = ref.disableCollapsedCursor;

    config.addNode(Link);
    config.addComponent('link', LinkComponent);
    config.addConverter('html', LinkXMLConverter);
    config.addConverter('xml', LinkXMLConverter);
    config.addCommand('link', LinkCommand, {
      nodeType: 'link',
      disableCollapsedCursor: disableCollapsedCursor
    });
    config.addCommand('edit-link', EditAnnotationCommand, {
      nodeType: 'link'
    });
    config.addTool('link', AnnotationTool, {
      toolGroup: toolGroup || 'annotations'
    });
    config.addTool('edit-link', EditLinkTool, {
      toolGroup: editLinkToolGroup || 'overlay'
    });
    config.addIcon('link', { 'fontawesome': 'fa-link'});
    config.addIcon('open-link', { 'fontawesome': 'fa-external-link' });
    config.addLabel('link', {
      en: 'Link',
      de: 'Link'
    });
    config.addLabel('open-link', {
      en: 'Open Link',
      de: 'Link öffnen'
    });
    config.addLabel('delete-link', {
      en: 'Remove Link',
      de: 'Link löschen'
    });
    if (platform.isMac) {
      config.addKeyboardShortcut('cmd+k', { command: 'link' });
    } else {
      config.addKeyboardShortcut('ctrl+k', { command: 'link' });
    }
  },
  Link: Link,
  LinkComponent: LinkComponent,
  LinkCommand: LinkCommand,
  EditLinkTool: EditLinkTool,
};

var ListNode = (function (DocumentNode$$1) {
  function ListNode () {
    DocumentNode$$1.apply(this, arguments);
  }

  if ( DocumentNode$$1 ) ListNode.__proto__ = DocumentNode$$1;
  ListNode.prototype = Object.create( DocumentNode$$1 && DocumentNode$$1.prototype );
  ListNode.prototype.constructor = ListNode;

  var prototypeAccessors = { length: {} };

  ListNode.prototype.getItemAt = function getItemAt (idx) {
    return this.getDocument().get(this.items[idx])
  };

  ListNode.prototype.getFirstItem = function getFirstItem () {
    return this.getItemAt(0)
  };

  ListNode.prototype.getLastItem = function getLastItem () {
    return this.getItemAt(this.getLength()-1)
  };

  ListNode.prototype.getItems = function getItems () {
    var doc = this.getDocument();
    return this.items.map(function (id) {
      return doc.get(id)
    })
  };

  ListNode.prototype.getItemPosition = function getItemPosition (itemId) {
    if (itemId._isNode) { itemId = itemId.id; }
    var pos = this.items.indexOf(itemId);
    if (pos < 0) { throw new Error('Item is not within this list: ' + itemId) }
    return pos
  };

  ListNode.prototype.insertItemAt = function insertItemAt (pos, itemId) {
    var doc = this.getDocument();
    doc.update([this.id, 'items'], { type: 'insert', pos: pos, value: itemId });
  };

  ListNode.prototype.appendItem = function appendItem (itemId) {
    this.insertItemAt(this.items.length, itemId);
  };

  ListNode.prototype.removeItemAt = function removeItemAt (pos) {
    var doc = this.getDocument();
    doc.update([this.id, 'items'], { type: 'delete', pos: pos });
  };

  ListNode.prototype.remove = function remove (itemId) {
    var doc = this.getDocument();
    var pos = this.getItemPosition(itemId);
    if (pos >= 0) {
      doc.update([this.id, 'items'], { type: 'delete', pos: pos });
    }
  };

  ListNode.prototype.getLength = function getLength () {
    return this.items.length
  };

  prototypeAccessors.length.get = function () {
    return this.getLength()
  };

  Object.defineProperties( ListNode.prototype, prototypeAccessors );

  return ListNode;
}(DocumentNode));

ListNode.isList = true;

ListNode.type = 'list';

ListNode.schema = {
  ordered: { type: 'boolean', default: false },
  // list-items are owned by the list
  items: { type: [ 'array', 'id' ], default: [], owned: true }
};

var ListItem = (function (TextNode$$1) {
  function ListItem () {
    TextNode$$1.apply(this, arguments);
  }if ( TextNode$$1 ) ListItem.__proto__ = TextNode$$1;
  ListItem.prototype = Object.create( TextNode$$1 && TextNode$$1.prototype );
  ListItem.prototype.constructor = ListItem;

  

  return ListItem;
}(TextNode));

ListItem.type = 'list-item';

ListItem.schema = {
  level: { type: "number", default: 1 }
};

var ListItemComponent = (function (TextPropertyComponent$$1) {
	function ListItemComponent () {
		TextPropertyComponent$$1.apply(this, arguments);
	}if ( TextPropertyComponent$$1 ) ListItemComponent.__proto__ = TextPropertyComponent$$1;
	ListItemComponent.prototype = Object.create( TextPropertyComponent$$1 && TextPropertyComponent$$1.prototype );
	ListItemComponent.prototype.constructor = ListItemComponent;

	

	return ListItemComponent;
}(TextPropertyComponent));

function getListTagName(node) {
  // TODO: we might want to have different types for different levels
  return node.ordered ? 'ol' : 'ul'
}

function renderListNode(node, rootEl, createElement) {
  var items = node.getItems();
  var stack = [rootEl];
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    if (item.level<stack.length) {
      for (var j = stack.length; j > item.level; j--) {
        stack.pop();
      }
    } else if (item.level>stack.length) {
      for (var j$1 = stack.length; j$1 < item.level; j$1++) {
        // Note: ATM all sublists have the same order type
        var sublist = createElement(getListTagName(node));
        last$2(stack).append(sublist);
        stack.push(sublist);
      }
    }
    console.assert(item.level === stack.length, 'item.level should now be the same as stack.length');
    last$2(stack).append(
      createElement(item)
    );
  }
  for(var j$2=stack.length; j$2>1;j$2--) {
    stack.pop();
  }
}

var ListComponent = (function (Component$$1) {
  function ListComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) ListComponent.__proto__ = Component$$1;
  ListComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  ListComponent.prototype.constructor = ListComponent;

  ListComponent.prototype.didMount = function didMount () {
    this.context.editorSession.onRender('document', this._onChange, this);
  };

  ListComponent.prototype.render = function render ($$) {
    var node = this.props.node;
    var el = $$(getListTagName(node))
      .addClass('sc-list')
      .attr('data-id', node.id);
    renderListNode(node, el, function (arg) {
      if (isString(arg)) {
        return $$(arg)
      } else if(arg.type === 'list-item') {
        var item = arg;
        return $$(ListItemComponent, {
          path: [item.id, 'content'],
          node: item,
          tagName: 'li'
        })
        // setting ref to preserve items when rerendering
        .ref(item.id)
      }
    });
    return el
  };

  ListComponent.prototype._onChange = function _onChange (change) {
    var this$1 = this;

    var node = this.props.node;
    if (change.isAffected(node.id)) {
      return this.rerender()
    }
    // check if any of the list items are affected
    var itemIds = node.items;
    for (var i = 0; i < itemIds.length; i++) {
      if (change.isAffected([itemIds[i], 'level'])) {
        return this$1.rerender()
      }
    }
  };

  return ListComponent;
}(Component));

// we need this ATM to prevent this being wrapped into an isolated node (see ContainerEditor._renderNode())
ListComponent.prototype._isCustomNodeComponent = true;

/*
  HTML converter for Lists.
 */

/*
 * HTML converter for Lists.
 */

var Table = (function (BlockNode$$1) {
  function Table () {
    BlockNode$$1.apply(this, arguments);
  }

  if ( BlockNode$$1 ) Table.__proto__ = BlockNode$$1;
  Table.prototype = Object.create( BlockNode$$1 && BlockNode$$1.prototype );
  Table.prototype.constructor = Table;

  Table.prototype.getRowCount = function getRowCount () {
    return this.cells.length
  };

  Table.prototype.getColCount = function getColCount () {
    if (this.cells.length > 0) {
      return this.cells[0].length
    } else {
      return 0
    }
  };

  Table.prototype.getCellAt = function getCellAt (row, col) {
    var cellId = this.cells[row][col];
    if (cellId) {
      return this.document.get(cellId)
    }
  };

  return Table;
}(BlockNode));

Table.schema = {
  type: 'table',
  cells: { type: ['array', 'array', 'id'], default: [], owned: true }
};

var TableCell = (function (TextNode$$1) {
  function TableCell () {
    TextNode$$1.apply(this, arguments);
  }if ( TextNode$$1 ) TableCell.__proto__ = TextNode$$1;
  TableCell.prototype = Object.create( TextNode$$1 && TextNode$$1.prototype );
  TableCell.prototype.constructor = TableCell;

  

  return TableCell;
}(TextNode));

TableCell.schema = {
  type: 'table-cell',
  rowspan: { type: 'number', default: 0 },
  colspan: { type: 'number', default: 0 }
};

function startsWith$2(str, prefix) {
  if (!isString(str)) { return false }
  if (str.startsWith) { return str.startsWith(prefix) }
  if (!isString(prefix)) { prefix = String(prefix); }
  return str.slice(0, prefix.length) === prefix
}

/**
  Import HTML from clipboard. Used for inter-application copy'n'paste.

  @internal
*/
var ClipboardImporter = (function (HTMLImporter$$1) {
  function ClipboardImporter(config) {
    ClipboardImporter._addConverters(config);

    if (!config.schema) {
      throw new Error('Missing argument: config.schema is required.')
    }

    HTMLImporter$$1.call(this, config);
    // disabling warnings about default importers
    this.IGNORE_DEFAULT_WARNINGS = true;

    extend(config, {
      trimWhitespaces: true,
      REMOVE_INNER_WS: true
    });

    // ATTENTION: this is only here so we can enfore windows conversion
    // mode from within tests
    this._isWindows = platform.isWindows;

    this._emptyDoc = this._createDocument(this.schema);
  }

  if ( HTMLImporter$$1 ) ClipboardImporter.__proto__ = HTMLImporter$$1;
  ClipboardImporter.prototype = Object.create( HTMLImporter$$1 && HTMLImporter$$1.prototype );
  ClipboardImporter.prototype.constructor = ClipboardImporter;

  /**
    Parses HTML and applies some sanitization/normalization.
  */
  ClipboardImporter.prototype.importDocument = function importDocument (html) {
    var body, el;

    if (this._isWindows) {
      // Under windows we can exploit <!--StartFragment--> and <!--EndFragment-->
      // to have an easier life
      var match = /<!--StartFragment-->(.*)<!--EndFragment-->/.exec(html);
      if (match) {
        html = match[1];
      }
    }

    // when copying from a substance editor we store JSON in a script tag in the head
    // If the import fails e.g. because the schema is incompatible
    // we fall back to plain HTML import
    if (html.search(/script id=.substance-clipboard./)>=0) {
      el = DefaultDOMElement.parseHTML(html);
      var substanceData = el.find('#substance-clipboard');
      if (substanceData) {
        var jsonStr = substanceData.textContent;
        try {
          return this.importFromJSON(jsonStr)
        } catch(err) {
          console.error(err);
        }
      }
    }

    el = DefaultDOMElement.parseHTML(html);
    if (isArray(el)) {
      body = this._createElement('body');
      body.append(el);
    } else {
      body = el.find('body');
    }
    if (!body) {
      body = this._createElement('body');
      body.append(el);
    }
    body = this._sanitizeBody(body);
    if (!body) {
      console.warn('Invalid HTML.');
      return null
    }

    this.reset();
    this.convertBody(body);
    var doc = this.generateDocument();
    return doc
  };

  ClipboardImporter.prototype._sanitizeBody = function _sanitizeBody (body) {
    body = this._fixupGoogleDocsBody(body);
    // Remove <meta> element
    body.findAll('meta').forEach(function (el) { return el.remove(); });
    return body
  };

  ClipboardImporter.prototype._fixupGoogleDocsBody = function _fixupGoogleDocsBody (body) {
    if (!body) { return }
    // Google Docs has a strange convention to use a bold tag as
    // container for the copied elements
    // HACK: we exploit the fact that this element has an id with a
    // specific format, e.g., id="docs-internal-guid-5bea85da-43dc-fb06-e327-00c1c6576cf7"
    var bold = body.find('b');
    if (bold && /^docs-internal/.exec(bold.id)) {
      return bold
    }
    return body
  };

  ClipboardImporter.prototype.importFromJSON = function importFromJSON (jsonStr) {
    var doc = this.createDocument();
    var jsonData = JSON.parse(jsonStr);
    var converter = new JSONConverter();
    converter.importDocument(doc, jsonData);
    return doc
  };

  /**
    Converts all children of a given body element.

    @param {String} body body element of given HTML document
  */
  ClipboardImporter.prototype.convertBody = function convertBody (body) {
    this.convertContainer(body.childNodes, Document.SNIPPET_ID);
  };

  ClipboardImporter.prototype._wrapInlineElementsIntoBlockElement = function _wrapInlineElementsIntoBlockElement (childIterator) {
    var this$1 = this;

    var wrapper = this._createElement('p');
    while(childIterator.hasNext()) {
      var el = childIterator.next();
      // if there is a block node we finish this wrapper
      var blockTypeConverter = this$1._getConverterForElement(el, 'block');
      if (blockTypeConverter) {
        childIterator.back();
        break
      }
      wrapper.append(el.clone(true));
    }
    // HACK: usually when we run into this case, then there is inline data only
    // Instead of detecting this case up-front we just set the proper id
    // and hope that all goes well.
    // Note: when this is called a second time, the id will be overridden.
    wrapper.attr('data-id', Document.TEXT_SNIPPET_ID);
    var node = this.defaultConverter(wrapper, this);
    if (node) {
      if (!node.type) {
        throw new Error('Contract: Html.defaultConverter() must return a node with type.')
      }
      this._createAndShow(node);
    }
    return node
  };

  /**
    Creates substance document to paste.

    @return {Document} the document instance
  */
  ClipboardImporter.prototype.createDocument = function createDocument () {
    return this._emptyDoc.createSnippet()
  };

  ClipboardImporter.prototype._getUnsupportedNodeConverter = function _getUnsupportedNodeConverter () {
    // nothing
  };

  return ClipboardImporter;
}(HTMLImporter));

var CONVERTERS = {
  'catch-all-block': {
    type: 'paragraph',
    matchElement: function(el) { return el.is('div') },
    import: function(el, node, converter) {
      node.content = converter.annotatedText(el, [node.id, 'content']);
    }
  }
};

ClipboardImporter._addConverters = function(config) {
  if (config.converters) {
    var registry = new Registry();
    config.converters.forEach(function(conv, name) {
      registry.add(name, conv);
    });
    forEach(CONVERTERS, function(converter, name) {
      registry.add(name, converter);
    });
    config.converters = registry;
  }
};

/**
  Export HTML from clipboard. Used for inter-application copy'n'paste.

  @internal
*/
var ClipboardExporter = (function (HtmlExporter) {
  function ClipboardExporter () {
    HtmlExporter.apply(this, arguments);
  }

  if ( HtmlExporter ) ClipboardExporter.__proto__ = HtmlExporter;
  ClipboardExporter.prototype = Object.create( HtmlExporter && HtmlExporter.prototype );
  ClipboardExporter.prototype.constructor = ClipboardExporter;

  ClipboardExporter.prototype.exportDocument = function exportDocument (doc) {
    this.state.doc = doc;
    var html;
    var elements = this.convertDocument(doc);
    // special treatment for a text snippet
    if (elements.length === 1 && elements[0].attr('data-id') === Document.TEXT_SNIPPET_ID) {
      html = elements[0].innerHTML;
    } else {
      html = elements.map(function(el) {
        return el.outerHTML
      }).join('');
    }
    var jsonConverter = new JSONConverter();
    var jsonStr = JSON.stringify(jsonConverter.exportDocument(doc));
    var substanceContent = "<script id=\"substance-clipboard\" type=\"application/json\">" + jsonStr + "</script>";
    return '<html><head>' +substanceContent+ '</head><body>' + html + '</body></html>'
  };

  /**
    Coverts document to set of DOM elements.

    @param {Document} doc document to convert

    @return {Array} array of DOM elements each represented single node
  */
  ClipboardExporter.prototype.convertDocument = function convertDocument (doc) {
    var content = doc.get(Document.SNIPPET_ID);
    if (!content) {
      throw new Error('Illegal clipboard document: could not find container "' + Document.SNIPPET_ID + '"')
    }
    return this.convertContainer(content)
  };

  return ClipboardExporter;
}(HTMLExporter));

/**
  The Clipboard is a Component which should be rendered as a sibling component
  of one or multiple Surfaces.

  It uses the JSONImporter and JSONExporter for internal copy'n'pasting,
  i.e., within one window or between two instances with the same DocumentSchema.

  For inter-application copy'n'paste, the ClipboardImporter and ClipboardExporter is used.

  @internal
*/
var Clipboard = function Clipboard(editorSession, config) {
  this.editorSession = editorSession;
  var doc = editorSession.getDocument();
  var schema = doc.getSchema();

  var htmlConverters = [];
  if (config.converterRegistry) {
    htmlConverters = config.converterRegistry.get('html') || [];
  }
  var _config = {
    schema: schema,
    DocumentClass: doc.constructor,
    converters: htmlConverters
  };

  this.htmlImporter = new ClipboardImporter(_config);
  this.htmlExporter = new ClipboardExporter(_config);
};

Clipboard.prototype.getEditorSession = function getEditorSession () {
  return this.editorSession
};

/*
  Called by to enable clipboard handling on a given root element.
*/
Clipboard.prototype.attach = function attach (el) {
  el.on('copy', this.onCopy, this);
  el.on('cut', this.onCut, this);
  el.on('paste', this.onPaste, this);
};

/*
  Called by to disable clipboard handling.
*/
Clipboard.prototype.detach = function detach (el) {
  el.off(this);
};

/*
  Called when copy event fired.

  @param {Event} event
*/
Clipboard.prototype.onCopy = function onCopy (event) {
  // console.log("Clipboard.onCopy", arguments);
  var clipboardData = this._copy();
  substanceGlobals._clipboardData = event.clipboardData;

  if (event.clipboardData && clipboardData.doc) {
    event.preventDefault();
    // store as plain text and html
    event.clipboardData.setData('text/plain', clipboardData.text);
    // WORKAROUND: under IE and Edge it is not permitted to set 'text/html'
    if (!platform.isIE && !platform.isEdge) {
      event.clipboardData.setData('text/html', clipboardData.html);
    }
  }
};

/*
  Called when cut event fired.

  @param {Event} event
*/
Clipboard.prototype.onCut = function onCut (event) {
  // preventing default behavior to avoid that contenteditable
  // destroys our DOM
  event.preventDefault();
  // console.log("Clipboard.onCut", arguments);
  this.onCopy(event);
  var editorSession = this.getEditorSession();
  editorSession.transaction(function (tx){
    tx.deleteSelection();
  });
};

/*
  Called when paste event fired.

  @param {Event} event
*/
// Works on Safari/Chrome/FF
Clipboard.prototype.onPaste = function onPaste (event) {
  var clipboardData = event.clipboardData;

  var types = {};
  for (var i = 0; i < clipboardData.types.length; i++) {
    types[clipboardData.types[i]] = true;
  }
  // console.log('onPaste(): received content types', types);

  event.preventDefault();
  event.stopPropagation();

  var plainText;
  var html;
  if (types['text/plain']) {
    plainText = clipboardData.getData('text/plain');
  }
  if (types['text/html']) {
    html = clipboardData.getData('text/html');
  }

  // HACK: to allow at least in app copy and paste under Edge (which blocks HTML)
  // we guess by comparing the old and new plain text
  if (platform.isEdge &&
      substanceGlobals.clipboardData &&
      substanceGlobals.clipboardData.text === plainText) {
    html = substanceGlobals.clipboardData.html;
  } else {
    substanceGlobals.clipboardData = {
      text: plainText,
      html: html
    };
  }

  // console.log('onPaste(): html = ', html);

  // WORKAROUND: FF does not provide HTML coming in from other applications
  // so fall back to pasting plain text
  if (platform.isFF && !html) {
    this._pastePlainText(plainText);
    return
  }

  // if we have content given as HTML we let the importer assess the quality first
  // and fallback to plain text import if it's bad
  if (html) {
    if (!this._pasteHtml(html, plainText)) {
      this._pastePlainText(plainText);
    }
  } else {
    this._pastePlainText(plainText);
  }
};

/*
  Pastes a given plain text into the surface.

  @param {String} plainText plain text
*/
Clipboard.prototype._pastePlainText = function _pastePlainText (plainText) {
  var editorSession = this.getEditorSession();
  editorSession.transaction(function(tx) {
    tx.paste(plainText);
  }, { action: 'paste' });
};

/*
  Copies selected content from document to clipboard.
*/
Clipboard.prototype._copy = function _copy () {
  var editorSession = this.getEditorSession();
  var sel = editorSession.getSelection();
  var doc = editorSession.getDocument();
  var clipboardDoc = null;
  var clipboardText = "";
  var clipboardHtml = "";
  if (!sel.isCollapsed()) {
    clipboardText = documentHelpers.getTextForSelection(doc, sel) || "";
    clipboardDoc = copySelection(doc, sel);
    clipboardHtml = this.htmlExporter.exportDocument(clipboardDoc);
  }
  return {
    doc: clipboardDoc,
    html: clipboardHtml,
    text: clipboardText
  }
};

/*
  Pastes a given parsed html document into the surface.

  @param {ui/DOMElement} docElement
  @param {String} text plain text representation used as a fallback
*/
Clipboard.prototype._pasteHtml = function _pasteHtml (html, text) {
  var content = this.htmlImporter.importDocument(html);
  this.paste(content, text);
  return true
};

/*
  Takes a clipboard document and pastes it at the current
  cursor position.

  Used by PasteCommand
*/
Clipboard.prototype.paste = function paste (doc, text) {
  var content = doc || text;
  var editorSession = this.getEditorSession();
  if (content) {
    editorSession.transaction(function (tx) {
      tx.paste(content);
    }, { action: 'paste' });
  }
};

var UnsupportedNodeComponent = (function (Component$$1) {
  function UnsupportedNodeComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) UnsupportedNodeComponent.__proto__ = Component$$1;
  UnsupportedNodeComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  UnsupportedNodeComponent.prototype.constructor = UnsupportedNodeComponent;

  UnsupportedNodeComponent.prototype.render = function render ($$) {
    return $$('pre')
      .addClass('content-node unsupported')
      .attr({
        'data-id': this.props.node.id,
        contentEditable: false
      })
      .append(
        JSON.stringify(this.props.node.properties, null, 2)
      )
  };

  return UnsupportedNodeComponent;
}(Component));

/**
   Abstract interface for editing components.
   Dances with contenteditable, so you don't have to.
*/
var Surface = (function (Component$$1) {
  function Surface() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Component$$1.apply(this, args);

    // EditorSession instance must be provided either as a prop
    // or via dependency-injection
    this.editorSession = this.props.editorSession || this.context.editorSession;
    if (!this.editorSession) {
      throw new Error('No EditorSession provided')
    }
    this.name = this.props.name;
    if (!this.name) {
      throw new Error('Surface must have a name.')
    }
    if (this.name.indexOf('/') > -1) {
      // because we are using '/' to deal with nested surfaces (isolated nodes)
      throw new Error("Surface.name must not contain '/'")
    }
    // this path is an identifier unique for this surface
    // considering nesting in IsolatedNodes
    this._surfaceId = createSurfaceId(this);

    this.clipboard = new Clipboard(this.editorSession, {
      converterRegistry: this.context.converterRegistry
    });

    this.domSelection = this.context.domSelection;
    if (!this.domSelection) { throw new Error('DOMSelection instance must be provided via context.') }

    this.domObserver = null;

    // HACK: we need to listen to mousup on document
    // to catch events outside the surface
    if (inBrowser) {
      this.documentEl = DefaultDOMElement.wrapNativeElement(window.document);
    }

    // set when editing is enabled
    this.undoEnabled = true;

    // a registry for TextProperties which allows us to dispatch changes
    this._textProperties = {};

    this._state = {
      // true if the document session's selection is addressing this surface
      skipNextFocusEvent: false
    };
  }

  if ( Component$$1 ) Surface.__proto__ = Component$$1;
  Surface.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Surface.prototype.constructor = Surface;

  var prototypeAccessors = { id: {} };

  Surface.prototype.getChildContext = function getChildContext () {
    return {
      surface: this,
      doc: this.getDocument(),
      // HACK: clearing isolatedNodeComponent so that we can easily know
      // if this surface is within an isolated node
      isolatedNodeComponent: null
    }
  };

  Surface.prototype.didMount = function didMount () {
    if (this.context.surfaceManager) {
      this.context.surfaceManager.registerSurface(this);
    }
    this.editorSession.onRender('selection', this._onSelectionChanged, this);
  };


  Surface.prototype.dispose = function dispose () {
    this.editorSession.off(this);
    if (this.domObserver) {
      this.domObserver.disconnect();
    }
    if (this.context.surfaceManager) {
      this.context.surfaceManager.unregisterSurface(this);
    }
  };

  Surface.prototype.didUpdate = function didUpdate () {
    this._updateContentEditableState();
  };

  Surface.prototype.render = function render ($$) {
    var tagName = this.props.tagName || 'div';
    var el = $$(tagName)
      .addClass('sc-surface')
      .attr('tabindex', 2)
      .attr('data-surface-id', this.id);

    if (!this.isDisabled()) {
      if (this.isEditable()) {
        // Keyboard Events
        el.on('keydown', this.onKeyDown);
        // OSX specific handling of dead-keys
        if (!platform.isIE) {
          el.on('compositionstart', this.onCompositionStart);
        }
        // Note: TextEvent in Chrome/Webkit is the easiest for us
        // as it contains the actual inserted string.
        // Though, it is not available in FF and not working properly in IE
        // where we fall back to a ContentEditable backed implementation.
        if (inBrowser && window.TextEvent && !platform.isIE) {
          el.on('textInput', this.onTextInput);
        } else {
          el.on('keypress', this.onTextInputShim);
        }
      }
      if (!this.isReadonly()) {
        // Mouse Events
        el.on('mousedown', this.onMouseDown);
        el.on('contextmenu', this.onContextMenu);
        // disable drag'n'drop
        // we will react on this to render a custom selection
        el.on('focus', this.onNativeFocus);
        el.on('blur', this.onNativeBlur);
        // activate the clipboard
        this.clipboard.attach(el);
      }

    }
    return el
  };

  Surface.prototype.renderNode = function renderNode ($$, node) {
    var doc = this.getDocument();
    var componentRegistry = this.getComponentRegistry();
    var ComponentClass = componentRegistry.get(node.type);
    if (!ComponentClass) {
      console.error('Could not resolve a component for type: ' + node.type);
      ComponentClass = UnsupportedNodeComponent;
    }
    return $$(ComponentClass, {
      doc: doc,
      node: node
    }).ref(node.id)
  };

  Surface.prototype.getComponentRegistry = function getComponentRegistry () {
    return this.context.componentRegistry || this.props.componentRegistry
  };

  Surface.prototype.getName = function getName () {
    return this.name
  };

  Surface.prototype.getId = function getId () {
    return this._surfaceId
  };

  Surface.prototype.isDisabled = function isDisabled () {
    return this.props.disabled
  };

  Surface.prototype.isEditable = function isEditable () {
    return (this.props.editing === "full" || this.props.editing === undefined)
  };

  Surface.prototype.isSelectable = function isSelectable () {
    return (this.props.editing === "selection" || this.props.editing === "full")
  };

  Surface.prototype.isReadonly = function isReadonly () {
    return this.props.editing === "readonly"
  };

  Surface.prototype.getElement = function getElement () {
    return this.el
  };

  Surface.prototype.getDocument = function getDocument () {
    return this.editorSession.getDocument()
  };

  Surface.prototype.getEditorSession = function getEditorSession () {
    return this.editorSession
  };

  Surface.prototype.isEnabled = function isEnabled () {
    return !this.state.disabled
  };

  Surface.prototype.isContainerEditor = function isContainerEditor () {
    return false
  };

  Surface.prototype.hasNativeSpellcheck = function hasNativeSpellcheck () {
    return this.props.spellcheck === 'native'
  };

  Surface.prototype.getContainerId = function getContainerId () {
    return null
  };

  Surface.prototype.blur = function blur () {
    if (this.el) {
      this.el.blur();
    }
  };

  Surface.prototype.focus = function focus () {
    if (this.isDisabled()) { return }
    // console.log('Focusing surface %s explicitly with Surface.focus()', this.getId());
    // NOTE: FF is causing problems with dynamically activated contenteditables
    // and focusing
    if (platform.isFF) {
      this.domSelection.clear();
      this.el.getNativeElement().blur();
    }
    this._focus();
  };

  // As the DOMSelection is owned by the Editor now, rerendering could now be done by someone else, e.g. the SurfaceManager?
  Surface.prototype.rerenderDOMSelection = function rerenderDOMSelection () {
    if (this.isDisabled()) { return }
    if (inBrowser) {
      // console.log('Surface.rerenderDOMSelection', this.__id__);
      var sel = this.editorSession.getSelection();
      if (sel.surfaceId === this.getId()) {
        this.domSelection.setSelection(sel);
        // this will let our parents know that the DOM selection is ready
        this.send('domSelectionRendered');
      }
    }
  };

  Surface.prototype.getDomNodeForId = function getDomNodeForId (nodeId) {
    return this.el.getNativeElement().querySelector('*[data-id="'+nodeId+'"]')
  };

  /* Event handlers */

  /*
   * Handle document key down events.
   */
  Surface.prototype.onKeyDown = function onKeyDown (event) {
    if (!this._shouldConsumeEvent(event)) { return }
    // console.log('Surface.onKeyDown()', this.getId());

    // ignore fake IME events (emitted in IE and Chromium)
    if ( event.which === 229 ) { return }

    // core handlers for cursor movements and editor interactions
    switch ( event.keyCode ) {
      // Cursor movements
      case keys.LEFT:
      case keys.RIGHT:
        return this._handleLeftOrRightArrowKey(event)
      case keys.UP:
      case keys.DOWN:
        return this._handleUpOrDownArrowKey(event)
      case keys.HOME:
      case keys.END:
        return this._handleHomeOrEndKey(event)
      case keys.PAGEUP:
      case keys.PAGEDOWN:
        return this._handlePageUpOrDownKey(event)
      // Input (together with text-input)
      case keys.ENTER:
        return this._handleEnterKey(event)
      case keys.SPACE:
        return this._handleSpaceKey(event)
      case keys.TAB:
        return this._handleTabKey(event)
      case keys.BACKSPACE:
      case keys.DELETE:
        return this._handleDeleteKey(event)
      default:
        break
    }

    // keyboard shortcuts
    this.editorSession.keyboardManager.onKeydown(event);
  };

  Surface.prototype.onTextInput = function onTextInput (event) {
    if (!this._shouldConsumeEvent(event)) { return }
    // console.log("TextInput:", event);
    event.preventDefault();
    event.stopPropagation();
    if (!event.data) { return }

    var text = event.data;
    if (!this.editorSession.keyboardManager.onTextInput(text)) {
      this.editorSession.transaction(function (tx) {
        tx.insertText(text);
      }, { action: 'type' });
    }
  };

  // Handling Dead-keys under OSX
  Surface.prototype.onCompositionStart = function onCompositionStart (event) {
    if (!this._shouldConsumeEvent(event)) { return }
  };

  // TODO: do we need this anymore?
  Surface.prototype.onTextInputShim = function onTextInputShim (event) {
    if (!this._shouldConsumeEvent(event)) { return }
    // Filter out non-character keys
    if (
      // Catches most keys that don't produce output (charCode === 0, thus no character)
      event.which === 0 || event.charCode === 0 ||
      // Opera 12 doesn't always adhere to that convention
      event.keyCode === keys.TAB || event.keyCode === keys.ESCAPE ||
      // prevent combinations with meta keys, but not alt-graph which is represented as ctrl+alt
      Boolean(event.metaKey) || (Boolean(event.ctrlKey)^Boolean(event.altKey))
    ) {
      return
    }
    var character = String.fromCharCode(event.which);
    if (!event.shiftKey) {
      character = character.toLowerCase();
    }
    event.preventDefault();
    event.stopPropagation();
    if (!this.editorSession.keyboardManager.onTextInput(character)) {
      if (character.length>0) {
        this.editorSession.transaction(function (tx) {
          tx.insertText(character);
        }, { action: 'type' });
      }
    }
  };

  // TODO: the whole mouse event based selection mechanism needs
  // to be redesigned. The current implementation works basically
  // though, there are some things which do not work well cross-browser
  // particularly, double- and triple clicks.
  // also it turned out to be problematic to react on mouse down instantly
  Surface.prototype.onMouseDown = function onMouseDown (event) {
    if (!this._shouldConsumeEvent(event)) { return }

    // EXPERIMENTAL: trying to 'reserve' a mousedown event
    // so that parents know that they shouldn't react
    // This is similar to event.stopPropagation() but without
    // side-effects.
    // Note: some browsers do not do clicks, selections etc. on children if propagation is stopped
    if (event.__reserved__) {
      // console.log('%s: mousedown already reserved by %s', this.id, event.__reserved__.id)
      return
    } else {
      // console.log('%s: taking mousedown ', this.id)
      event.__reserved__ = this;
    }

    // NOTE: this is here to make sure that this surface is contenteditable
    // For instance, IsolatedNodeComponent sets contenteditable=false on this element
    // to achieve selection isolation
    if (this.isEditable()) {
      this.el.setAttribute('contenteditable', true);
    }

    // TODO: what is this exactly?
    if ( event.button !== 0 ) {
      return
    }

    // special treatment for triple clicks
    if (!(platform.isIE && platform.version<12) && event.detail >= 3) {
      var sel = this.getEditorSession().getSelection();
      if (sel.isPropertySelection()) {
        this._selectProperty(sel.path);
        event.preventDefault();
        event.stopPropagation();
        return
      } else if (sel.isContainerSelection()) {
        this._selectProperty(sel.startPath);
        event.preventDefault();
        event.stopPropagation();
        return
      }
    }
    // 'mouseDown' is triggered before 'focus' so we tell
    // our focus handler that we are already dealing with it
    // The opposite situation, when the surface gets focused e.g. using keyboard
    // then the handler needs to kick in and recover a persisted selection or such
    this._state.skipNextFocusEvent = true;

    // Bind mouseup to the whole document in case of dragging out of the surface
    if (this.documentEl) {
      // TODO: we should handle mouse up only if we started a drag (and the selection has really changed)
      this.documentEl.on('mouseup', this.onMouseUp, this, { once: true });
    }
  };

  Surface.prototype.onMouseUp = function onMouseUp (e) {
    // ATTENTION: filtering events does not make sense here,
    // as we need to make sure that pick the selection even
    // when the mouse is released outside the surface
    // if (!this._shouldConsumeEvent(e)) return
    e.stopPropagation();
    // console.log('mouseup on', this.getId());
    // ATTENTION: this delay is necessary for cases the user clicks
    // into an existing selection. In this case the window selection still
    // holds the old value, and is set to the correct selection after this
    // being called.
    setTimeout(function() {
      var sel = this.domSelection.getSelection();
      this._setSelection(sel);
    }.bind(this));
  };

  // When a user right clicks the DOM selection is updated (in Chrome the nearest
  // word gets selected). Like we do with the left mouse clicks we need to sync up
  // our model selection.
  Surface.prototype.onContextMenu = function onContextMenu (event) {
    if (!this._shouldConsumeEvent(event)) { return }
    var sel = this.domSelection.getSelection();
    this._setSelection(sel);
  };

  Surface.prototype.onNativeBlur = function onNativeBlur () {
    // console.log('Native blur on surface', this.getId());
    var _state = this._state;
    _state.hasNativeFocus = false;
  };

  Surface.prototype.onNativeFocus = function onNativeFocus () {
    // console.log('Native focus on surface', this.getId());
    var _state = this._state;
    _state.hasNativeFocus = true;
  };

  // Internal implementations


  Surface.prototype._onSelectionChanged = function _onSelectionChanged (selection) {
    var newMode = this._deriveModeFromSelection(selection);
    if (this.state.mode !== newMode) {
      this.extendState({
        mode: newMode
      });
    }
  };

  // helper to manage surface mode which is derived from the current selection
  Surface.prototype._deriveModeFromSelection = function _deriveModeFromSelection (sel) {
    if (!sel) { return null }
    var surfaceId = sel.surfaceId;
    var id = this.getId();
    var mode;
    if (startsWith$2(surfaceId, id)) {
      if (surfaceId.length === id.length) {
        mode = 'focused';
      } else {
        mode = 'co-focused';
      }
    }
    return mode
  };

  Surface.prototype._updateContentEditableState = function _updateContentEditableState () {
    // NOTE: managing contenteditable is difficult in
    // order to achieve a correct behavior for IsolatedNodes
    // For 'closed' isolated nodes it is important that the parents'
    // contenteditables are all false. Otherwise, the cursor
    // can leave the isolated area.
    var enableContenteditable = false;
    if (this.isEditable() && !this.props.disabled) {
      enableContenteditable = true;
      if (this.state.mode === 'co-focused') {
        var selState = this.context.editorSession.getSelectionState();
        var sel = selState.getSelection();
        var surface = this.context.surfaceManager.getSurface(sel.surfaceId);
        if (surface) {
          var isolatedNodeComponent = surface.context.isolatedNodeComponent;
          if (isolatedNodeComponent) {
            enableContenteditable = isolatedNodeComponent.isOpen();
          }
        }
      }
    }
    if (enableContenteditable) {
      this.el.setAttribute('contenteditable', true);
    } else {
      // TODO: find out what is better
      this.el.removeAttribute('contenteditable');
    }
  };

  Surface.prototype._focus = function _focus () {
    this._state.hasNativeFocus = true;
    // HACK: we must not focus explicitly in Chrome/Safari
    // as otherwise we get a crazy auto-scroll
    // Still, this is ok, as everything is working fine
    // there, without that (as opposed to FF/Edge)
    if (this.el && !platform.isWebkit) {
      this._state.skipNextFocusEvent = true;
      // ATTENTION: unfortunately, focusing the contenteditable does lead to auto-scrolling
      // in some browsers
      this.el.focus();
      this._state.skipNextFocusEvent = false;
    }
  };

  Surface.prototype._handleLeftOrRightArrowKey = function _handleLeftOrRightArrowKey (event) {
    event.stopPropagation();
    var direction = (event.keyCode === keys.LEFT) ? 'left' : 'right';
    // Note: we need this timeout so that CE updates the DOM selection first
    // before we map it to the model
    window.setTimeout(function() {
      this._updateModelSelection({direction: direction});
    }.bind(this));
  };

  Surface.prototype._handleUpOrDownArrowKey = function _handleUpOrDownArrowKey (event) {
    event.stopPropagation();
    // Note: we need this timeout so that CE updates the DOM selection first
    // before we map it to the model
    window.setTimeout(function() {
      var options = {
        direction: (event.keyCode === keys.UP) ? 'left' : 'right'
      };
      this._updateModelSelection(options);
    }.bind(this));
  };

  Surface.prototype._handleHomeOrEndKey = function _handleHomeOrEndKey (event) {
    event.stopPropagation();
    // Note: we need this timeout so that CE updates the DOM selection first
    // before we map it to the model
    window.setTimeout(function() {
      var options = {
        direction: (event.keyCode === keys.HOME) ? 'left' : 'right'
      };
      this._updateModelSelection(options);
    }.bind(this));
  };

  Surface.prototype._handlePageUpOrDownKey = function _handlePageUpOrDownKey (event) {
    event.stopPropagation();
    // Note: we need this timeout so that CE updates the DOM selection first
    // before we map it to the model
    window.setTimeout(function() {
      var options = {
        direction: (event.keyCode === keys.PAGEUP) ? 'left' : 'right'
      };
      this._updateModelSelection(options);
    }.bind(this));
  };

  Surface.prototype._handleSpaceKey = function _handleSpaceKey (event) {
    event.preventDefault();
    event.stopPropagation();
    this.editorSession.transaction(function (tx) {
      tx.insertText(' ');
    }, { action: 'type' });
  };

  Surface.prototype._handleTabKey = function _handleTabKey (event) {
    var this$1 = this;

    event.stopPropagation();
    window.setTimeout(function (){
      this$1._updateModelSelection();
    });
  };

  Surface.prototype._handleEnterKey = function _handleEnterKey (event) {
    event.preventDefault();
    event.stopPropagation();
    this.editorSession.transaction(function (tx) {
      tx.break();
    }, { action: 'break' });
  };

  Surface.prototype._handleDeleteKey = function _handleDeleteKey (event) {
    event.preventDefault();
    event.stopPropagation();
    var direction = (event.keyCode === keys.BACKSPACE) ? 'left' : 'right';
    this.editorSession.transaction(function (tx) {
      tx.deleteCharacter(direction);
    }, { action: 'delete' });
  };

  Surface.prototype._hasNativeFocus = function _hasNativeFocus () {
    return Boolean(this._state.hasNativeFocus)
  };

  Surface.prototype._setSelection = function _setSelection (sel) {
    // Since we allow the surface be blurred natively when clicking
    // on tools we now need to make sure that the element is focused natively
    // when we set the selection
    // This is actually only a problem on FF, other browsers set the focus implicitly
    // when a new DOM selection is set.
    // ATTENTION: in FF 44 this was causing troubles, making the CE unselectable
    // until the next native blur.
    // TODO: check if this is still necessary
    if (!sel.isNull() && sel.surfaceId === this.id && platform.isFF) {
      this._focus();
    }
    this.editorSession.setSelection(sel);
  };

  Surface.prototype._updateModelSelection = function _updateModelSelection (options) {
    var sel = this.domSelection.getSelection(options);
    // console.log('Surface: updating model selection', sel.toString());
    // NOTE: this will also lead to a rerendering of the selection
    // via session.on('update')
    this._setSelection(sel);
  };

  Surface.prototype._selectProperty = function _selectProperty (path) {
    var doc = this.getDocument();
    var text = doc.get(path);
    this._setSelection(doc.createSelection({
      type: 'property',
      path: path,
      startOffset: 0,
      endOffset: text.length
    }));
  };

  // internal API for TextProperties to enable dispatching
  // TextProperty components are registered via path
  Surface.prototype._registerTextProperty = function _registerTextProperty (textPropertyComponent) {
    var path = textPropertyComponent.getPath();
    this._textProperties[path] = textPropertyComponent;
  };

  Surface.prototype._unregisterTextProperty = function _unregisterTextProperty (textPropertyComponent) {
    var path = textPropertyComponent.getPath();
    if (this._textProperties[path] === textPropertyComponent) {
      delete this._textProperties[path];
    }
  };

  Surface.prototype._getTextPropertyComponent = function _getTextPropertyComponent (path) {
    return this._textProperties[path]
  };

  // TODO: we could integrate container node rendering into this helper
  // TODO: this helper should be available also in non surface context
  Surface.prototype._renderNode = function _renderNode ($$, nodeId) {
    var doc = this.getDocument();
    var node = doc.get(nodeId);
    var componentRegistry = this.context.componentRegistry || this.props.componentRegistry;
    var ComponentClass = componentRegistry.get(node.type);
    if (!ComponentClass) {
      console.error('Could not resolve a component for type: ' + node.type);
      ComponentClass = UnsupportedNodeComponent;
    }
    return $$(ComponentClass, {
      doc: doc,
      node: node
    })
  };

  // only take care of events which are emitted on targets which belong to this surface
  Surface.prototype._shouldConsumeEvent = function _shouldConsumeEvent (event) {
    var comp = Component$$1.unwrap(event.target._wrapper);
    return (comp && (comp === this || comp.context.surface === this))
  };

  // Experimental: used by DragManager
  Surface.prototype.getSelectionFromEvent = function getSelectionFromEvent (event) {
    var domRange = getDOMRangeFromEvent(event);
    var sel = this.domSelection.getSelectionForDOMRange(domRange);
    sel.surfaceId = this.getId();
    return sel;
  };

  Surface.prototype.setSelectionFromEvent = function setSelectionFromEvent (event) {
    var sel = this.getSelectionFromEvent(event);
    if (sel) {
      this._state.skipNextFocusEvent = true;
      this._setSelection(sel);
    } else {
      console.error('Could not create a selection from event.');
    }
  };

  prototypeAccessors.id.get = function () {
    return this._surfaceId
  };

  Object.defineProperties( Surface.prototype, prototypeAccessors );

  return Surface;
}(Component));

Surface.prototype._isSurface = true;

/*
  Computes the id of a surface

  With IsolatedNodes, surfaces can be nested.
  In this case the id can be seen as a path from the top-most to the nested ones

  @examples

  - top-level surface: 'body'
  - table cell: 'body/t1/t1-A1.content'
  - figure caption: 'body/fig1/fig1-caption.content'
  - nested containers: 'body/section1'
*/
function createSurfaceId(surface) {
  var isolatedNodeComponent = surface.context.isolatedNodeComponent;
  if (isolatedNodeComponent) {
    var parentSurface = isolatedNodeComponent.context.surface;
    // nested containers
    if (surface.isContainerEditor()) {
      if (isolatedNodeComponent._isInlineNodeComponent) {
        return parentSurface.id + '/' + isolatedNodeComponent.props.node.id + '/' + surface.name
      } else {
        return parentSurface.id + '/' + surface.name
      }
    }
    // other isolated nodes such as tables, figures, etc.
    else {
      return parentSurface.id + '/' + isolatedNodeComponent.props.node.id + '/' + surface.name
    }
  } else {
    return surface.name
  }
}

/**
  Editor for a text property (annotated string). Needs to be
  instantiated inside a {@link ui/Controller} context.

  @class
  @component
  @extends ui/Surface

  @prop {String} name unique editor name
  @prop {String[]} path path to a text property
  @prop {ui/SurfaceCommand[]} commands array of command classes to be available

  @example

  Create a `TextPropertyEditor` for the `name` property of an author object. Allow emphasis annotations.

  ```js
  $$(TextPropertyEditor, {
    name: 'authorNameEditor',
    path: ['author_1', 'name'],
    commands: [EmphasisCommand]
  })
  ```
*/

var TextPropertyEditor = (function (Surface$$1) {
  function TextPropertyEditor(parent, props) {
    // making props.name optional
    props.name = props.name || props.path.join('.');
    Surface$$1.call(this, parent, props);

    if (!props.path) {
      throw new Error("Property 'path' is mandatory.")
    }
  }

  if ( Surface$$1 ) TextPropertyEditor.__proto__ = Surface$$1;
  TextPropertyEditor.prototype = Object.create( Surface$$1 && Surface$$1.prototype );
  TextPropertyEditor.prototype.constructor = TextPropertyEditor;

  TextPropertyEditor.prototype.render = function render ($$) {
    var el = Surface$$1.prototype.render.apply(this, arguments);
    el.addClass("sc-text-property-editor");

    if (!this.props.disabled) {
      el.addClass('sm-enabled');
      el.attr('contenteditable', true);
      // native spellcheck
      el.attr('spellcheck', this.props.spellcheck === 'native');
    }

    el.append(
      $$(TextPropertyComponent, {
        tagName: this.props.tagName || "div",
        path: this.props.path,
        withoutBreak: this.props.withoutBreak
      })
    );

    return el
  };

  TextPropertyEditor.prototype._handleEnterKey = function _handleEnterKey (event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.props.multiLine) {
      Surface$$1.prototype._handleEnterKey.call(this, event);
    }
  };

  TextPropertyEditor.prototype.getPath = function getPath () {
    return this.props.path
  };

  return TextPropertyEditor;
}(Surface));

TextPropertyEditor.prototype._isTextPropertyEditor = true;

var TableCellComponent = (function (Component$$1) {
  function TableCellComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) TableCellComponent.__proto__ = Component$$1;
  TableCellComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  TableCellComponent.prototype.constructor = TableCellComponent;

  TableCellComponent.prototype.render = function render ($$) {
    var node = this.props.node;
    var el = $$('td').addClass('sc-table-cell');
    el.append(
      $$(TextPropertyEditor, {
        path: node.getTextPath(),
        disabled: this.props.disabled
      }).ref('editor')
    );
    if (node.rowspan > 0) {
      el.attr('rowspan', node.rowspan);
    }
    if (node.colspan > 0) {
      el.attr('colspan', node.colspan);
    }
    return el
  };

  TableCellComponent.prototype.grabFocus = function grabFocus () {
    var node = this.props.node;
    this.context.editorSession.setSelection({
      type: 'property',
      path: node.getPath(),
      startOffset: node.getLength(),
      surfaceId: this.refs.editor.id
    });
  };

  return TableCellComponent;
}(Component));

TableCellComponent.prototype._isTableCellComponent = true;

var TableComponent = (function (Component$$1) {
  function TableComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) TableComponent.__proto__ = Component$$1;
  TableComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  TableComponent.prototype.constructor = TableComponent;

  TableComponent.prototype.render = function render ($$) {
    var this$1 = this;

    var el = $$('table').addClass('sc-table');
    var node = this.props.node;
    var doc = this.props.node.getDocument();
    var cells = this.props.node.cells;
    var rowCount = node.getRowCount();
    var colCount = node.getColCount();
    for (var i = 0; i < rowCount; i++) {
      var rowEl = $$('tr');
      for (var j = 0; j < colCount; j++) {
        var cellId = cells[i][j];
        // Merged cells (cellId is null) are skipped
        if (cellId) {
          var cellNode = doc.get(cellId);
          var cellEl = $$(TableCellComponent, {
            node: cellNode,
            disabled: this$1.props.disabled
          }).ref(cellNode.id);
          rowEl.append(cellEl);
        }
      }
      el.append(rowEl);
    }
    el.on('click', this.onClick);
    el.on('dblclick', this.onDblClick);
    return el
  };

  TableComponent.prototype.onClick = function onClick (event) {
    event.stopPropagation();
    // console.log('Clicked on Table', this.props.node.id, event.target)
  };

  // TODO: this should only be used for the initial table state
  TableComponent.prototype.onDblClick = function onDblClick (event) {
    event.stopPropagation();
    // console.log('DblClicked on Table', this.props.node.id, event.target)

    // HACK: assuming that if the event.target has a surface
    // it is a TextPropertyEditor of a cell
    var comp = Component$$1.unwrap(event.target);
    if (comp) {
      var cellComp;
      if (comp._isTableCellComponent) {
        cellComp = comp;
      } else if (comp._isTextPropertyEditor) {
        cellComp = comp.getParent();
      } else if (comp._isTextPropertyComponent) {
        cellComp = comp.getParent().getParent();
      } else {
        console.warn('TODO: find the right cell');
      }
      if (cellComp) {
        cellComp.grabFocus();
      }
    }
  };

  TableComponent.prototype.grabFocus = function grabFocus () {
    var cellId = this.props.node.cells[0][0];
    if (cellId) {
      var comp = this.refs[cellId];
      comp.grabFocus();
    }
  };

  return TableComponent;
}(Component));

TableComponent.hasDropzones = true;

/*
  Each time a resource node is created an automatic fetch is triggered. This
  happens only once. We may want to adapt other fetching strategies as well.

  TODO: Resources would be problematic in a realtime scenario atm, as all
  collaborators would trigger a fetch of the resource, when it should only
  be done by the user who created the resource explicitly
*/

var ResourceManager = function ResourceManager(editorSession, context) {
  this.editorSession = editorSession;
  this.context = context;
  this.editorSession.onRender('document', this._onDocumentChange, this);
};

ResourceManager.prototype._onDocumentChange = function _onDocumentChange (change) {
    var this$1 = this;

  var doc = this.editorSession.getDocument();
  forEach(change.created, function (node) {
    node = doc.get(node.id);
    if (node.constructor.isResource) {
      setTimeout(function () {
        this$1.triggerFetch(node);
      });
    }
  });
};

/*
  Trigger fetch of a given resource
*/
ResourceManager.prototype.triggerFetch = function triggerFetch (resource) {
    var this$1 = this;

  resource.fetchPayload(this.context, function (err, props) {
    if (err) {
      this$1._updateNode(resource.id, {
        errorMessage: err.toString()
      });
    } else {
      this$1._updateNode(resource.id, props);
    }
  });
};

/*
    Fill in node payload
*/
ResourceManager.prototype._updateNode = function _updateNode (nodeId, props) {
  var editorSession = this.editorSession;
  editorSession.transaction(function (tx) {
    forEach(props, function (val, key) {
      tx.set([nodeId, key], val);
    });
  });
};

var BRACKET = 'X';

/*
  Isolation Strategies:
    - default: IsolatedNode renders a blocker the content gets enabled by a double-click.
    - open: No blocker. Content is enabled when parent surface is.

    > Notes:

      The blocker is used to shield the inner UI and not to interfer with general editing gestures.
      In some cases however, e.g. a figure (with image and caption), it feels better if the content directly accessible.
      In this case, the content component must provide a means to drag the node, e.g. set `<img draggable=true>`.
      This works only in browsers that are able to deal with 'contenteditable' isles,
      i.e. a structure where the isolated node is contenteditable=false, and inner elements have contenteditable=true
      Does not work in Edge. Works in Chrome, Safari

      The the default unblocking gesture requires the content to implement a grabFocus() method, which should set the selection
      into one of the surfaces, or set a CustomSelection.
*/
var IsolatedNodeComponent = (function (AbstractIsolatedNodeComponent$$1) {
  function IsolatedNodeComponent() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    AbstractIsolatedNodeComponent$$1.apply(this, args);
  }

  if ( AbstractIsolatedNodeComponent$$1 ) IsolatedNodeComponent.__proto__ = AbstractIsolatedNodeComponent$$1;
  IsolatedNodeComponent.prototype = Object.create( AbstractIsolatedNodeComponent$$1 && AbstractIsolatedNodeComponent$$1.prototype );
  IsolatedNodeComponent.prototype.constructor = IsolatedNodeComponent;

  IsolatedNodeComponent.prototype.render = function render ($$) {
    var node = this.props.node;
    var ContentClass = this.ContentClass;
    var disabled = this.props.disabled;

    // console.log('##### IsolatedNodeComponent.render()', $$.capturing);
    var el = $$('div');
    el.addClass(this.getClassNames())
      .addClass('sc-isolated-node')
      .addClass('sm-'+this.props.node.type)
      .attr("data-id", node.id);
    if (disabled) {
      el.addClass('sm-disabled');
    }
    if (this.state.mode) {
      el.addClass('sm-'+this.state.mode);
    }
    if (!ContentClass.noStyle) {
      el.addClass('sm-default-style');
    }
    // always handle ESCAPE
    el.on('keydown', this.onKeydown);

    // console.log('##### rendering IsolatedNode', this.id)
    var shouldRenderBlocker = (
      this.blockingMode === 'closed' &&
      !this.state.unblocked
    );

    // HACK: we need something 'editable' where we can put DOM selection into,
    // otherwise native cursor navigation gets broken
    el.append(
      $$('div').addClass('se-bracket sm-left').ref('left')
        .append(BRACKET)
    );

    var content = this.renderContent($$, node, {
      disabled: this.props.disabled || shouldRenderBlocker
    }).ref('content');
    content.attr('contenteditable', false);

    el.append(content);
    el.append($$(Blocker).ref('blocker'));
    el.append(
      $$('div').addClass('se-bracket sm-right').ref('right')
        .append(BRACKET)
    );

    if (!shouldRenderBlocker) {
      el.addClass('sm-no-blocker');
      el.on('click', this.onClick)
        .on('dblclick', this.onDblClick);
    }
    el.on('mousedown', this._reserveMousedown, this);

    return el
  };

  IsolatedNodeComponent.prototype.getClassNames = function getClassNames () {
    return ''
  };

  IsolatedNodeComponent.prototype.getContent = function getContent () {
    return this.refs.content
  };

  IsolatedNodeComponent.prototype.selectNode = function selectNode () {
    // console.log('IsolatedNodeComponent: selecting node.');
    var editorSession = this.context.editorSession;
    var surface = this.context.surface;
    var nodeId = this.props.node.id;
    editorSession.setSelection({
      type: 'node',
      nodeId: nodeId,
      containerId: surface.getContainerId(),
      surfaceId: surface.id
    });
  };

  // EXPERIMENTAL: trying to catch clicks not handler by the
  // content when this is unblocked
  IsolatedNodeComponent.prototype.onClick = function onClick (event) {
    // console.log('### Clicked on IsolatedNode', this.id, event.target)
    event.stopPropagation();
  };

  IsolatedNodeComponent.prototype.onDblClick = function onDblClick (event) {
    // console.log('### DblClicked on IsolatedNode', this.id, event.target)
    event.stopPropagation();
  };

  IsolatedNodeComponent.prototype.grabFocus = function grabFocus (event) {
    var content = this.refs.content;
    if (content.grabFocus) {
      content.grabFocus(event);
    }
  };

  // EXPERIMENTAL: Surface and IsolatedNodeComponent communicate via flag on the mousedown event
  // and only reacting on click or mouseup when the mousedown has been reserved
  IsolatedNodeComponent.prototype._reserveMousedown = function _reserveMousedown (event) {
    if (event.__reserved__) {
      // console.log('%s: mousedown already reserved by %s', this.id, event.__reserved__.id)
      return
    } else {
      // console.log('%s: taking mousedown ', this.id)
      event.__reserved__ = this;
    }
  };

  IsolatedNodeComponent.prototype._deriveStateFromSelectionState = function _deriveStateFromSelectionState (selState) {
    var surface = this._getSurface(selState);
    var newState = { mode: null, unblocked: null};
    if (!surface) { return newState }
    // detect cases where this node is selected or co-selected by inspecting the selection
    if (surface === this.context.surface) {
      var sel = selState.getSelection();
      var nodeId = this.props.node.id;
      if (sel.isNodeSelection() && sel.getNodeId() === nodeId) {
        if (sel.isFull()) {
          newState.mode = 'selected';
          newState.unblocked = true;
        } else if (sel.isBefore()) {
          newState.mode = 'cursor';
          newState.position = 'before';
        } else if (sel.isAfter()) {
          newState.mode = 'cursor';
          newState.position = 'after';
        }
      }
      if (sel.isContainerSelection() && sel.containsNode(nodeId)) {
        newState.mode = 'co-selected';
      }
    } else {
      var isolatedNodeComponent = surface.context.isolatedNodeComponent;
      if (isolatedNodeComponent) {
        if (isolatedNodeComponent === this) {
          newState.mode = 'focused';
          newState.unblocked = true;
        } else {
          var isolatedNodes = this._getIsolatedNodes(selState);
          if (isolatedNodes.indexOf(this) > -1) {
            newState.mode = 'co-focused';
            newState.unblocked = true;
          }
        }
      }
    }
    return newState
  };

  return IsolatedNodeComponent;
}(AbstractIsolatedNodeComponent));

IsolatedNodeComponent.prototype._isIsolatedNodeComponent = true;

IsolatedNodeComponent.prototype._isDisabled = IsolatedNodeComponent.prototype.isDisabled;

IsolatedNodeComponent.getDOMCoordinate = function(comp, coor) {
  var ref = IsolatedNodeComponent.getDOMCoordinates(comp);
  var start = ref.start;
  var end = ref.end;
  if (coor.offset === 0) { return start }
  else { return end }
};

IsolatedNodeComponent.getDOMCoordinates = function(comp) {
  var left = comp.refs.left;
  var right = comp.refs.right;
  return {
    start: {
      container: left.getNativeElement(),
      offset: 0
    },
    end: {
      container: right.getNativeElement(),
      offset: right.getChildCount()
    }
  }
};

IsolatedNodeComponent.getCoordinate = function(nodeEl, options) {
  var comp = Component.unwrap(nodeEl, 'strict').context.isolatedNodeComponent;
  var offset = null;
  if (options.direction === 'left' || nodeEl === comp.refs.left.el) {
    offset = 0;
  } else if (options.direction === 'right' || nodeEl === comp.refs.right.el) {
    offset = 1;
  }
  var coor;
  if (offset !== null) {
    coor = new Coordinate([comp.props.node.id], offset);
    coor._comp = comp;
  }
  return coor
};

var Blocker = (function (Component$$1) {
  function Blocker () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) Blocker.__proto__ = Component$$1;
  Blocker.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Blocker.prototype.constructor = Blocker;

  Blocker.prototype.render = function render ($$) {
    return $$('div').addClass('sc-isolated-node-blocker')
      .attr('draggable', true)
      .attr('contenteditable', false)
      .on('click', this.onClick)
      .on('dblclick', this.onDblClick)
  };

  Blocker.prototype.onClick = function onClick (event) {
    if (event.target !== this.getNativeElement()) { return }
    // console.log('Clicked on Blocker of %s', this._getIsolatedNodeComponent().id, event)
    event.stopPropagation();
    var comp = this._getIsolatedNodeComponent();
    comp.extendState({ mode: 'selected', unblocked: true });
    comp.selectNode();
  };

  Blocker.prototype.onDblClick = function onDblClick (event) {
    // console.log('DblClicked on Blocker of %s', this.getParent().id, event)
    event.stopPropagation();
  };

  Blocker.prototype._getIsolatedNodeComponent = function _getIsolatedNodeComponent () {
    return this.context.isolatedNodeComponent
  };

  return Blocker;
}(Component));

// import last from '../util/last'
var DEBUG = false;

/*
  A class that maps DOM selections to model selections.

  There are some difficulties with mapping model selections:
  1. DOM selections can not model discontinuous selections.
  2. Not all positions reachable via ContentEditable can be mapped to model selections. For instance,
     there are extra positions before and after non-editable child elements.
  3. Some native cursor behaviors need to be overidden.

  @param {Editor} Editor component
 */
var DOMSelection = function DOMSelection(editor) {
  this.editor = editor;
  if (inBrowser) {
    this.wRange = window.document.createRange();
  }
  // keeping the last DOM and Model coordinates
  // TODO: why are we doing this?
  this.state = { dom: null, model: null };
};

/**
  Create a model selection by mapping the current DOM selection
  to model coordinates.

  @param {object} options
    - `direction`: `left` or `right`; a hint for disambiguations, used by Surface during cursor navigation.
  @returns {model/Selection}
*/
DOMSelection.prototype.getSelection = function getSelection (options) {
  // HACK: ignore this if not Browser (e.g. when running the test suite in node)
  if (!inBrowser) { return }
  var range = this.mapDOMSelection(options);
  var doc = this.editor.getDocument();
  // TODO: consolidate
  return doc._createSelectionFromRange(range)
};

DOMSelection.prototype.getSelectionForDOMRange = function getSelectionForDOMRange (wrange) {
  var range = this.mapDOMRange(wrange);
  var doc = this.editor.getDocument();
  return doc._createSelectionFromRange(range)
};

/*
  Maps the current DOM selection to a model range.

  @param {object} [options]
    - `direction`: `left` or `right`; a hint for disambiguations, used by Surface during cursor navigation.
  @returns {model/Range}
*/
DOMSelection.prototype.mapDOMSelection = function mapDOMSelection (options) {
  var wSel = window.getSelection();
  var state = this.state;
  var range;
  // Use this log whenever the mapping goes wrong to analyze what
  // is actually being provided by the browser
  if (DEBUG) { console.info('DOM->Model: ', wSel.anchorNode, wSel.anchorOffset, wSel.focusNode, wSel.focusOffset); }
  if (wSel.rangeCount === 0) { return _null() }
  var anchorNode = DefaultDOMElement.wrapNativeElement(wSel.anchorNode);
  if (wSel.isCollapsed) {
    var coor = this._getCoordinate(anchorNode, wSel.anchorOffset, options);
    if (!coor) { return _null() }
    range = _createRange({
      start: coor,
      end: coor
    });
  }
  else {
    var focusNode = DefaultDOMElement.wrapNativeElement(wSel.focusNode);
    range = this._getRange(anchorNode, wSel.anchorOffset, focusNode, wSel.focusOffset, options);
  }
  if (DEBUG) { console.info('DOM->Model: range ', range ? range.toString() : null); }
  state.model = range;
  return range

  function _null() {
    state.dom = null;
    state.model = null;
    return null
  }
};

/**
  Transfer a given model selection into the DOM.

  @param {model/Selection} sel
*/
DOMSelection.prototype.setSelection = function setSelection (sel) {
  // HACK: ignore this if not Browser (e.g. when running the test suite in node)
  if (!inBrowser) { return }
  var state = this.state;
  var wSel = window.getSelection();
  var wRange = this.wRange;
  if (!sel || sel.isNull()) { return this.clear() }
  // console.log('### DOMSelection: setting selection', sel.toString());
  var ref = this.mapModelToDOMCoordinates(sel);
    var start = ref.start;
    var end = ref.end;
  if (!start) { return this.clear() }
  if (sel.isReverse()) {
    var assign;
      (assign = [end, start], start = assign[0], end = assign[1]);
  }
  state.dom = {
    anchorNode: start.container,
    anchorOffset: start.offset,
    focusNode: end.container,
    focusOffset: end.offset
  };
  _set(state.dom);

  function _set(ref) {
      var anchorNode = ref.anchorNode;
      var anchorOffset = ref.anchorOffset;
      var focusNode = ref.focusNode;
      var focusOffset = ref.focusOffset;

    wSel.removeAllRanges();
    wRange.setStart(anchorNode, anchorOffset);
    wRange.setEnd(anchorNode, anchorOffset);
    wSel.addRange(wRange);
    if (focusNode !== anchorOffset || focusOffset !== anchorOffset) {
      wSel.extend(focusNode, focusOffset);
    }
  }
};

DOMSelection.prototype.mapModelToDOMCoordinates = function mapModelToDOMCoordinates (sel) {
  if (DEBUG) { console.info('Model->DOM: sel =', sel.toString()); }
  var rootEl;
  var surface = this.editor.surfaceManager.getSurface(sel.surfaceId);
  if (!surface) {
    console.warn('Selection should have "surfaceId" set.');
    rootEl = this.editor.el;
  } else {
    rootEl = surface.el;
  }
  if (sel.isNull() || sel.isCustomSelection()) {
    return {}
  }

  var start, end;
  if (sel.isPropertySelection() || sel.isContainerSelection()) {
    start = this._getDOMCoordinate(rootEl, sel.start);
    if (!start) {
      console.warn('FIXME: selection seems to be invalid.');
      return {}
    }
    if (sel.isCollapsed()) {
      end = start;
    } else {
      end = this._getDOMCoordinate(rootEl, sel.end);
      if (!end) {
        console.warn('FIXME: selection seems to be invalid.');
        return {}
      }
    }
  } else if (sel.isNodeSelection()) {
    var comp = Component.unwrap(rootEl.find('*[data-id="'+sel.getNodeId()+'"]'));
    if (!comp) {
      console.error('Could not find component with id', sel.getNodeId());
      return {}
    }
    if (comp._isIsolatedNodeComponent) {
      var coors = IsolatedNodeComponent.getDOMCoordinates(comp, sel);
      start = coors.start;
      end = coors.end;
      // Note: ATM we do not render collapsed NodeSelections differently
      // if (sel.isAfter()) start = end
      // else if (sel.isBefore()) end = start
    } else {
      var _nodeEl = comp.el;
      start = {
        container: _nodeEl.getNativeElement(),
        offset: 0
      };
      end = {
        container: _nodeEl.getNativeElement(),
        offset: _nodeEl.getChildCount()
      };
    }
  }
  if (DEBUG) { console.info('Model->DOM:', start.container, start.offset, end.container, end.offset, 'isReverse?', sel.isReverse()); }
  return {start: start,end: end}
};

DOMSelection.prototype._getDOMCoordinate = function _getDOMCoordinate (rootEl, coor) {
  var comp, domCoor = null;
  if (coor.isNodeCoordinate()) {
    comp = Component.unwrap(rootEl.find('*[data-id="'+coor.getNodeId()+'"]'));
    if (comp) {
      if (comp._isIsolatedNodeComponent) {
        domCoor = IsolatedNodeComponent.getDOMCoordinate(comp, coor);
      } else {
        var domOffset = 0;
        if (coor.offset > 0) {
          domOffset = comp.getChildCount();
        }
        domCoor = {
          container: comp.getNativeElement(),
          offset: domOffset
        };
      }
    }
  } else {
    comp = Component.unwrap(rootEl.find('.sc-text-property[data-path="'+coor.path.join('.')+'"]'));
    if (comp) {
      domCoor = comp.getDOMCoordinate(coor.offset);
    }
  }
  return domCoor
};

/*
  Map a DOM range to a model range.

  @param {Range} range
  @returns {model/Range}
*/
DOMSelection.prototype.mapDOMRange = function mapDOMRange (wRange, options) {
  return this._getRange(
    DefaultDOMElement.wrapNativeElement(wRange.startContainer),
    wRange.startOffset,
    DefaultDOMElement.wrapNativeElement(wRange.endContainer),
    wRange.endOffset, options)
};

/*
  Clear the DOM selection.
*/
DOMSelection.prototype.clear = function clear () {
  window.getSelection().removeAllRanges();
  this.state.dom = null;
  this.state.model = null;
};

DOMSelection.prototype.collapse = function collapse (dir) {
  var wSel = window.getSelection();
  var wRange;
  if (wSel.rangeCount > 0) {
    wRange = wSel.getRangeAt(0);
    wRange.collapse(dir === 'left');
    wSel.removeAllRanges();
    wSel.addRange(wRange);
  }
};

DOMSelection.prototype.select = function select (el) {
  var wSel = window.getSelection();
  var wRange = window.document.createRange();
  wRange.selectNode(el.getNativeElement());
  wSel.removeAllRanges();
  wSel.addRange(wRange);
};

DOMSelection.prototype.extend = function extend (el, offset) {
  var wSel = window.getSelection();
  wSel.extend(el.getNativeElement(), offset);
};

DOMSelection.prototype.setCursor = function setCursor (el, offset) {
  var wSel = window.getSelection();
  var wRange = window.document.createRange();
  wRange.setStart(el.getNativeElement(), offset);
  wSel.removeAllRanges();
  wSel.addRange(wRange);
};

/*
  Extract a model range from given DOM elements.

  @param {Node} anchorNode
  @param {number} anchorOffset
  @param {Node} focusNode
  @param {number} focusOffset
  @returns {model/Range}
*/
DOMSelection.prototype._getRange = function _getRange (anchorNode, anchorOffset, focusNode, focusOffset, options) {
    if ( options === void 0 ) options = {};

  var isReverse = DefaultDOMElement.isReverse(anchorNode, anchorOffset, focusNode, focusOffset);
  var isCollapsed = (anchorNode === focusNode && anchorOffset === focusOffset);
  var start, end;
  if (isCollapsed) {
    start = end = this._getCoordinate(anchorNode, anchorOffset, options);
  } else {
    start = this._getCoordinate(anchorNode, anchorOffset, { direction: isReverse ? 'right' : 'left' });
    end = this._getCoordinate(focusNode, focusOffset, options);
  }
  if (start && end) {
    return _createRange({ start: start, end: end, isReverse: isReverse })
  } else {
    return null
  }
};

/*
  Map a DOM coordinate to a model coordinate.

  @param {Node} node
  @param {number} offset
  @param {object} options
  @param {object} [options]
    - `direction`: `left` or `right`; a hint for disambiguation.
  @returns {model/Coordinate}

  @info

  `options.direction` can be used to control the result when this function is called
  after cursor navigation. The root problem is that we are using ContentEditable on
  Container level (as opposed to TextProperty level). The native ContentEditable allows
  cursor positions which do not make sense in the model sense.

  For example,

  ```
  <div contenteditable=true>
    <p data-path="p1.content">foo</p>
    <img>
    <p data-path="p1.content">bar</p>
  </div>
  ```
  would allow to set the cursor directly before or after the image, which
  we want to prevent, as it is not a valid insert position for text.
  Instead, if we find the DOM selection in such a situation, then we map it to the
  closest valid model address. And this depends on the direction of movement.
  Moving `left` would provide the previous address, `right` would provide the next address.
  The default direction is `right`.
*/
DOMSelection.prototype._getCoordinate = function _getCoordinate (nodeEl, offset, options) {
    if ( options === void 0 ) options={};

  var coor = null;
  // this deals with a cursor in a TextProperty
  if (!coor) {
    coor = TextPropertyComponent.getCoordinate(this.editor.el, nodeEl, offset);
  }
  var comp = Component.unwrap(nodeEl);
  if (!coor && comp) {
    // let IsolatedNodeComponent figure out where the selection is
    if (comp.context.isolatedNodeComponent) {
      coor = IsolatedNodeComponent.getCoordinate(nodeEl, options);
    }
  }
  // Edge-cases: These handlers are hacked so that the case is covered,
  // not solved 'elegantly'
  if (!coor) {
    // as in #354: sometimes anchor or focus is the surface itself
    if (comp && comp._isContainerEditor) {
      var childIdx = (offset === 0) ? 0 : offset-1;
      var isBefore = (offset === 0);
      var container = comp.getContainer();
      var childNode = container.getNodeAt(childIdx);
      var childComp = comp.getChildAt(childIdx);
      coor = new Coordinate([childNode.id], isBefore?0:1 );
      coor._comp = childComp;
    }
    // sometimes anchor or focus is a Node component with TextPropertyComponents as children (all TextNode Components)
    else if (nodeEl.isElementNode() && nodeEl.getChildCount() > 0) {
      var child = (offset > 0) ? nodeEl.getChildAt(offset-1) : nodeEl.firstChild;
      var prop;
      var childComp$1 = Component.unwrap(child);
      if (childComp$1 && childComp$1._isTextPropertyComponent) {
        prop = child;
      }
      // let prop = last(child.findAll('data-path'))
      if (prop) {
        coor = TextPropertyComponent.getCoordinate(nodeEl, prop, (offset > 0) ? prop.getChildCount() : 0);
      }
    }
  }
  return coor
};

/*
 Helper for creating a model range correctly
 as for model/Range start should be before end.

 In contrast to that, DOM selections are described with anchor and focus coordinates,
 i.e. bearing the information of direction implicitly.
 To simplify the implementation we treat anchor and focus equally
 and only at the end exploit the fact deriving an isReverse flag
 and bringing start and end in the correct order.
*/
function _createRange(ref) {
  var start = ref.start;
  var end = ref.end;
  var isReverse = ref.isReverse;

  if (isReverse) {
    var assign;
    (assign = [end, start], start = assign[0], end = assign[1]);
  }
  if (!start._comp || !end._comp) {
    console.error('FIXME: getCoordinate() should provide a component instance');
    return null
  }
  var surface = start._comp.context.surface;
  if (!surface) {
    console.error('FIXME: Editable components should have their surface in the context');
    return null
  }
  if (surface !== end._comp.context.surface) {
    console.error('Coordinates are within two different surfaces. Can not create a selection.');
    return null
  }
  return new Range(start, end, isReverse, surface.getContainerId(), surface.id)
}

/**
  Reusable abstract editor implementation.

  @example

  ```js
  class SimpleWriter extends AbstractEditor {
    render($$) {
      // render editor
    }
  }
  ```
*/
var AbstractEditor = (function (Component$$1) {
  function AbstractEditor() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Component$$1.apply(this, args);
    this._initialize(this.props);
  }

  if ( Component$$1 ) AbstractEditor.__proto__ = Component$$1;
  AbstractEditor.prototype = Object.create( Component$$1 && Component$$1.prototype );
  AbstractEditor.prototype.constructor = AbstractEditor;

  AbstractEditor.prototype._initialize = function _initialize (props) {
    if (!props.editorSession) {
      throw new Error('EditorSession instance required');
    }
    this.editorSession = props.editorSession;
    this.doc = this.editorSession.getDocument();

    var configurator = this.editorSession.getConfigurator();
    this.componentRegistry = configurator.getComponentRegistry();
    this.toolGroups = configurator.getToolGroups();
    this.labelProvider = configurator.getLabelProvider();
    this.iconProvider = configurator.getIconProvider();

    // legacy
    this.surfaceManager = this.editorSession.surfaceManager;
    this.commandManager = this.editorSession.commandManager;
    this.dragManager = this.editorSession.dragManager;
    this.macroManager = this.editorSession.macroManager;
    this.converterRegistry = this.editorSession.converterRegistry;
    this.globalEventHandler = this.editorSession.globalEventHandler;
    this.editingBehavior = this.editorSession.editingBehavior;
    this.markersManager = this.editorSession.markersManager;

    this.resourceManager = new ResourceManager(this.editorSession, this.getChildContext());

    this.domSelection = new DOMSelection(this);
  };

  /**
    Define the editors render method here.
  */
  AbstractEditor.prototype.render = function render () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return Component$$1.prototype.render.apply(this, args)
  };

  AbstractEditor.prototype.willReceiveProps = function willReceiveProps (nextProps) {
    var newSession = nextProps.editorSession;
    var shouldDispose = newSession && newSession !== this.editorSession;
    if (shouldDispose) {
      this._dispose();
      this._initialize(nextProps);
    }
  };

  AbstractEditor.prototype.dispose = function dispose () {
    this._dispose();
  };

  AbstractEditor.prototype._dispose = function _dispose () {
    // Note: we need to clear everything, as the childContext
    // changes which is immutable
    this.empty();
  };

  AbstractEditor.prototype.getChildContext = function getChildContext () {
    return {
      editor: this,
      editorSession: this.editorSession,
      doc: this.doc, // TODO: remove in favor of editorSession
      componentRegistry: this.componentRegistry,
      surfaceManager: this.surfaceManager,
      domSelection: this.domSelection,
      commandManager: this.commandManager,
      markersManager: this.markersManager,
      converterRegistry: this.converterRegistry,
      dragManager: this.dragManager,
      editingBehavior: this.editingBehavior,
      globalEventHandler: this.globalEventHandler,
      iconProvider: this.iconProvider,
      labelProvider: this.labelProvider,
      resourceManager: this.resourceManager,
      // ATTENTION: this is a map of tool target names to maps of tool names to tools
      // i.e. a declarative way to map tools to tool groups
      toolGroups: this.toolGroups,
    }
  };

  AbstractEditor.prototype.getDocument = function getDocument () {
    return this.editorSession.getDocument()
  };

  AbstractEditor.prototype.getConfigurator = function getConfigurator () {
    return this.editorSession.getConfigurator()
  };

  AbstractEditor.prototype.getEditorSession = function getEditorSession () {
    return this.editorSession
  };

  AbstractEditor.prototype.getComponentRegistry = function getComponentRegistry () {
    return this.componentRegistry
  };

  AbstractEditor.prototype.onSessionUnlocked = function onSessionUnlocked () {
    if (this.refs.blocker) {
      this.refs.blocker.remove();
    }
  };

  return AbstractEditor;
}(Component));

var EditingBehavior = function EditingBehavior() {
  this._merge = {};
  this._mergeComponents = {};
  this._break = {};
};

EditingBehavior.prototype.defineMerge = function defineMerge (firstType, secondType, impl) {
  if (!this._merge[firstType]) {
    this._merge[firstType] = {};
  }
  this._merge[firstType][secondType] = impl;
  return this
};

EditingBehavior.prototype.canMerge = function canMerge (firstType, secondType) {
  return (this._merge[firstType] && this._merge[firstType][secondType])
};

EditingBehavior.prototype.getMerger = function getMerger (firstType, secondType) {
  return this._merge[firstType][secondType]
};

EditingBehavior.prototype.defineComponentMerge = function defineComponentMerge (nodeType, impl) {
  this._mergeComponents[nodeType] = impl;
};

EditingBehavior.prototype.canMergeComponents = function canMergeComponents (nodeType) {
  return this._mergeComponents[nodeType]
};

EditingBehavior.prototype.getComponentMerger = function getComponentMerger (nodeType) {
  return this._mergeComponents[nodeType]
};

EditingBehavior.prototype.defineBreak = function defineBreak (nodeType, impl) {
  this._break[nodeType] = impl;
  return this
};

EditingBehavior.prototype.canBreak = function canBreak (nodeType) {
  return this._break[nodeType]
};

EditingBehavior.prototype.getBreaker = function getBreaker (nodeType) {
  return this._break[nodeType]
};

// import platform from '../util/platform'
// import Component from '../ui/Component'

/**
  Represents a flow editor that manages a sequence of nodes in a container. Needs to be
  instantiated inside a {@link ui/Controller} context.

  @class ContainerEditor
  @component
  @extends ui/Surface

  @prop {String} name unique editor name
  @prop {String} containerId container id
  @prop {Object[]} textTypes array of textType definition objects
  @prop {ui/SurfaceCommand[]} commands array of command classes to be available

  @example

  Create a full-fledged `ContainerEditor` for the `body` container of a document.
  Allow Strong and Emphasis annotations and to switch text types between paragraph
  and heading at level 1.

  ```js
  $$(ContainerEditor, {
    name: 'bodyEditor',
    containerId: 'body',
    textTypes: [
      {name: 'paragraph', data: {type: 'paragraph'}},
      {name: 'heading1',  data: {type: 'heading', level: 1}}
    ],
    commands: [StrongCommand, EmphasisCommand, SwitchTextTypeCommand],
  })
  ```
*/

var ContainerEditor = (function (Surface$$1) {
  function ContainerEditor(parent, props, el) {
    // default props derived from the given props
    props.containerId = props.containerId || props.node.id;
    props.name = props.name || props.containerId || props.node.id;

    Surface$$1.call(this, parent, props, el);

    this.containerId = this.props.containerId;
    if (!isString(this.containerId)) {
      throw new Error("Property 'containerId' is mandatory.")
    }
    var doc = this.getDocument();
    this.container = doc.get(this.containerId);
    if (!this.container) {
      throw new Error('Container with id ' + this.containerId + ' does not exist.')
    }

    this.textTypes = this.props.textTypes || [];

    this.editingBehavior = this.context.editingBehavior || new EditingBehavior();

    this._deriveInternalState(this.props);
  }

  if ( Surface$$1 ) ContainerEditor.__proto__ = Surface$$1;
  ContainerEditor.prototype = Object.create( Surface$$1 && Surface$$1.prototype );
  ContainerEditor.prototype.constructor = ContainerEditor;

  // Note: this component is self managed
  ContainerEditor.prototype.shouldRerender = function shouldRerender (newProps) {
    if (newProps.disabled !== this.props.disabled) { return true }
    // TODO: we should still detect when the document has changed,
    // see https://github.com/substance/substance/issues/543
    return false
  };

  ContainerEditor.prototype.willReceiveProps = function willReceiveProps (newProps) {
    Surface$$1.prototype.willReceiveProps.apply(this, arguments);
    this._deriveInternalState(newProps);
  };

  ContainerEditor.prototype.didMount = function didMount () {
    Surface$$1.prototype.didMount.apply(this, arguments);
    var editorSession = this.getEditorSession();
    editorSession.onUpdate('document', this._onContainerChanged, this, {
      path: [this.getContainerId(), 'nodes']
    });

  };

  ContainerEditor.prototype.dispose = function dispose () {
    Surface$$1.prototype.dispose.apply(this, arguments);
    var editorSession = this.getEditorSession();
    editorSession.off(this);
  };

  ContainerEditor.prototype.render = function render ($$) {
    var el = Surface$$1.prototype.render.call(this, $$);

    var doc = this.getDocument();
    var containerId = this.getContainerId();
    var containerNode = doc.get(containerId);
    if (!containerNode) {
      console.warn('No container node found for ', containerId);
    }
    el.addClass('sc-container-editor container-node ' + containerId)
      .attr("data-id", containerId);

    // native spellcheck
    el.attr('spellcheck', this.props.spellcheck === 'native');

    containerNode.getNodes().forEach(function(node) {
      el.append(this._renderNode($$, node));
    }.bind(this));

    // No editing if disabled by user or container is empty
    if (!this.props.disabled && !this.isEmpty()) {
      el.addClass('sm-enabled');
      el.setAttribute('contenteditable', true);
    }

    return el
  };

  ContainerEditor.prototype._renderNode = function _renderNode ($$, node) {
    if (!node) { throw new Error('Illegal argument') }
    if (node.isText()) {
      return Surface$$1.prototype.renderNode.call(this, $$, node)
    } else {
      var componentRegistry = this.context.componentRegistry;
      var ComponentClass = componentRegistry.get(node.type);
      if (ComponentClass.prototype._isCustomNodeComponent || ComponentClass.prototype._isIsolatedNodeComponent) {
        return $$(ComponentClass, { node: node }).ref(node.id)
      } else {
        return $$(IsolatedNodeComponent, { node: node }).ref(node.id)
      }
    }
  };

  ContainerEditor.prototype._deriveInternalState = function _deriveInternalState (props) {
    var _state = this._state;
    if (!props.hasOwnProperty('enabled') || props.enabled) {
      _state.enabled = true;
    } else {
      _state.enabled = false;
    }
  };

  ContainerEditor.prototype._selectNextIsolatedNode = function _selectNextIsolatedNode (direction) {
    var selState = this.getEditorSession().getSelectionState();
    var node = (direction === 'left') ? selState.getPreviousNode() : selState.getNextNode();
    if (!node || !node.isIsolatedNode()) { return false }
    if (
      (direction === 'left' && selState.isFirst()) ||
      (direction === 'right' && selState.isLast())
    ) {
      this.getEditorSession().setSelection({
        type: 'node',
        nodeId: node.id,
        containerId: selState.getContainer().id,
        surfaceId: this.id
      });
      return true
    }
    return false
  };

  ContainerEditor.prototype._handleLeftOrRightArrowKey = function _handleLeftOrRightArrowKey (event) {
    var this$1 = this;

    event.stopPropagation();
    var doc = this.getDocument();
    var sel = this.getEditorSession().getSelection();
    var left = (event.keyCode === keys.LEFT);
    var right = !left;
    var direction = left ? 'left' : 'right';

    if (sel && !sel.isNull()) {
      var container = doc.get(sel.containerId, 'strict');

      // Don't react if we are at the boundary of the document
      if (sel.isNodeSelection()) {
        var nodePos = container.getPosition(doc.get(sel.getNodeId()));
        if ((left && nodePos === 0) || (right && nodePos === container.length-1)) {
          event.preventDefault();
          return
        }
      }

      if (sel.isNodeSelection() && !event.shiftKey) {
        this.domSelection.collapse(direction);
      }
    }

    window.setTimeout(function () {
      this$1._updateModelSelection({ direction: direction });
    });
  };

  ContainerEditor.prototype._handleUpOrDownArrowKey = function _handleUpOrDownArrowKey (event) {
    var this$1 = this;

    event.stopPropagation();
    var doc = this.getDocument();
    var sel = this.getEditorSession().getSelection();
    var up = (event.keyCode === keys.UP);
    var down = !up;
    var direction = up ? 'left' : 'right';

    if (sel && !sel.isNull()) {
      var container = doc.get(sel.containerId, 'strict');
      // Don't react if we are at the boundary of the document
      if (sel.isNodeSelection()) {
        var nodePos = container.getPosition(doc.get(sel.getNodeId()));
        if ((up && nodePos === 0) || (down && nodePos === container.length-1)) {
          event.preventDefault();
          return
        }
        // Unfortunately we need to navigate out of an isolated node
        // manually, as even Chrome on Win is not able to do it.
        var editorSession = this.getEditorSession();
        // TODO the following fixes the mentioned problem for
        // regular UP/DOWN (non expanding)
        // For SHIFT+DOWN it happens to work, and only SHIFT-UP when started as NodeSelection needs to be fixed
        if (!event.shiftKey) {
          event.preventDefault();
          if (up) {
            var prev = container.getChildAt(nodePos-1);
            setCursor(editorSession, prev, sel.containerId, 'after');
            return
          } else {
            var next = container.getChildAt(nodePos+1);
            setCursor(editorSession, next, sel.containerId, 'before');
            return
          }
        }
      }
    }

    window.setTimeout(function () {
      this$1._updateModelSelection({ direction: direction });
    });
  };

  ContainerEditor.prototype._handleSpaceKey = function _handleSpaceKey (event) {
    var sel = this.getEditorSession().getSelection();
    if (sel.isNodeSelection() && sel.isFull()) {
      var comp = this.refs[sel.getNodeId()];
      if (comp && comp.grabFocus) {
        event.preventDefault();
        event.stopPropagation();
        comp.grabFocus();
        return
      }
    }
    Surface$$1.prototype._handleSpaceKey.call(this, event);
  };

  // Used by Clipboard
  ContainerEditor.prototype.isContainerEditor = function isContainerEditor () {
    return true
  };

  /**
    Returns the containerId the editor is bound to
  */
  ContainerEditor.prototype.getContainerId = function getContainerId () {
    return this.containerId
  };

  // TODO: do we really need this in addition to getContainerId?
  ContainerEditor.prototype.getContainer = function getContainer () {
    return this.getDocument().get(this.getContainerId())
  };

  ContainerEditor.prototype.isEmpty = function isEmpty () {
    var containerNode = this.getContainer();
    return (containerNode && containerNode.nodes.length === 0)
  };

  ContainerEditor.prototype.isEditable = function isEditable () {
    return Surface$$1.prototype.isEditable.call(this) && !this.isEmpty()
  };

  ContainerEditor.prototype.getTextTypes = function getTextTypes () {
    return this.textTypes || []
  };

  // Used by SwitchTextTypeTool
  // TODO: Filter by enabled commands for this Surface
  // TODO: rethink
  ContainerEditor.prototype.getTextCommands = function getTextCommands () {
    var textCommands = {};
    this.commandRegistry.each(function(cmd) {
      if (cmd.constructor.textTypeName) {
        textCommands[cmd.getName()] = cmd;
      }
    });
    return textCommands
  };

  // called by flow when subscribed resources have been updated
  ContainerEditor.prototype._onContainerChanged = function _onContainerChanged (change) {
    var this$1 = this;

    var doc = this.getDocument();
    // first update the container
    var renderContext = RenderingEngine.createContext(this);
    var $$ = renderContext.$$;
    var container = this.getContainer();
    var path = container.getContentPath();
    for (var i = 0; i < change.ops.length; i++) {
      var op = change.ops[i];
      if (op.type === "update" && op.path[0] === path[0]) {
        var diff = op.diff;
        if (diff.type === "insert") {
          var nodeId = diff.getValue();
          var node = doc.get(nodeId);
          var nodeEl = (void 0);
          if (node) {
            nodeEl = this$1._renderNode($$, node);
          } else {
            // node does not exist anymore
            // so we insert a stub element, so that the number of child
            // elements is consistent
            nodeEl = $$('div');
          }
          this$1.insertAt(diff.getOffset(), nodeEl);
        } else if (diff.type === "delete") {
          this$1.removeAt(diff.getOffset());
        }
      }
    }
  };

  return ContainerEditor;
}(Surface));

ContainerEditor.prototype._isContainerEditor = true;

var Toolbar = (function (Toolbox$$1) {
  function Toolbar () {
    Toolbox$$1.apply(this, arguments);
  }

  if ( Toolbox$$1 ) Toolbar.__proto__ = Toolbox$$1;
  Toolbar.prototype = Object.create( Toolbox$$1 && Toolbox$$1.prototype );
  Toolbar.prototype.constructor = Toolbar;

  Toolbar.prototype.render = function render ($$) {
    var this$1 = this;

    var el = $$('div').addClass(this.getClassNames());
    var activeToolGroups = this.state.activeToolGroups;

    activeToolGroups.forEach(function (toolGroup) {
      var toolGroupProps = Object.assign({}, toolGroup, {
        toolStyle: this$1.getToolStyle(),
        layout: 'horizontal',
        showIcons: true
      });
      el.append(
        $$(toolGroup.Class, toolGroupProps)
      );
    });
    return el
  };

  Toolbar.prototype.getActiveToolGroupNames = function getActiveToolGroupNames () {
    return this.props.toolGroups || ['text', 'document', 'annotations', 'default']
  };

  Toolbar.prototype.getClassNames = function getClassNames () {
    return 'sc-toolbar';
  };

  Toolbar.prototype.getToolStyle = function getToolStyle () {
    return 'outline'
  };

  Toolbar.prototype.showDisabled = function showDisabled () {
    return true
  };

  return Toolbar;
}(Toolbox));

var SpellError = (function (Marker$$1) {
  function SpellError () {
    Marker$$1.apply(this, arguments);
  }

  if ( Marker$$1 ) SpellError.__proto__ = Marker$$1;
  SpellError.prototype = Object.create( Marker$$1 && Marker$$1.prototype );
  SpellError.prototype.constructor = SpellError;

  SpellError.prototype.invalidate = function invalidate () {
    this.remove();
  };

  return SpellError;
}(Marker));

SpellError.schema = {
  type: 'spell-error',
  suggestions: { type: ['object'], default: [] }
};

SpellError.scope = 'document';

function sendRequest(params, cb) {
  return new Promise(function(resolve, reject) {
    var method = (params.method || 'GET').toUpperCase();
    var url = params.url;
    if (['GET', 'POST', 'PUT', 'DELETE'].indexOf(method) < 0) {
      throw new Error("Parameter 'method' must be 'GET', 'POST', 'PUT', or 'DELETE'.")
    }
    if (!url) {
      throw new Error("Parameter 'url' is required.")
    }
    var xmlhttp = new XMLHttpRequest();
    xmlhttp.onreadystatechange = function() {
      // TODO: we could support more states here to give feedback
      // e.g. about progress of an upload
      if (xmlhttp.readyState === 4) { return _done() }
    };
    xmlhttp.open(method, url, true);
    if (params.header) {
      forEach(params.header, function(val, key) {
        xmlhttp.setRequestHeader(key, val);
      });
    }
    if (params.data) {
      xmlhttp.send(JSON.stringify(params.data));
    } else {
      xmlhttp.send();
    }

    function _done() {
      if (xmlhttp.status === 200) {
        var response = xmlhttp.responseText;
        if (cb) { cb(null, response); }
        resolve(response);
      } else {
        console.error(xmlhttp.statusText);
        if (cb) { cb(xmlhttp.status); }
        reject(xmlhttp.statusText, xmlhttp.status);
      }
    }
  })
}

var DEFAULT_API_URL = 'http://localhost:4777/api/check';

var SpellCheckManager = function SpellCheckManager(editorSession, options) {
  options = options || {};
  var wait = options.wait || 750;

  this.editorSession = editorSession;
  this.apiURL = options.apiURL || DEFAULT_API_URL;

  // TODO: MarkersManager is basically a TextPropertyManager
  this.textPropertyManager = editorSession.markersManager;
  this.markersManager = editorSession.markersManager;

  this._schedule = {};
  this._scheduleCheck = debounce(this._runSpellCheck.bind(this), wait);

  editorSession.onFinalize('document', this._onDocumentChange, this);
};

SpellCheckManager.prototype.dispose = function dispose () {
  this.editorSession.off(this);
};

SpellCheckManager.prototype.check = function check (path) {
  this._runSpellCheck(String(path));
};

SpellCheckManager.prototype.runGlobalCheck = function runGlobalCheck () {
    var this$1 = this;

  var paths = Object.keys(this.textPropertyManager._textProperties);
  paths.forEach(function (p) {
    this$1._runSpellCheck(p);
  });
};

SpellCheckManager.prototype._onDocumentChange = function _onDocumentChange (change, info) {
    var this$1 = this;

  if (info.spellcheck) { return }
  // Note: instead of analyzing the model, we consider
  // all existing TextPropertyComponents instead
  // as this reflects what is presented to the user
  var textProperties = this.textPropertyManager._textProperties;
  Object.keys(change.updated).forEach(function (pathStr) {
    if (textProperties[pathStr]) { this$1._scheduleCheck(pathStr); }
  });
};

SpellCheckManager.prototype._runSpellCheck = function _runSpellCheck (pathStr) {
    var this$1 = this;

  // console.log('Running spell-checker on', pathStr)
  var path = pathStr.split(',');
  var text = this.editorSession.getDocument().get(path);
  var lang = this.editorSession.getLanguage();
  if (!text || !isString(text)) { return }
  sendRequest({
    method: 'POST',
    url: this.apiURL,
    header: {
      'Content-Type': 'application/json; charset=UTF-8',
    },
    data: {
      text: text,
      lang: lang
    }
  }).then(function (data) {
    data = JSON.parse(data);
    this$1._addSpellErrors(path, data);
  }).catch(function(err) {
    console.error(err);
  });
};

/*
  Called when spell corrections have been returned.

  Removes all spell errors on the given path first.
*/
SpellCheckManager.prototype._addSpellErrors = function _addSpellErrors (path, data) {
  var doc = this.editorSession.getDocument();
  var oldErrors = doc.getIndex('markers').get(path).filter(function (marker) {
    return marker.type === 'spell-error'
  });
  var newErrors = data.map(function(m) {
    return {
      type: 'spell-error',
      start: {
        path: path,
        offset: m.start
      },
      end: {
        offset: m.end
      },
      suggestions: m.suggestions
    }
  });
  this.editorSession.transaction(function (tx) {
    // remove the old markers first
    oldErrors.forEach(function (spellError) {
      tx.delete(spellError.id);
    });
    // then add the new ones
    newErrors.forEach(function (spellError) {
      tx.create(spellError);
    });
  }, { history: false, spellcheck: true });
};

var FontAwesomeIcon = (function (Component$$1) {
  function FontAwesomeIcon() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    Component$$1.apply(this, args);
  }

  if ( Component$$1 ) FontAwesomeIcon.__proto__ = Component$$1;
  FontAwesomeIcon.prototype = Object.create( Component$$1 && Component$$1.prototype );
  FontAwesomeIcon.prototype.constructor = FontAwesomeIcon;

  FontAwesomeIcon.prototype.render = function render ($$) {
    return $$('i').addClass('fa ' + this.props.icon)
  };

  return FontAwesomeIcon;
}(Component));

function includes$2(arr, val) {
  if (!arr) { return false }
  return (arr.indexOf(val) >= 0)
}

/*
  Manages a table of content for a container. Default implementation considers
  all headings as TOC entries. You can extend this implementation and override
  `computeEntries`. Instantiate this class on controller level and pass it to relevant components
  (such as {@link ui/TOCPanel} and {@link ui/ScrollPane}).

  @class TOCProvider
  @component

  @prop {Controller}
 */

var TOCProvider = (function (EventEmitter$$1) {
  function TOCProvider(document, config) {
    EventEmitter$$1.call(this, document, config);
    this.document = document;
    this.config = config;

    this.entries = this.computeEntries();
    if (this.entries.length > 0) {
      this.activeEntry = this.entries[0].id;
    } else {
      this.activeEntry = null;
    }

    this.document.on('document:changed', this.handleDocumentChange, this);
  }

  if ( EventEmitter$$1 ) TOCProvider.__proto__ = EventEmitter$$1;
  TOCProvider.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  TOCProvider.prototype.constructor = TOCProvider;

  TOCProvider.prototype.dispose = function dispose () {
    var doc = this.getDocument();
    doc.disconnect(this);
  };

  // Inspects a document change and recomputes the
  // entries if necessary
  TOCProvider.prototype.handleDocumentChange = function handleDocumentChange (change) {
    var doc = this.getDocument();
    var needsUpdate = false;
    var tocTypes = this.constructor.tocTypes;

    // HACK: this is not totally correct but works.
    // Actually, the TOC should be updated if tocType nodes
    // get inserted or removed from the container, plus any property changes
    // This implementation just checks for changes of the node type
    // not the container, but as we usually create and show in
    // a single transaction this works.
    for (var i = 0; i < change.ops.length; i++) {
      var op = change.ops[i];
      var nodeType = (void 0);
      if (op.isCreate() || op.isDelete()) {
        var nodeData = op.getValue();
        nodeType = nodeData.type;
        if (includes$2(tocTypes, nodeType)) {
          needsUpdate = true;
          break
        }
      } else {
        var id = op.path[0];
        var node = doc.get(id);
        if (node && includes$2(tocTypes, node.type)) {
          needsUpdate = true;
          break
        }
      }
    }
    if (needsUpdate) {
      this.entries = this.computeEntries();
      this.emit('toc:updated');
    }
  };

  TOCProvider.prototype.computeEntries = function computeEntries () {
    var doc = this.getDocument();
    var config = this.config;
    var entries = [];
    var contentNodes = doc.get(config.containerId).nodes;
    forEach(contentNodes, function(nodeId) {
      var node = doc.get(nodeId);
      if (node.type === 'heading') {
        entries.push({
          id: node.id,
          name: node.content,
          level: node.level,
          node: node
        });
      }
    });
    return entries
  };

  TOCProvider.prototype.getEntries = function getEntries () {
    return this.entries
  };

  TOCProvider.prototype.getDocument = function getDocument () {
    return this.document
  };

  TOCProvider.prototype.markActiveEntry = function markActiveEntry (scrollPane) {
    var panelContent = scrollPane.getContentElement();
    var contentHeight = scrollPane.getContentHeight();
    var scrollPaneHeight = scrollPane.getHeight();
    var scrollPos = scrollPane.getScrollPosition();

    var scrollBottom = scrollPos + scrollPaneHeight;
    var regularScanline = scrollPos;
    var smartScanline = 2 * scrollBottom - contentHeight;
    var scanline = Math.max(regularScanline, smartScanline);

    var tocNodes = this.computeEntries();
    if (tocNodes.length === 0) { return }

    // Use first toc node as default
    var activeEntry = tocNodes[0].id;
    for (var i = tocNodes.length - 1; i >= 0; i--) {
      var tocNode = tocNodes[i];
      var nodeEl = panelContent.find('[data-id="'+tocNode.id+'"]');
      if (!nodeEl) {
        console.warn('Not found in Content panel', tocNode.id);
        return
      }
      var panelOffset = scrollPane.getPanelOffsetForElement(nodeEl);
      if (scanline >= panelOffset) {
        activeEntry = tocNode.id;
        break
      }
    }

    if (this.activeEntry !== activeEntry) {
      this.activeEntry = activeEntry;
      this.emit('toc:updated');
    }
  };

  return TOCProvider;
}(EventEmitter));

TOCProvider.tocTypes = ['heading'];

var Router = (function (EventEmitter$$1) {
  function Router() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    EventEmitter$$1.apply(this, args);
    this.__isStarted__ = false;
  }

  if ( EventEmitter$$1 ) Router.__proto__ = EventEmitter$$1;
  Router.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Router.prototype.constructor = Router;

  /*
    Starts listening for hash-changes
  */
  Router.prototype.start = function start () {
    var window = DefaultDOMElement.getBrowserWindow();
    window.on('hashchange', this._onHashChange, this);
    this.__isStarted__ = true;
  };

  /*
    Reads out the current route
  */
  Router.prototype.readRoute = function readRoute () {
    if (!this.__isStarted__) { this.start(); }
    return this.parseRoute(this.getRouteString())
  };

  /*
    Writes out a given route as a string url
  */
  Router.prototype.writeRoute = function writeRoute (route, opts) {
    opts = opts || {};
    var routeString = this.stringifyRoute(route);
    if (!routeString) {
      this.clearRoute(opts);
    } else {
      this._writeRoute(routeString, opts);
    }
  };

  Router.prototype.dispose = function dispose () {
    var window = DefaultDOMElement.getBrowserWindow();
    window.off(this);
  };

  /*
    Maps a route URL to a route object

    @abstract
    @param String route content of the URL's hash fragment
  */
  Router.prototype.parseRoute = function parseRoute (routeString) {
    return Router.routeStringToObject(routeString)
  };

  /*
    Maps a route object to a route URL

    This can be overriden by an application specific router.

    @abstract
  */
  Router.prototype.stringifyRoute = function stringifyRoute (route) {
    return Router.objectToRouteString(route)
  };

  Router.prototype.getRouteString = function getRouteString () {
    return window.location.hash.slice(1)
  };

  Router.prototype._writeRoute = function _writeRoute (route, opts) {
    this.__isSaving__ = true;
    try {
      if (opts.replace) {
        window.history.replaceState({} , '', '#'+route);
      } else {
        window.history.pushState({} , '', '#'+route);
      }
    } finally {
      this.__isSaving__ = false;
    }
  };

  Router.prototype.clearRoute = function clearRoute (opts) {
    this._writeRoute('', opts);
  };

  Router.prototype._onHashChange = function _onHashChange () {
    // console.log('_onHashChange');
    if (this.__isSaving__) {
      return
    }
    if (this.__isLoading__) {
      console.error('FIXME: router is currently applying a route.');
      return
    }
    this.__isLoading__ = true;
    try {
      var routeString = this.getRouteString();
      var route = this.parseRoute(routeString);
      this.emit('route:changed', route);
    } finally {
      this.__isLoading__ = false;
    }
  };

  return Router;
}(EventEmitter));

Router.objectToRouteString = function(obj) {
  var route = [];
  forEach(obj, function(val, key) {
    route.push(key+'='+val);
  });
  return route.join(',')
};

Router.routeStringToObject = function(routeStr) {
  var obj = {};
  // Empty route maps to empty route object
  if (!routeStr) { return obj }
  var params = routeStr.split(',');
  params.forEach(function(param) {
    var tuple = param.split('=');
    if (tuple.length !== 2) {
      throw new Error('Illegal route.')
    }
    obj[tuple[0].trim()] = tuple[1].trim();
  });
  return obj
};

/*
  Registry for Nodes.

  @class NodeRegistry
  @extends util/Registry
 */
var NodeRegistry = (function (Registry$$1) {
  function NodeRegistry () {
    Registry$$1.apply(this, arguments);
  }

  if ( Registry$$1 ) NodeRegistry.__proto__ = Registry$$1;
  NodeRegistry.prototype = Object.create( Registry$$1 && Registry$$1.prototype );
  NodeRegistry.prototype.constructor = NodeRegistry;

  NodeRegistry.prototype.register = function register (nodeClazz) {
    var type = nodeClazz.prototype.type;
    if ( typeof type !== 'string' || type === '' ) {
      console.error('#### nodeClazz', nodeClazz);
      throw new Error( 'Node names must be strings and must not be empty')
    }
    if ( !( nodeClazz.prototype._isNode) ) {
      throw new Error( 'Nodes must be subclasses of Substance.Data.Node' )
    }
    if (this.contains(type)) {
      throw new Error('Node class is already registered: ' + type)
    }
    this.add(type, nodeClazz);
  };

  return NodeRegistry;
}(Registry));

/**
  Schema for Data Objects.

  @internal
 */
var Schema = function Schema(name, version) {
  /**
    @type {String}
  */
  this.name = name;
  /**
    @type {String}
  */
  this.version = version;
  /**
    @type {NodeRegistry}
    @private
  */
  this.nodeRegistry = new NodeRegistry();
  /**
    @type {Array} all Node classes which have `Node.tocType = true`
    @private
  */
  this.tocTypes = [];

  // add built-in node classes
  this.addNodes(this.getBuiltIns());
};

/**
  Add nodes to the schema.

  @param {Array} nodes Array of Node classes
*/
Schema.prototype.addNodes = function addNodes (nodes) {
  if (!nodes) { return }
  forEach(nodes, function(NodeClass) {
    if (!NodeClass.prototype._isNode) {
      console.error('Illegal node class: ', NodeClass);
    } else {
      this.addNode(NodeClass);
    }
  }.bind(this));
};

Schema.prototype.addNode = function addNode (NodeClass) {
  this.nodeRegistry.register(NodeClass);
  if (NodeClass.tocType) {
    this.tocTypes.push(NodeClass.type);
  }
};

/**
  Get the node class for a type name.

  @param {String} name
  @returns {Class}
*/
Schema.prototype.getNodeClass = function getNodeClass (name) {
  return this.nodeRegistry.get(name)
};

/**
  Provide all built-in node classes.

  @private
  @returns {Node[]} An array of Node classes.
*/
Schema.prototype.getBuiltIns = function getBuiltIns () {
  return []
};

/**
  Checks if a given type is of given parent type.

  @param {String} type
  @param {String} parentType
  @returns {Boolean} true if type is and instance of parentType.
*/
Schema.prototype.isInstanceOf = function isInstanceOf (type, parentType) {
  var NodeClass = this.getNodeClass(type);
  if (NodeClass) {
    return Node.isInstanceOf(NodeClass, parentType)
  }
  return false
};

/**
  Iterate over all registered node classes.

  See {@link util/Registry#each}

  @param {Function} callback
  @param {Object} context
*/
Schema.prototype.each = function each () {
  this.nodeRegistry.each.apply(this.nodeRegistry, arguments);
};

/**
  @returns {Node[]} list of types that should appear in a TOC
*/
Schema.prototype.getTocTypes = function getTocTypes () {
  return this.tocTypes
};

/**
  @returns {String} the name of the default textish node (e.g. 'paragraph')
*/
Schema.prototype.getDefaultTextType = function getDefaultTextType () {
  throw new Error('Schmema.prototype.getDefaultTextType() must be overridden.')
};

Schema.prototype.getNodeSchema = function getNodeSchema (type) {
  var NodeClass = this.getNodeClass(type);
  if (!NodeClass) {
    console.error('Unknown node type ', type);
    return null
  }
  return NodeClass.schema
};

/*
  Used to define custom article formats. Predefined node types can be combined with custom ones.

  Note: since introduction of packages DocumentSchema is not used explicitly
  but rather generated by a Configurator.

  @class
  @param {String} name schema identifier
  @param {String} schema schema version

  @example

  ```js
  import { PropertyAnnotation, Strong, Emphasis, Paragraph } from 'substance'

  class Comment extends PropertyAnnotation {}

  Comment.schema = {
    type: 'comment',
    content: 'string'
  }

  let schema = new Document.Schema('my-article')
  schema.getDefaultTextType = function() {
    return 'paragraph'
  }
  schema.addNodes([Paragraph, Emphasis, Strong, Comment])
  ```
*/

var DocumentSchema = (function (Schema$$1) {
  function DocumentSchema(name, version, options) {
    if ( options === void 0 ) options = {};

    Schema$$1.call(this, name, version);

    this.defaultTextType = options.defaultTextType;
  }

  if ( Schema$$1 ) DocumentSchema.__proto__ = Schema$$1;
  DocumentSchema.prototype = Object.create( Schema$$1 && Schema$$1.prototype );
  DocumentSchema.prototype.constructor = DocumentSchema;

  /**
    Returns default text type. E.g. used when hitting ENTER in a text node, which
    produces a new node of the type returned here. Abstract method, which must be implemented.

    @abstract
    @returns {String} default text type (e.g. 'paragraph')
  */

  DocumentSchema.prototype.getDefaultTextType = function getDefaultTextType () {
    return this.defaultTextType
  };

  DocumentSchema.prototype.isAnnotationType = function isAnnotationType (type) {
    var nodeClass = this.getNodeClass(type);
    return (nodeClass && nodeClass.prototype._isPropertyAnnotation)
  };

  DocumentSchema.prototype.getBuiltIns = function getBuiltIns () {
    return [DocumentNode, PropertyAnnotation, Container, ContainerAnnotation]
  };

  return DocumentSchema;
}(Schema));

var ComponentRegistry = (function (Registry$$1) {
  function ComponentRegistry(entries) {
    Registry$$1.call(this, entries, function(ComponentClass) {
      if (!ComponentClass.prototype._isComponent) {
        throw new Error('Component registry: wrong type. Expected a ComponentClass. Was: ' + String(ComponentClass))
      }
    });
  }

  if ( Registry$$1 ) ComponentRegistry.__proto__ = Registry$$1;
  ComponentRegistry.prototype = Object.create( Registry$$1 && Registry$$1.prototype );
  ComponentRegistry.prototype.constructor = ComponentRegistry;

  return ComponentRegistry;
}(Registry));

var FontAwesomeIconProvider = function FontAwesomeIconProvider(icons) {
  this.map = {};
  forEach(icons, function(config, name) {
    var faClass = config['fontawesome'];
    if (faClass) {
      this.addIcon(name, faClass);
    }
  }.bind(this));
};

FontAwesomeIconProvider.prototype.renderIcon = function renderIcon ($$, name) {
  var iconClass = this.map[name];
  if (iconClass) {
    return $$(FontAwesomeIcon, {icon:iconClass})
  }
};

FontAwesomeIconProvider.prototype.addIcon = function addIcon (name, faClass) {
  this.map[name] = faClass;
};

/**
 Default label provider implementation

 @internal
*/
var DefaultLabelProvider = function DefaultLabelProvider(labels, lang) {
  this.lang = lang || 'en';
  this.labels = labels;
};

DefaultLabelProvider.prototype.getLabel = function getLabel (name) {
  var labels = this.labels[this.lang];
  if (!labels) { return name }
  return labels[name] || name
};

var ToolGroup = (function (Component$$1) {
  function ToolGroup () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) ToolGroup.__proto__ = Component$$1;
  ToolGroup.prototype = Object.create( Component$$1 && Component$$1.prototype );
  ToolGroup.prototype.constructor = ToolGroup;

  ToolGroup.prototype.render = function render ($$) {
    var this$1 = this;


    var tools = this.props.tools;
    var el = $$('div').addClass('sc-tool-group');
    el.addClass('sm-target-'+this.props.name);
    if (this.props.layout) {
      el.addClass('sm-layout-'+this.props.layout);
    }

    tools.forEach(function (tool) {
      var toolProps = Object.assign({}, tool.toolProps, {
        showIcon: this$1.props.showIcons,
        showLabel: this$1.props.showLabels,
        style: this$1.props.toolStyle
      });
      el.append(
        $$(tool.Class, toolProps)
      );
    });
    return el
  };

  return ToolGroup;
}(Component));

var SaveHandlerStub = function SaveHandlerStub () {};

SaveHandlerStub.prototype.saveDocument = function saveDocument (ref) {
    var fileManager = ref.fileManager;

  console.info('Simulating save ...');

  return fileManager.sync()
  .then(function () {
    // Here you would run a converter (HTML/XML) usually
    // and send the result to a REST endpoint.
    console.info('Creating document snapshot...');
  })

};

/**
  Default Configurator for Substance editors. It provides an API for
  adding nodes to the schema, components, commands and tools etc.

  @class

  @example

  ```js
  let configurator = new Configurator()

  configurator.addNode(Heading)
  configurator.addComponent('heading', HeadingComponent)
  ```

  To modularize configuration, package definitions can be imported.

  ```js
  configurator.import(ParagraphPackage)
  ```

  You can create your own extensions that way.

  ```js

  const AlienPackage = {
    name: 'alien'
    configure: function(config) {
      config.addNode(AlienNode)
      config.addComponent('alien', AlienComponent)
      config.addCommand('add-alien', AddAlienCommand)
      config.addTool('add-alien', AddAlienTool)
    }
  }

  ```

  From within a package, another package can be imported. This provides
  a simple mechanism to model dependencies between packages. Just make
  sure you don't run into cyclic dependencies as there is no checking for
  that at the moment.
*/
var Configurator = function Configurator() {
  this.config = {
    schema: {},
    nodes: {},
    components: {},
    converters: {},
    importers: {},
    exporters: {},
    fileProxies: [],
    commands: {},
    tools: new Map(),
    toolGroups: new Map(),
    textTypes: [],
    editingBehaviors: [],
    macros: [],
    dropHandlers: [],
    keyboardShortcuts: [],
    icons: {},
    labels: {},
    lang: 'en_US',
    SaveHandlerClass: null
  };
};

// Record phase API
// ------------------------

/**
  Defines the document schema for this configuration.

  @param{DocumentSchema} schema A schema to be used for articles created
      from this configuration.
 */
Configurator.prototype.defineSchema = function defineSchema (schema) {
  this.config.schema = schema;
};

/**
  Adds a node to this configuration. Later, when you use
  {@link Configurator#getSchema()}, this node will be added to that schema.
  Usually, used within a package to add its own nodes to the schema.

  @param {Node} NodeClass
 */
Configurator.prototype.addNode = function addNode (NodeClass) {
  var type = NodeClass.type;
  if (!type) {
    throw new Error('A NodeClass must have a type.')
  }
  if (this.config.nodes[type]) {
    throw new Error('NodeClass with this type name is already registered: ' + type)
  }
  this.config.nodes[type] = NodeClass;
};

/**
  Adds a converter for a conversion format.

  @param {string} type    a conversion format type, eg. 'html', 'xml', 'json'
  @param {Object} converter a converter for that format.
 */
Configurator.prototype.addConverter = function addConverter (type, converter) {
  var converters = this.config.converters[type];
  if (!converters) {
    converters = {};
    this.config.converters[type] = converters;
  }
  if (!converter.type) {
    throw new Error('A converter needs an associated type.')
  }
  converters[converter.type] = converter;
};

/**
  Add importer for a conversion format.

  @param {string} type        a conversion format type. eg. 'html', 'xml'
  @param {Object} ImporterClass an importer for the conversion format.
 */
Configurator.prototype.addImporter = function addImporter (type, ImporterClass) {
  this.config.importers[type] = ImporterClass;
};

/**
  Add exporter for a conversion format.

  @param {string} type        a conversion format type. eg. 'html', 'xml'
  @param {Object} ExporterClass an exporter for the conversion format.
 */
Configurator.prototype.addExporter = function addExporter (type, ExporterClass) {
  this.config.exporters[type] = ExporterClass;
};

/**
  Add a component for a node type. Components ({@link Component}) are the
  ui representation of a node for rendering and manipulation. This is usually
  used within a package to add representations for nodes added by that
  package.

  A component can be added once per nodeType. If you provide two components
  for the same node type, Substance can't figure out which one to use.

  @param {String} nodeType     the type attribute of the node for which this
                                 component is to be used.
  @param {Class} ComponentClassA subclass of {@link Component} for nodes
                                 of nodeType.
 */
Configurator.prototype.addComponent = function addComponent (nodeType, ComponentClass, force) {
  if (!force && this.config.components[nodeType]) {
    throw new Error(nodeType+' already registered')
  }
  if (!ComponentClass) {
    throw new Error('Provided nil for component '+nodeType)
  }
  if (!ComponentClass.prototype._isComponent) {
    throw new Error('ComponentClass must be a subclass of ui/Component.')
  }
  this.config.components[nodeType] = ComponentClass;
};

Configurator.prototype.addCommand = function addCommand (name, CommandClass, options) {
  if (!isString(name)) {
    throw new Error("Expecting 'name' to be a String")
  }
  if (!CommandClass) {
    throw new Error('Provided nil for command '+name)
  }
  if (!CommandClass.prototype._isCommand) {
    throw new Error("Expecting 'CommandClass' to be of type ui/Command.")
  }
  this.config.commands[name] = {
    name: name,
    CommandClass: CommandClass,
    options: options || {}
  };
};

Configurator.prototype.addToolGroup = function addToolGroup (name, ToolGroupClass, options) {
  options = options || {};
  ToolGroupClass = ToolGroupClass || ToolGroup;

  this.config.toolGroups.set(name, {
    name: name,
    tools: new Map(),
    Class: ToolGroupClass,
    options: options
  });
};

Configurator.prototype.addTool = function addTool (name, ToolClass, options) {
    var this$1 = this;

  options = options || {};

  if (options.target) {
    console.warn('DEPRECATED: please use `toolGroup` instead of `target`', name);
  }
  var toolGroupNames = options.toolGroup || options.target;
  if (isString(toolGroupNames)) {
    toolGroupNames = [ toolGroupNames ];
  }

  if (!toolGroupNames && options.overlay) {
    toolGroupNames = [ 'overlay' ];
  } else if (!toolGroupNames) {
    toolGroupNames = [ 'default' ];
  }

  if (!isString(name)) {
    throw new Error("Expecting 'name' to be a String")
  }
  if (!ToolClass) {
    throw new Error('Provided nil for tool '+name)
  }
  if (!ToolClass || !ToolClass.prototype._isTool) {
    throw new Error("Expecting 'ToolClass' to be of type ui/Tool. name:")
  }

  toolGroupNames.forEach(function (toolGroupName) {
    var toolGroup = this$1.config.toolGroups.get(toolGroupName);
    if (!toolGroup) {
      console.error(("No toolGroup registered with name: " + toolGroupName));
      return
    }
    toolGroup.tools.set(name, {
      name: name,
      Class: ToolClass,
      options: options || {}
    });
  });
};

/**
  Adds an icon to the configuration which can be later retrieved via the
  iconProvider.

  @param {string} iconName name or key for retrieving the icon
  @param {Object} optionsyour custom method of representing the icon as a
      JSON object. Enables plugging in your own IconProvider.
 */
Configurator.prototype.addIcon = function addIcon (iconName, options) {
  var iconConfig = this.config.icons[iconName];
  if (!iconConfig) {
    iconConfig = {};
    this.config.icons[iconName] = iconConfig;
  }
  Object.assign(iconConfig, options);
};

/**
  Define a new label
  Label is either a string or a hash with translations.
  If string is provided 'en' is used as the language.

  @param {String} labelName name of label.
  @param {String} label label.

  @example

  ```
  // Using english only.
  config.addLabel('paragraph.content', 'Paragraph')

  // Using multiple languages
  config.addLabel('superscript', {
    en: 'Superscript',
    de: 'Hochgestellt'
  })

  .
  .
  // Usage within other code
  let labels = this.context.labelProvider
  $$('span').append(labels.getLabel('superscript'))
  ```
*/
Configurator.prototype.addLabel = function addLabel (labelName, label) {
  if (isString(label)) {
    if(!this.config.labels['en']) {
      this.config.labels['en'] = {};
    }
    this.config.labels['en'][labelName] = label;
  } else {
    forEach(label, function(label, lang) {
      if (!this.config.labels[lang]) {
        this.config.labels[lang] = {};
      }
      this.config.labels[lang][labelName] = label;
    }.bind(this));
  }
};

/**
  Replaces the seed function for this configuration.

  Use a seed function to create the empty state for your document. This should
  be used only once per configuration. You shouldn't call this within package
  config methods.

  You can use {@link Configurator#getSeed} method to get this seed and
  apply it on your document {@link Document} class.

  @param {function} seed A transaction function that creates the seed
      document from an empty document.

  @example

  ```js
  var seedFn = function(tx) {
    var body = tx.get('body')

    tx.create({
      id: 'p1',
      type: 'paragraph',
      content: 'This is your new paragraph!'
    })
    body.show('p1')
  }

  config.addSeed(seedFn)
  ```
*/
Configurator.prototype.addSeed = function addSeed (seed) {
  this.config.seed = seed;
};

Configurator.prototype.addTextType = function addTextType (textType, options) {
  this.config.textTypes.push({
    spec: textType,
    options: options || {}
  });
};

/**
  Adds an editing behavior to this configuration. {@link EditingBehavior}
  for more.

  @param {EditingBehavior} editingBehavior.
 */
Configurator.prototype.addEditingBehavior = function addEditingBehavior (editingBehavior) {
  this.config.editingBehaviors.push(editingBehavior);
};

Configurator.prototype.addMacro = function addMacro (macro) {
  this.config.macros.push(macro);
};

Configurator.prototype.addDragAndDrop = function addDragAndDrop (DragAndDropHandlerClass) {
  // we deprecated this after it became more clear what
  // we actually needed to solve
  console.warn('DEPRECATED: Use addDropHandler() instead');
  if (!DragAndDropHandlerClass.prototype._isDragAndDropHandler) {
    throw new Error('Only instances of DragAndDropHandler are allowed.')
  }
  this.addDropHandler(new DragAndDropHandlerClass());
};

Configurator.prototype.addDropHandler = function addDropHandler (dropHandler) {
  // legacy
  if (dropHandler._isDragAndDropHandler) {
    dropHandler.type = dropHandler.type || 'drop-asset';
  }
  this.config.dropHandlers.push(dropHandler);
};

Configurator.prototype.addKeyboardShortcut = function addKeyboardShortcut (combo, spec) {
  var entry = {
    key: combo,
    spec: spec
  };
  this.config.keyboardShortcuts.push(entry);
};

Configurator.prototype.addFileProxy = function addFileProxy (FileProxyClass) {
  this.config.fileProxies.push(FileProxyClass);
};

Configurator.prototype.getFileAdapters = function getFileAdapters () {
  return this.config.fileProxies.slice(0)
};

/**
  Configure this instance of configuration for provided package.
  @param{Object} pkg   Object should contain a `configure` method that
                           takes a Configurator instance as the first method.
  @param{Object} options Additional options to pass to the
                           package.`configure` method

  @return {configurator} returns the configurator instance to make it easy
                           to chain calls to import.
 */
Configurator.prototype.import = function import$1 (pkg, options) {
  pkg.configure(this, options || {});
  return this
};

// Config Interpreter APIs
// ------------------------

Configurator.prototype.getConfig = function getConfig () {
  return this.config
};

Configurator.prototype.getStyles = function getStyles () {
  return this.config.styles
};

Configurator.prototype.getSchema = function getSchema () {
  var schemaConfig = this.config.schema;
  // TODO: We may want to remove passing a schema version as
  // the version is defined by the repository / npm package version
  var schema = new DocumentSchema(schemaConfig.name, '1.0.0');
  schema.getDefaultTextType = function() {
    return schemaConfig.defaultTextType
  };
  schema.addNodes(this.config.nodes);
  return schema
};

Configurator.prototype.createArticle = function createArticle (seed) {
  var schemaConfig = this.config.schema;
  var schema = this.getSchema();
  var doc = new schemaConfig.ArticleClass(schema);
  if (seed) {
    seed(doc);
  }
  return doc
};

Configurator.prototype.createImporter = function createImporter (type, context, options) {
    if ( options === void 0 ) options = {};

  var ImporterClass = this.config.importers[type];
  var config = Object.assign({
    schema: this.getSchema(),
    converters: this.getConverterRegistry().get(type),
    DocumentClass: this.config.schema.ArticleClass
  }, options);
  return new ImporterClass(config, context)
};

Configurator.prototype.createExporter = function createExporter (type, context, options) {
    if ( options === void 0 ) options = {};

  var ExporterClass = this.config.exporters[type];
  var config = Object.assign({
    schema: this.getSchema(),
    converters: this.getConverterRegistry().get(type)
  }, options);
  return new ExporterClass(config, context)
};

Configurator.prototype.getToolGroups = function getToolGroups () {
  return this.config.toolGroups
};

Configurator.prototype.getTools = function getTools (toolGroupName) {
  return this.config.toolGroups.get(toolGroupName).tools
};

Configurator.prototype.getComponentRegistry = function getComponentRegistry () {
  var componentRegistry = new ComponentRegistry();
  forEach(this.config.components, function(ComponentClass, name) {
    componentRegistry.add(name, ComponentClass);
  });
  return componentRegistry
};

Configurator.prototype.getCommands = function getCommands () {
  return map(this.config.commands, function(item, name) {
    return new item.CommandClass(Object.assign({name: name}, item.options))
  })
};

Configurator.prototype.getSurfaceCommandNames = function getSurfaceCommandNames () {
  var commands = this.getCommands();
  var commandNames = commands.map(function(C) {
    return C.type
  });
  return commandNames
};

/*
  A converter registry is a registry by file type and then by node type

  `configurator.getConverterRegistry().get('html').get('paragraph')` provides
  a HTML converter for Paragraphs.
*/
Configurator.prototype.getConverterRegistry = function getConverterRegistry () {
  if (!this.converterRegistry) {
    var converterRegistry = new Registry();
    forEach(this.config.converters, function(converters, name) {
      converterRegistry.add(name, new Registry(converters));
    });
    this.converterRegistry = converterRegistry;
  }
  return this.converterRegistry
};

Configurator.prototype.getDropHandlers = function getDropHandlers () {
  return this.config.dropHandlers.slice(0)
};

Configurator.prototype.getSeed = function getSeed () {
  return this.config.seed
};

Configurator.prototype.getTextTypes = function getTextTypes () {
  return this.config.textTypes.map(function(t) {
    return t.spec
  })
};

Configurator.prototype.getIconProvider = function getIconProvider () {
  return new FontAwesomeIconProvider(this.config.icons)
};

Configurator.prototype.getLabelProvider = function getLabelProvider () {
  return new DefaultLabelProvider(this.config.labels)
};

Configurator.prototype.getEditingBehavior = function getEditingBehavior () {
  var editingBehavior = new EditingBehavior();
  this.config.editingBehaviors.forEach(function(behavior) {
    behavior.register(editingBehavior);
  });
  return editingBehavior
};

Configurator.prototype.getMacros = function getMacros () {
  return this.config.macros
};

Configurator.prototype.getKeyboardShortcuts = function getKeyboardShortcuts () {
  return this.config.keyboardShortcuts
};

Configurator.prototype.setDefaultLanguage = function setDefaultLanguage (lang) {
  this.config.lang = lang;
};

Configurator.prototype.getDefaultLanguage = function getDefaultLanguage () {
  return this.config.lang || 'en_US'
};

Configurator.prototype.setSaveHandlerClass = function setSaveHandlerClass (SaveHandlerClass) {
  this.config.SaveHandlerClass = SaveHandlerClass;
};

Configurator.prototype.getSaveHandler = function getSaveHandler () {
  var SaveHandler = this.config.SaveHandlerClass || SaveHandlerStub;
  return new SaveHandler()
};

/*
  Run the functions in the tasks collection in series.

  NOTE: You can not access results of the executed functions
*/

// collab

/**
  We extend from AbstractEditor which provides an abstract implementation
  that should be feasible for most editors.
*/
var SimpleWriter = (function (AbstractEditor$$1) {
  function SimpleWriter () {
    AbstractEditor$$1.apply(this, arguments);
  }

  if ( AbstractEditor$$1 ) SimpleWriter.__proto__ = AbstractEditor$$1;
  SimpleWriter.prototype = Object.create( AbstractEditor$$1 && AbstractEditor$$1.prototype );
  SimpleWriter.prototype.constructor = SimpleWriter;

  SimpleWriter.prototype.render = function render ($$) {
    var SplitPane$$1 = this.componentRegistry.get('split-pane');
    var el = $$('div').addClass('sc-simple-writer');
    var ScrollPane$$1 = this.componentRegistry.get('scroll-pane');
    var Overlay = this.componentRegistry.get('overlay');
    var ContextMenu = this.componentRegistry.get('context-menu');
    var Dropzones$$1 = this.componentRegistry.get('dropzones');
    var commandStates = this.commandManager.getCommandStates();
    var configurator = this.props.editorSession.getConfigurator();
    var Body = this.componentRegistry.get('body');
    var contentPanel = $$(ScrollPane$$1, {
      scrollbarPosition: 'right'
    }).append(
      $$(Body, {
        disabled: this.props.disabled,
        node: this.doc.get('body'),
        commands: configurator.getSurfaceCommandNames(),
        textTypes: configurator.getTextTypes()
      }).ref('body'),
      $$(Overlay),
      $$(ContextMenu),
      $$(Dropzones$$1)
    ).ref('contentPanel');

    el.append(
      $$(SplitPane$$1, {splitType: 'horizontal'}).append(
        $$('div').addClass('se-toolbar-wrapper').append(
          $$(Toolbar, {
            commandStates: commandStates
          }).ref('toolbar')
        ),
        contentPanel
      )
    );
    return el
  };

  return SimpleWriter;
}(AbstractEditor));

var Body = (function (Container$$1) {
  function Body () {
    Container$$1.apply(this, arguments);
  }if ( Container$$1 ) Body.__proto__ = Container$$1;
  Body.prototype = Object.create( Container$$1 && Container$$1.prototype );
  Body.prototype.constructor = Body;

  

  return Body;
}(Container));

Body.define({
  type: 'body'
});

var BodyConverter = {
  type: 'body',
  tagName: 'body',

  import: function(el, node, converter) {
    node.id = 'body';
    node.nodes = el.getChildren().map(function(child) {
      var childNode = converter.convertElement(child);
      return childNode.id
    });
  },

  export: function(node, el, converter) {
    el.append(converter.convertNodes(node.nodes));
  }
};

var BodyComponent = (function (Component$$1) {
  function BodyComponent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) BodyComponent.__proto__ = Component$$1;
  BodyComponent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  BodyComponent.prototype.constructor = BodyComponent;

  BodyComponent.prototype.render = function render ($$) {
    var node = this.props.node;
    var el = $$('div')
      .addClass('sc-body')
      .attr('data-id', this.props.node.id);

    el.append(
      $$(ContainerEditor, {
        disabled: this.props.disabled,
        node: node,
        commands: this.props.commands,
        textTypes: this.props.textTypes
      }).ref('body')
    );
    return el;
  };

  return BodyComponent;
}(Component));

var BodyPackage = {
  name: 'body',
  configure: function(config) {
    config.addNode(Body);
    config.addComponent(Body.type, BodyComponent);
    config.addConverter('html', BodyConverter);
  }
};

/**
  Comment node type, based on PropertyAnnotation. Defines
  comment property which holds the comment content as a string.
*/
var Comment = (function (PropertyAnnotation$$1) {
  function Comment () {
    PropertyAnnotation$$1.apply(this, arguments);
  }if ( PropertyAnnotation$$1 ) Comment.__proto__ = PropertyAnnotation$$1;
  Comment.prototype = Object.create( PropertyAnnotation$$1 && PropertyAnnotation$$1.prototype );
  Comment.prototype.constructor = Comment;

  

  return Comment;
}(PropertyAnnotation));

Comment.define({
  type: 'comment',
  content: { type: 'string', default: '' }
});

// in presence of overlapping annotations will try to render this as one element
Comment.fragmentation = Fragmenter.SHOULD_NOT_SPLIT;

/**
  Command implementation used for creating, expanding and
  truncating comments.

  Fusion and deletion are disabled as these are handled by EditCommentTool.
*/
var CommentCommand = (function (AnnotationCommand$$1) {
  function CommentCommand () {
    AnnotationCommand$$1.apply(this, arguments);
  }

  if ( AnnotationCommand$$1 ) CommentCommand.__proto__ = AnnotationCommand$$1;
  CommentCommand.prototype = Object.create( AnnotationCommand$$1 && AnnotationCommand$$1.prototype );
  CommentCommand.prototype.constructor = CommentCommand;

  CommentCommand.prototype.canFuse = function canFuse ()   { return false };
  CommentCommand.prototype.canDelete = function canDelete () { return false };

  return CommentCommand;
}(AnnotationCommand));

/**
  Simple comment editor, based on a regular
  input field. Changes are saved when the input
  field is blurred.
*/
var EditCommentTool = (function (Tool$$1) {
  function EditCommentTool () {
    Tool$$1.apply(this, arguments);
  }

  if ( Tool$$1 ) EditCommentTool.__proto__ = Tool$$1;
  EditCommentTool.prototype = Object.create( Tool$$1 && Tool$$1.prototype );
  EditCommentTool.prototype.constructor = EditCommentTool;

  EditCommentTool.prototype.render = function render ($$) {
    var Input$$1 = this.getComponent('input');
    var Button$$1 = this.getComponent('button');
    var el = $$('div').addClass('sc-edit-comment-tool');

    el.append(
      $$(Input$$1, {
        type: 'text',
        path: [this.props.node.id, 'content'],
        placeholder: 'Please enter comment here'
      }),
      $$(Button$$1, {
        icon: 'delete',
        style: this.props.style
      }).on('click', this.onDelete)
    );
    return el
  };

  EditCommentTool.prototype.onDelete = function onDelete (e) {
    e.preventDefault();
    var node = this.props.node;
    var session = this.context.editorSession;
    session.transaction(function(tx, args) {
      tx.delete(node.id);
      return args
    });
  };

  return EditCommentTool;
}(Tool));

var CommentConverter = {

  type: 'comment',
  tagName: 'span',

  /**
    Custom matcher, needed as matching by tagName is not sufficient
  */
  matchElement: function(el) {
    return el.is('span[data-type="comment"]')
  },

  /**
    Extract comment string from the data-comment attribute
  */
  import: function(el, node) {
    node.content = el.attr('data-comment');
  },

  /**
    Serialize comment node to span with data-type and data-comment
    attributes.
  */
  export: function(node, el) {
    el.attr({
      'data-type': 'comment',
      'data-comment': node.content
    }.append(node.content));
  }
};

/**
  Comment package that can be imported by SimpleWriter

  Provides a Comment node definition, a converter for HTML conversion,
  commands and tools for creation, and editing of comments.
*/
var CommentPackage = {
  name: 'link',
  configure: function(config, options) {
    config.addNode(Comment);
    config.addConverter('html', CommentConverter);

    // Tool to insert a new comment
    config.addCommand('comment', CommentCommand, {nodeType: 'comment'});
    config.addTool('comment', AnnotationTool, {toolGroup: options.toolGroup || 'annotations'});
    // Tool to edit an existing comment, should be displayed as an overlay
    config.addCommand('edit-comment', EditAnnotationCommand, {nodeType: 'comment'});
    config.addTool('edit-comment', EditCommentTool, { toolGroup: 'overlay' });

    // Icons and labels
    config.addIcon('comment', { 'fontawesome': 'fa-comment'});
    config.addLabel('comment', 'Comment');
  }
};

/**
  HTML importer for the SimpleArticle. We delegate the work to
  BodyConverter.
*/
var SimpleHTMLImporter = (function (HTMLImporter$$1) {
  function SimpleHTMLImporter () {
    HTMLImporter$$1.apply(this, arguments);
  }

  if ( HTMLImporter$$1 ) SimpleHTMLImporter.__proto__ = HTMLImporter$$1;
  SimpleHTMLImporter.prototype = Object.create( HTMLImporter$$1 && HTMLImporter$$1.prototype );
  SimpleHTMLImporter.prototype.constructor = SimpleHTMLImporter;

  SimpleHTMLImporter.prototype.convertDocument = function convertDocument (htmlEl) {
    var bodyEl = htmlEl.find('body');
    this.convertElement(bodyEl);
  };

  return SimpleHTMLImporter;
}(HTMLImporter));

/**
  Standard configuration for SimpleWriter

  We define a schema (simple-article) import some core packages
  from Substance, as well as custom node types.

  An HTML importer is registered to be able to turn HTML markup
  into a SimpleArticle instance.
*/
var SimpleWriterPackage = {
  name: 'simple-writer',
  configure: function (config) {
    config.defineSchema({
      name: 'simple-article',
      ArticleClass: Document,
      defaultTextType: 'paragraph'
    });

    // BasePackage provides core functionaliy, such as undo/redo
    // and the SwitchTextTypeTool. However, you could import those
    // functionalities individually if you need more control
    config.import(BasePackage);
    config.import(SwitchTextTypePackage);
    // core nodes
    config.import(ParagraphPackage);
    config.import(HeadingPackage);
    config.import(CodeblockPackage);
    config.import(StrongPackage, {toolGroup: 'annotations'});
    config.import(EmphasisPackage, {toolGroup: 'annotations'});
    config.import(LinkPackage, {toolGroup: 'annotations'});

    // custom nodes
    config.import(BodyPackage);
    config.import(CommentPackage, {toolGroup: 'annotations'});

    // Override Importer/Exporter
    config.addImporter('html', SimpleHTMLImporter);
  }
};

var fixture = "<html><body>\n  <h1>SimpleWriterasdasasd</h1>\n  <p>This is the official <span data-type=\"comment\" data-comment=\"A JavaScript library for web-based content editing\">Substance</span> editor boilerplate example. Fork it, and create your own editor.</p>\n  <p>You can find the source code on <a href=\"http://github.com/substance/starter\">Github</a>.</p>\n</body></html>";

var cfg = new Configurator();
cfg.import(SimpleWriterPackage);

window.onload = function() {
  // Import article from HTML markup
  var importer = cfg.createImporter('html');
  var doc = importer.importDocument(fixture);
  // This is the data structure manipulated by the editor
  var editorSession = new EditorSession(doc, {
    configurator: cfg
  });
  // Mount SimpleWriter to the DOM and run it.
  SimpleWriter.mount({
    editorSession: editorSession
  }, document.body);
};

})));

//# sourceMappingURL=./app.js.map